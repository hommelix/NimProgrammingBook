<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="A gentle Introduction (C) Dr. Stefan Salewski 2020, 2021, 2022">
<title>Computer Programming with the Nim Programming Language</title>
<style>
@import "/home/stefan/asciidoctor-stylesheet-factory/stylesheets/asciidoctor.css";

/* https://github.com/asciidoctor/asciidoctor.org/issues/422 */

:root{
--maincolor:#00FFFF;
--primarycolor:#000000;
--secondarycolor:#AAAA00;
--tertiarycolor:#CCCCCC;
--sidebarbackground:#CACACA;
--linkcolor:#0D47A1;
--linkcoloralternate:#B71C1C;
--white:#FFFFFF;
--black:#000000;
}


.var{font-family: monospace; background-color: #DDD; color: #000}
.code{font-family: monospace; background-color: #DDD; color: #000}
.term{font-family: monospace; background-color: #DDD; color: #000}
.ndef{font-style: italic; color: #000}


.userinput{font-family: monospace, monospace;color:#000; font-size:80%;}

.monospace{font-family: monospace, monospace;color:#000; background-color: #EEE; font-size:70%;}

.important{color: #000; background-color:#FF0}

.new{color: #000; background-color:#FF0}

.dim{font-style: italic}

.quote{} 

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Computer Programming with the Nim Programming Language</h1>
<div class="details">
<span id="author" class="author">A gentle Introduction (C) Dr. Stefan Salewski 2020, 2021, 2022</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_about_this_book">About this book</a></li>
<li><a href="#_part_i_introduction">Part I: Introduction</a>
<ul class="sectlevel1">
<li><a href="#_what_is_a_computer">What is a Computer?</a></li>
<li><a href="#_analog_and_digital">Analog and Digital</a></li>
<li><a href="#_what_is_an_operating_system">What is an Operating System?</a></li>
<li><a href="#_what_is_computer_programming">What is Computer Programming?</a></li>
<li><a href="#_what_is_a_computer_program">What is a Computer Program?</a></li>
<li><a href="#_what_is_an_algorithm">What is an Algorithm?</a></li>
<li><a href="#_what_is_a_programming_language">What is a Programming Language?</a></li>
<li><a href="#_compilers_and_interpreters">Compilers and Interpreters</a></li>
<li><a href="#_types_of_programming_languages">Types of Programming Languages</a></li>
<li><a href="#_why_nim">Why Nim?</a>
<ul class="sectlevel2">
<li><a href="#_some_facts_about_nim">Some Facts About Nim</a></li>
<li><a href="#_nim_supports_many_programming_styles">Nim supports many programming styles</a></li>
<li><a href="#_nim_is_efficient">Nim is Efficient</a></li>
<li><a href="#_nim_is_expressive_and_elegant">Nim is Expressive and Elegant</a></li>
<li><a href="#_nim_is_open_and_free">Nim is Open and Free</a></li>
<li><a href="#_nim_has_a_friendly_and_helpful_growing_community">Nim has a friendly and helpful growing community</a></li>
<li><a href="#_nim_has_a_encouraging_future">Nim has a encouraging future</a></li>
<li><a href="#_why_is_nim_not_a_popular_mainstream_language_yet">Why is Nim not a popular mainstream language yet?</a></li>
<li><a href="#_is_nim_a_good_choice_as_first_language_for_a_beginner">Is Nim a good choice as first language for a Beginner?</a></li>
<li><a href="#_is_nim_really_a_good_teaching_language">Is Nim really a good teaching language?</a></li>
<li><a href="#_so_is_nim_really_the_best_start_for_me">So is Nim really the best start for me?</a></li>
<li><a href="#_after_learning_nim_will_i_still_have_to_learn_other_programming_languages">After learning Nim, will I still have to learn other programming languages?</a></li>
<li><a href="#_why_should_i_not_use_nim">Why should I not use Nim?</a></li>
</ul>
</li>
<li><a href="#_our_first_nim_program">Our first Nim Program</a></li>
<li><a href="#_binary_numbers">Binary Numbers</a></li>
<li><a href="#_hexadecimal_numbers">Hexadecimal Numbers</a></li>
<li><a href="#_installation_of_the_compiler">Installation of the Compiler</a></li>
<li><a href="#_creation_of_source_code_files">Creation of Source Code Files</a></li>
<li><a href="#_launching_the_compiler_and_running_the_program">Launching the compiler and running the program</a></li>
</ul>
</li>
<li><a href="#_part_ii_the_basics">Part II: The Basics</a>
<ul class="sectlevel1">
<li><a href="#_declarations">Declarations</a></li>
<li><a href="#_statements">Statements</a></li>
<li><a href="#_input_and_output">Input and Output</a></li>
<li><a href="#_data_types">Data types</a>
<ul class="sectlevel2">
<li><a href="#_integer_types">Integer types</a></li>
<li><a href="#_floating_point_types">Floating point types</a></li>
<li><a href="#_distinct_types">Distinct types</a></li>
<li><a href="#_subrange_types">Subrange types</a></li>
<li><a href="#_enums">Enums</a></li>
<li><a href="#_boolean_types">Boolean types</a></li>
<li><a href="#_characters">Characters</a></li>
<li><a href="#_ordinal_types">Ordinal types</a></li>
<li><a href="#_sets">Sets</a></li>
<li><a href="#_strings">Strings</a></li>
<li><a href="#_comments">Comments</a></li>
<li><a href="#_other_data_types">Other data types</a></li>
</ul>
</li>
<li><a href="#_nim_source_code">Nim Source Code</a>
<ul class="sectlevel2">
<li><a href="#_blocks_scopes_visibility_locality_and_shadowing">Blocks, Scopes, Visibility, Locality and Shadowing</a></li>
<li><a href="#_global_code">Global code</a></li>
<li><a href="#_white_space_punctuation_and_operators">White space, punctuation and operators</a></li>
<li><a href="#_operators">Operators</a></li>
<li><a href="#_order_of_execution">Order of Execution</a></li>
</ul>
</li>
<li><a href="#_control_structures">Control Structures</a>
<ul class="sectlevel2">
<li><a href="#_if_statement_and_if_expression">If Statement and If Expression</a></li>
<li><a href="#_the_when_statement">The When Statement</a></li>
<li><a href="#_the_case_statement">The Case Statement</a></li>
<li><a href="#_the_while_loop">The While Loop</a></li>
<li><a href="#_the_block_statement">The Block Statement</a></li>
<li><a href="#_for_loops_and_iterators">For Loops and Iterators</a></li>
</ul>
</li>
<li><a href="#_objects">Objects</a></li>
<li><a href="#_arrays_and_sequences">Arrays and Sequences</a>
<ul class="sectlevel2">
<li><a href="#_some_details">Some details</a></li>
</ul>
</li>
<li><a href="#_slices">Slices</a></li>
<li><a href="#_value_objects_and_references">Value Objects and References</a></li>
<li><a href="#_references_and_pointers">References and Pointers</a>
<ul class="sectlevel2">
<li><a href="#_introduction_to_pointers">Introduction to Pointers</a></li>
<li><a href="#_pointer_arithmetic">Pointer Arithmetic</a></li>
<li><a href="#_allocating_objects">Allocating Objects</a></li>
<li><a href="#_references_to_objects">References to Objects</a></li>
</ul>
</li>
<li><a href="#_procedures_and_functions">Procedures and Functions</a>
<ul class="sectlevel2">
<li><a href="#_introduction">Introduction</a></li>
<li><a href="#_special_argument_types_openarray_and_varargs">Special Argument Types: OpenArray and Varargs</a></li>
<li><a href="#_procedures_bound_to_a_data_type">Procedures bound to a Data Type</a></li>
<li><a href="#_scoping_visibility_and_locality">Scoping , Visibility and Locality</a></li>
<li><a href="#_generics">Generics</a></li>
<li><a href="#_example_for_the_use_of_generics">Example for the use of Generics</a></li>
<li><a href="#_method_call_syntax">Method Call Syntax</a></li>
<li><a href="#_procedure_variables">Procedure Variables</a></li>
<li><a href="#_nested_procedures_and_closures">Nested Procedures and Closures</a></li>
<li><a href="#_anonymous_procedures">Anonymous Procedures</a></li>
<li><a href="#_compile_time_proc_execution">Compile time proc execution</a></li>
<li><a href="#_inlining_procedures">Inlining Procedures</a></li>
<li><a href="#_recursion">Recursion</a></li>
<li><a href="#_converters">Converters</a></li>
</ul>
</li>
<li><a href="#_object_orientated_programming_and_inheritance">Object-Orientated Programming and Inheritance</a></li>
<li><a href="#_other_builtin_data_types">Other Builtin Data Types</a>
<ul class="sectlevel2">
<li><a href="#_tuple_types">Tuple Types</a></li>
<li><a href="#_object_variants">Object Variants</a></li>
</ul>
</li>
<li><a href="#_iterators">Iterators</a></li>
<li><a href="#_templates">Templates</a>
<ul class="sectlevel2">
<li><a href="#_typed_vs_untyped_parameters">Typed vs untyped parameters</a></li>
<li><a href="#_passing_a_code_block_to_a_template">Passing a code block to a template</a></li>
<li><a href="#_passing_operators_to_templates">Passing operators to templates</a></li>
<li><a href="#_advanced_template_use">Advanced template use</a></li>
</ul>
</li>
<li><a href="#_casts_and_type_conversion">Casts and Type Conversion</a></li>
<li><a href="#_bitwise_operations">Bitwise Operations</a></li>
<li><a href="#_exceptions">Exceptions</a>
<ul class="sectlevel2">
<li><a href="#_defects_and_catchable_errors">Defects and catchable Errors</a></li>
<li><a href="#_raise_statement">Raise statement</a></li>
<li><a href="#_custom_exceptions">Custom exceptions</a></li>
<li><a href="#_try_statement">Try statement</a></li>
<li><a href="#_try_expressions">Try expressions</a></li>
<li><a href="#_except_clauses">Except clauses</a></li>
<li><a href="#_imported_exceptions">Imported exceptions</a></li>
<li><a href="#_defer_statement">Defer statement</a></li>
</ul>
</li>
<li><a href="#_effect_system">Effect system</a></li>
<li><a href="#_destructors">Destructors</a>
<ul class="sectlevel2">
<li><a href="#_destructors_and_inheritance">Destructors and Inheritance</a></li>
</ul>
</li>
<li><a href="#_finalizers">Finalizers</a></li>
<li><a href="#_modules">Modules</a>
<ul class="sectlevel2">
<li><a href="#_cyclic_imports">Cyclic Imports</a></li>
</ul>
</li>
<li><a href="#_include">Include</a></li>
</ul>
</li>
<li><a href="#_part_iii_nims_standard_library">Part III: Nim&#8217;s Standard Library</a>
<ul class="sectlevel1">
<li><a href="#_command_line_arguments">Command Line Arguments</a></li>
<li><a href="#_reading_data_from_the_terminal">Reading data from the terminal</a></li>
<li><a href="#_writing_text_to_the_terminal_window">Writing text to the terminal window</a></li>
<li><a href="#_option_types"><span class="new">Option types</span></a></li>
<li><a href="#_serializationstoring_data_permanently_on_external_storage">Serialization&#8201;&#8212;&#8201;storing data permanently on external storage</a></li>
<li><a href="#_streams_and_files">Streams and Files</a>
<ul class="sectlevel2">
<li><a href="#_files">Files</a></li>
<li><a href="#_streams">Streams</a></li>
</ul>
</li>
<li><a href="#_string_processing">String Processing</a>
<ul class="sectlevel2">
<li><a href="#_basic_string_operations">Basic string operations</a></li>
<li><a href="#_module_stringutils">Module stringutils</a></li>
<li><a href="#_module_parseutils">Module parseutils</a></li>
<li><a href="#_module_strscans">Module strscans</a></li>
<li><a href="#_module_strformat">Module strformat</a></li>
</ul>
</li>
<li><a href="#_arrays_and_sequences_2">Arrays and Sequences</a>
<ul class="sectlevel2">
<li><a href="#_module_sequtils">Module sequtils</a></li>
</ul>
</li>
<li><a href="#_random_numbers">Random Numbers</a></li>
<li><a href="#_timers">Timers</a></li>
<li><a href="#_hash_tables">Hash Tables</a>
<ul class="sectlevel2">
<li><a href="#_user_defined_hash_values">User defined hash values</a></li>
<li><a href="#_equality_and_identity">Equality and Identity</a></li>
<li><a href="#_performance">Performance</a></li>
<li><a href="#_tuples_or_other_containers_as_keys">Tuples or other containers as Keys</a></li>
<li><a href="#_counttable">CountTable</a></li>
</ul>
</li>
<li><a href="#_hash_sets">Hash Sets</a></li>
<li><a href="#_operating_system_services">Operating system services</a></li>
<li><a href="#_command_line_parsing"><span class="new">Command line parsing</span></a></li>
<li><a href="#_regular_expressions"><span class="new">Regular Expressions</span></a>
<ul class="sectlevel2">
<li><a href="#_greedy_matching">Greedy matching</a></li>
<li><a href="#_escape_sequences">Escape sequences</a></li>
<li><a href="#_final_remarks">Final remarks</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_part_iv_some_programming_tasks">Part IV: Some Programming Tasks</a>
<ul class="sectlevel1">
<li><a href="#_sorting">Sorting</a>
<ul class="sectlevel2">
<li><a href="#_selection_sort">Selection Sort</a></li>
<li><a href="#_insertion_sort">Insertion Sort</a></li>
<li><a href="#_quick_sort">Quick Sort</a></li>
<li><a href="#_merge_sort">Merge Sort</a></li>
</ul>
</li>
<li><a href="#_some_small_exercises"><span class="recent">Some small exercises</span></a>
<ul class="sectlevel2">
<li><a href="#_removing_adjacent_duplicates">Removing adjacent duplicates</a></li>
<li><a href="#_array_difference">Array difference</a></li>
<li><a href="#_binary_search">Binary search</a></li>
<li><a href="#_integer_to_string_conversion">Integer to string conversion</a></li>
<li><a href="#_no_game_programming">No Game Programming?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_part_v_external_packages"><span class="new">Part V: External Packages</span></a>
<ul class="sectlevel1">
<li><a href="#_parsing_expression_grammars">Parsing Expression Grammars</a>
<ul class="sectlevel2">
<li><a href="#_capturing_data">Capturing data</a></li>
</ul>
</li>
<li><a href="#_cligen_a_command_line_interface_generator"><span class="new">Cligen, a Command-Line Interface generator</span></a></li>
</ul>
</li>
<li><a href="#_part_vi_advanced_nim">Part VI: Advanced Nim</a>
<ul class="sectlevel1">
<li><a href="#_macros_and_meta_programming">Macros and Meta-Programming</a>
<ul class="sectlevel2">
<li><a href="#_introduction_2">Introduction</a></li>
<li><a href="#_types_of_macro_parameters">Types of macro parameters</a></li>
<li><a href="#_quote_and_the_quote_do_construct">Quote and the quote do: construct</a></li>
<li><a href="#_building_the_ast_manually">Building the AST manually</a></li>
<li><a href="#_the_assert_macro">The Assert Macro</a></li>
<li><a href="#_pragma_macros">Pragma Macros</a></li>
<li><a href="#_pragma_macro_for_iterator">Pragma Macro for Iterator</a></li>
<li><a href="#_macros_to_generate_new_operator_symbols">Macros to generate new operator symbols</a></li>
</ul>
</li>
<li><a href="#_process_execution">Process execution</a>
<ul class="sectlevel2">
<li><a href="#_module_threadpool">Module threadpool</a></li>
<li><a href="#_using_the_threads_module_to_create_new_threads">Using the threads module to create new threads</a></li>
<li><a href="#_using_channels_for_communication_between_threads">Using Channels for communication between Threads</a></li>
<li><a href="#_race_conditions">Race conditions</a></li>
<li><a href="#_guards_and_locks">Guards and Locks</a></li>
<li><a href="#_exceptions_in_threads">Exceptions in Threads</a></li>
</ul>
</li>
<li><a href="#_code_execution_with_asyncawait">Code execution with async/await</a>
<ul class="sectlevel2">
<li><a href="#_is_asyncawait_faster_than_multi_threading">Is async/await faster than multi-threading?</a></li>
<li><a href="#_nims_asynchronous_dispatcher">Nim&#8217;s asynchronous dispatcher</a></li>
<li><a href="#_asynchronous_procedures">Asynchronous procedures</a></li>
<li><a href="#_simple_example">Simple example</a></li>
<li><a href="#_file_download">File download</a></li>
<li><a href="#_a_chat_server_application">A chat server application</a></li>
<li><a href="#_the_client_application">The client application</a></li>
</ul>
</li>
<li><a href="#_concepts">Concepts</a></li>
</ul>
</li>
<li><a href="#_appendix">Appendix</a>
<ul class="sectlevel1">
<li><a href="#_acknowledgments">Acknowledgments</a></li>
<li><a href="#_nimblea_package_manager"><span class="new">Nimble&#8201;&#8212;&#8201;a package manager</span></a>
<ul class="sectlevel2">
<li><a href="#_purpose_of_package_managers">Purpose of package managers</a></li>
<li><a href="#_creating_and_publishing_nimble_packages">Creating and publishing Nimble packages</a></li>
<li><a href="#_public_packages">Public packages</a></li>
</ul>
</li>
<li><a href="#_ascii_table">ASCII Table</a></li>
<li><a href="#_div_and_mod_operation">Div and Mod operation</a></li>
<li><a href="#_text_styles">Text styles</a></li>
<li><a href="#_changelog">ChangeLog</a>
<ul class="sectlevel2">
<li><a href="#_november_2021">November 2021</a></li>
<li><a href="#_februar_2022">Februar 2022</a></li>
<li><a href="#_march_2022">March 2022</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>When you are not able to explain it with words, you may have to add pictures.
And when you even do not manage it with pictures, you can still make a video.</p>
</div>
</blockquote>
</div>
</div>
</div>
<div class="sect1 normal">
<h2 id="_about_this_book">About this book</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the year 1970 Prof. Niklaus Wirth invented the <span class="ndef">Pascal</span> programming language to teach
his students the fundamentals of computer programming. While the initial core Pascal
language was designed for teaching purposes only, it was soon expanded by commercial
vendors and got some popularity. Later, Wirth presented the language <span class="ndef">Modula-2</span>
with improved syntax and support for modules for larger projects, and the
<span class="ndef">Oberon</span> language family with additional support for <span class="ndef">Object-Oriented
Programming</span>.</p>
</div>
<div class="paragraph">
<p>The <span class="ndef">Nim</span> programming language can be seen in this tradition, as it is
basically an easy language suited for beginners with no prior programming experience,
but at the same time is not restricted in any way. Nim offers all the concepts of
modern and powerful programming languages in combination with high performance and
some sort of universality&#8201;&#8212;&#8201;Nim can be used to create programs for tiny microcontroller as well
as large desktop apps and web applications.</p>
</div>
<div class="paragraph">
<p>Most books about programming languages concentrate on the language itself and assume
that the reader is already familiar with the foundations of computer hardware and
already has some programming experience. This is generally a valid approach, as today
most people are taught this fundamental knowledge, sometimes called <span class="ndef">Computer
Science</span> (CS) in school. But still, there are people who missed this introduction in
school for various reasons and decide later that they need some programming skills,
maybe for a technical job. And there may exist some children that are not satisfied
with the introduction to computer science taught at school. So we have decided to
start this book with a short introduction to fundamental concepts&#8201;&#8212;&#8201;most people can
skip that part. In part II, we explain the basics of computer programming step by step
in a way which should enable even children to learn independently. In this part we may repeat
some of the stuff which we already mentioned in part I. We do that by intent, as some
people may skip part I, and because it is generally not a bad idea to support the learning
process of the reader with some repetitions.
Part III will give
you an overview of the Nim standard library, and part IV will introduce some useful
external packages. Part V will introduce advanced concepts like <span class="ndef">asynchronous
operations</span>, <span class="ndef">threading</span> and <span class="ndef">parallel processing</span>, and <span class="ndef">macros</span>
and <span class="ndef">meta-programming</span>. Nim&#8217;s macros are very powerful but difficult at first.
Part VI may finally present some advanced examples.</p>
</div>
<div class="paragraph">
<p>This book is basically a traditional text book, a very simple one with detailed
explanations, so that kids from 14 years upwards can read and understand it
on their own, with no, or only minimal help from adults. The English language
may still be a problem for many kids not born in a country with a good
English language tradition, unfortunately. But luckily automatic
translations are already supported for some languages, and perhaps we
will be able to offer some translated editions later, possibly a Chinese
and a German translation?</p>
</div>
<div class="paragraph">
<p>In the last decades in the area of computer programming,
traditional text books have partly been replaced by videos and "Crash course" and "Learning
by doing" books. Well, maybe a good video may indeed help you start with a new
language, and a video may enable people with problems reading printed texts or with
difficulties concentrating on a topic for a few minutes to learn a programming language.
Unfortunately, the quality of most videos is very bad, some are made by kids just having
learned the first steps of computer programming themselves. And of course
watching videos does not improve the reading and concentration issues that people have.
"Crash course" and "Learning by doing"
books may give you a good start, but for that we already have a lot of textual tutorials.
The concern with these kinds of books is, that they may help you with solving some common tasks, but they do not
really support a deeper understanding. The idea of a "Crash course" and "Learning by doing" may not be that bad in general, but in computer
science starting with a larger example application may be an overwhelming process, as you have to learn
a lot of stuff in parallel. It may work for you, but there is the danger that you forget all the details very quickly again.
And these kinds of books are not very helpful when you have to look up something.
The other concern with "Learning by doing" in computer science is, that learning materials
may have only examples which you may not really be interested in: Of course we can create
a simple chat application, a simple Twitter clone and do some basic web scraping using
async/await. Or create a basic game, or a simple GUI with one of the dozen available tool-kits.
But what when you are not interested in chatting and twittering, and that single selected toolkit?
We think that for such a case, reading the detailed examples can be very frustrating. So we
would recommend that after reading the first tutorial, and maybe a few pages of this book, you just start
coding with stuff you are interested in. Perhaps together with some friends? Whenever you should
need some concrete help, you should find it on the internet, using search engines, Wikipedia or
a discussion platform of your choice.
And if you have really no idea whatsoever for a project with which you can start,
then potentially computer programming is just not the right profession for you.</p>
</div>
<div class="paragraph">
<p>While Nim has a JavaScript backend and so supports web related development well, this
book concentrates on native code generation using the C and C++ backends. We will
discuss some peculiarities of the JavaScript backend in the second half of the book,
and we may give some complete examples for the use of the JavaScript backend in the
final part VI of the book. If you are strongly interested in web development and the
JavaScript backend, then you may also consult the book <span class="ndef">Nim in Action</span> of
Dominik Picheta, which gives some detailed examples for the development of web based
software with the Nim programming language, including a simple chat application and
the skeleton of a microblogging and social networking service. And you may consult
the tutorials and manuals of Nim web packages like <span class="ndef">Karax</span>,
<span class="ndef">Jester</span> or <span class="ndef">basolato</span>.</p>
</div>
<div class="paragraph">
<p>This book will not try to explain things that are already explained well elsewhere or
that should have been explained well elsewhere&#8201;&#8212;&#8201;at least not in this first edition, where
we still have so much other essential stuff. So what we will leaf out for now is the installation
of the compiler, installing and using text editors or IDEs with special Nim support, using
Nim package managers like nimble, nimph or others, using the foreign function interface (FFI)
to create bindings to C libraries, and internal compiler details like the various
memory management options, all the pragmas and similar. Also, we do not intend to
fill the book up with redundant stuff, like tables listing all the Nim keyword or Nim&#8217;s
primitive data types and such, as you can find all that in the compiler manual easily.</p>
</div>
<div class="paragraph">
<p>While creating graphical user interfaces (GUIs) is an important topic, we can not
give many details for that due to various reasons: Nim has not yet the one and only
accepted GUI library, but more than 20 attempts&#8201;&#8212;&#8201;from pure Nim ones like nimx or fidget, over
wrapped libs like GTK or QML, or GUIs that try to provide a native look for various operating systems like xwidgets or nigui,
to web based GUIs. And for each of these, at least for the more
serious ones, we could write a separate GUI book. So we will give only a few minimal examples
for some of them in part IV of the book.</p>
</div>
<div class="paragraph">
<p>Also, we will not explain game programming, as game programming is
a broad area, and there are already a lot of tutorials available. Maybe in later editions of the
book we will add some of these topics, e.g. game programming, as so many people like it.
But we will always have to ensure that a possible printed book version will not get
more than 500 pages, so we may then leave out some stuff in the printed version.</p>
</div>
<div class="paragraph">
<p>General when learning a new programming language, people start with some short
tutorials before really learning the language following a book. This way is indeed a good start.
So we recommend you to read the short official tutorials part 1 and 2 and perhaps also
some other tutorials freely available online. Tutorials generally only scratch the topics, so you may not be able to understand all
really well, but this way you get already a feeling for the language.
There exists also
some video tutorials, for the case that you have problems reading, but in that case
this book will not be of much use for you at all.
When you know already some computer science and have already experience
with other languages like C++, Haskell or Rust, then the tutorials and the Nim compiler manual
may be fully sufficient for you, and you may not need this book at all.</p>
</div>
<div class="paragraph">
<p>This book is based on the Nim reference implementation of the team around
Mr. A. Rumpf.
While the first pages of this book have been written already in spring 2020, it should be mostly up-to-date
with the current stable version Nim v1.6. We will try to keep the book up to date with further Nim
releases, as a 1.8 or maybe already a 2.0 release with planned support for incremental compilation.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The source code of the book is hosted at <a href="https://github.com/StefanSalewski/NimProgrammingBook" class="bare">https://github.com/StefanSalewski/NimProgrammingBook</a>.
You may use the GitHub issue tracker to point us to mistakes or unclear explanations, we will try to
fix that. Please note that we are more interested in remarks to the content of the book currently, not that much
in typos or grammar issues. Before the book will be officially published or a printed
version will be created, we will run it through some correction software or hire a professional
proofreader.</p>
</div>
<div class="paragraph">
<p><span class="new">New sections, and serious content changes are now (end of 2021) marked with a yellow background</span>, <span class="recent">and
not that new stuff is still marked with a light yellow.</span> For details, you may see the change log in the appendix.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">About the Author</div>
<div class="paragraph">
<p>Dr. S. Salewski studied Physics, Mathematics and Computer Science at Hamburg
University (Germany), where he got his PhD in 2005 in the area of laser physics. He has worked
in the field of fiber laser physics, electronics, and software development, using languages like
Pascal, Modula-2, Oberon, C, Ruby and Nim. Some of his software projects, including the
Nim GTK GUI bindings and Nim implementations of an N-dimensional RTree and a fully
dynamic, constrained delaunay triangulation, are freely available as open source
projects at <a href="https://github.com/StefanSalewski" class="bare">https://github.com/StefanSalewski</a>.</p>
</div>
</div>
</div>
</div>
</div>
<h1 id="_part_i_introduction" class="sect0">Part I: Introduction</h1>
<div class="openblock partintro normal">
<div class="content">
For using computers and writing computer programs, you initially do not have to know
many details. It is basically like driving a car: Although a car is a powerful and
complicated tool, kids generally can drive it after a 3-minute introduction. Still,
good racing drivers typically need a much broader insight into the inner working of
all the technical components, and finally, a lot of practice.
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_computer">What is a Computer?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A computer is primarily a device which can run computer programs, by following
instructions about how to manipulate data.</p>
</div>
<div class="paragraph">
<p>Nearly all the
computers currently in use, from the tiny ones integrated in electronic gadgets, the
well known desktop computers (PCs), to large and powerful super computers filling out
entire rooms, work internally with digital data only.<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> Digital data are basically integer (whole) numbers encoded in
binary form, which are represented by sequences of the symbols <span class="ndef">0</span> and <span class="ndef">1</span>. We
will discuss the term digital in the next section in more detail.</p>
</div>
<div class="paragraph">
<p>The most important part of a digital computer is the <span class="ndef">CPU</span>, the
<span class="ndef">Central Processing Unit</span>. That tiny device is built of digital electronic
circuits and can perform very basic mathematical and logical operations on numbers,
like adding two numbers or deciding if a number is larger or smaller than another
number. Most computer CPU&#8217;s can only store very few numbers internally, and forget
the numbers when the power is switched off. So the CPU is generally electrically
connected to a <span class="ndef">RAM</span> module, a <span class="ndef">Random Access Memory</span>, which can store
many more numbers and allow fast access to these numbers, and to a <span class="ndef">Hard disk</span>
or <span class="ndef">SSD</span> device which can permanently store the numbers, but does not allow
such fast access. The stored numbers are most often called just <span class="ndef">data</span>&#8201;&#8212;&#8201;basically that data is nothing more than numbers, but it can be interpreted in many
ways, such as pictures, sounds and much more.</p>
</div>
<div class="paragraph">
<p>The traditional hard disk drives (HDD), which store data electromechanical on rotating magnetic disks, as
well as the more modern variants, the solid-state-devices (SDD), which store data using modern semiconductor
technologies, can store data persistently for longer time periods, even when no electric power
supply is available. Both, SSDs and HDDs, can be optionally split into multiple partitions, e.g. one or multiple OS partitions
for executable programs or pure data partition for passive data like text files or pictures.
Before used, each partition is generally formatted and a file system (FS) is created. These two steps
create an internal structure on the storage device, which allows us to store and retrieve individual data
blocks like programs, text files or pictures.</p>
</div>
<div class="paragraph">
<p>Nearly all of today&#8217;s desktop computers, and even most notebooks and cellphones
contain not only a single CPU, but multiple CPUs, also called "Cores", so they can
run different programs in parallel, or a single program can run parts of it on
different CPUs, to increase performance or reduce total execution time. The so-called
super computers can contain thousands of CPUs. Beside CPUs, most computers have also
at least one <span class="ndef">GPU</span>, a <span class="ndef">Graphic Processing Unit</span>, that can be used to
display data on a screen or monitor, maybe for doing animations in games or for
playing video. The distinction between CPU and GPU is not really sharp; generally a
CPU can also display data on screens and monitors, and GPUs can do also some data
processing that CPUs can do. But GPUs are optimized for the data display task.</p>
</div>
<div class="paragraph">
<p>More visible to the ordinary computer user are the peripheral devices like keyboard,
mouse, screen and perhaps a printer. These enable human interaction with the computer,
but are in no way a core component of it; the computer can run well without them. In
notebook or laptop computers or in cellphones, the peripheral devices are closely
integrated with the core components. All the physical parts of a computer are also
called <span class="ndef">hardware</span>, while the programs running on that hardware are called
<span class="ndef">software</span>.</p>
</div>
<div class="paragraph">
<p>A less visible but also very important class of computers are <span class="ndef">microcontroller</span> and so
called <span class="ndef">embedded devices</span>, tiny pieces with typically a hull of black plastic
with some electrical contacts. The devices generally contain all necessary elements,
that is the CPU, some RAM and a persistent storage that can store programs when no
electric power supply is available. These devices may be restricted in computing
power and the amount of data that they can store and process, but they are contained
in many devices. They control your washing machine, refrigerator, television and
radio and much more. Some devices in your home may even contain multiple microcontrollers and
often the microcontrollers can already communicate with each other by RF (Radio-Frequency), or
access by WLAN the internet, which is sometimes called <span class="ndef">Internet of Things</span>
(IoT).</p>
</div>
<div class="paragraph">
<p>Another class of large and very powerful digital computers are called
<span class="ndef">mainframe computers</span> or <span class="ndef">super computers</span>, which are optimized to
process large amount of data very fast. The key to their gigantic computing power is
that many fast CPUs work in parallel&#8201;&#8212;&#8201;the problem or task is split into many small
parts that are solved by one CPU each, and the final result is then the combination
of all the solved sub-tasks. Unfortunately, it is not always possible to split large
problems into smaller sub-tasks.</p>
</div>
<div class="paragraph">
<p>Digital computers are generally driven by a clock signal that pulses at a certain
frequency. The CPU can do simple operations like the addition of two integers at
each pulse of the clock signal. For more complicated operations like a multiplication
or a division, it may need more clock pulses.</p>
</div>
<div class="paragraph">
<p>So a rough measure for the performance of a computer is the clock rate, that is the
number of clock pulses per second, divided by the number of pulses that the CPU needs
to perform a basic operation, multiplied by the number of CPUs or Cores that the
computer can use.</p>
</div>
<div class="paragraph">
<p>A totally different kind of computers are <span class="ndef">Quantum Computers</span>, large,
expensive high-tech devices, which use the rules of <span class="ndef">quantum mechanics</span> to
calculate many computations in parallel. Today only a few of them exist, for research
at universities and some large commercial institutes. Quantum computers may at some
time in the future fundamentally change computing and our whole world, but they are
not the topic of this book.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_analog_and_digital">Analog and Digital</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Whenever we measure a quantity based on one tiny base unit, then we work in the
digital area, we measure with some granularity. Our ordinary money is digital in some
way, as the cent is the smallest base unit; you will never pay a fraction of a cent
for something. Time can be seen as a digital quantity as long as we accept the
second as the smallest unit. Even on so-called analogue watches, the second hand will
generally jump forwards in steps of a second, so you can not measure fractions of a
second with that watch.</p>
</div>
<div class="paragraph">
<p>An obvious analogue property is the thermodynamic temperature and its classic
measurement device is the well known capillary thermometer consisting of a glass
capillary filled with alcohol or liquid mercury. When temperature increases, the
liquid in a reservoir expand more than the surrounding glass and partly fills the
capillary. That filling rate is an analogue measure for the temperature.</p>
</div>
<div class="paragraph">
<p>While the hourglass works digitally (you can count the tiny sand grains), the sundial
does not.</p>
</div>
<div class="paragraph">
<p>Most of the quantities in our real world seem analog, and digital quantities seem to
be some sort of arbitrary approximation.</p>
</div>
<div class="paragraph">
<p>But <span class="ndef">quantum mechanics</span> has taught us that many quantities in our world really
have a granularity. Physically, quantities like energy or momentum are indeed
multiplies of the tiny <span class="ndef">Planck constant</span>. Or consider electric charge, which
is always a multiple of the <span class="ndef">elementary charge unit</span> of one electron. Whenever
an electrical current is flowing through an electrically conducting wire, an ionized
gas or an electrolyte like salt water, there are flowing multiplies of the elementary
charge only, never fractions of it. And of course light and electromagnetic radiation
also has some form of granularity, which the photoelectric effect as well as Compton
scattering proves.</p>
</div>
<div class="paragraph">
<p>An important and useful property of digital signals, and digital data, is that they map
directly to integral numbers.</p>
</div>
<div class="paragraph">
<p>The simplest form of digital data is binary data, which can have only two distinct
values. When you use a mechanical switch to turn the light bulb in your house on, or
of, you change the binary state of the bulb. And your neighbor, when watching your
house, receives binary signals.<sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p>
</div>
<div class="paragraph">
<p>Digital computers are generally using binary electric states internally&#8201;&#8212;&#8201;voltage or
current <span class="term">on</span> or <span class="term">off</span>. Such an on/off state is called a bit. We will
learn more about bits and binary logic later. One bit can store obviously only two
states, which we may map to the numbers <span class="term">0</span> and <span class="term">1</span>. Larger integer
numbers can be represented by a sequence of multiple bits.</p>
</div>
<div class="paragraph">
<p>The <span class="ndef">Morse code</span> was an early application to transmit messages encoded in
binary form.</p>
</div>
<div class="paragraph">
<p>A very important property of digital encoded numbers (data) is that they can be
copied and transmitted exactly without loss of precision. The reason for this is that digital numbers have a
well-defined clean state, there is no noise which overlays the data and may
accumulate when the data is copied multiple times. Well, that statement is not really
true&#8201;&#8212;&#8201;under bad conditions, the noise can become so large that it changes the binary
state of signals. Imagine we try to transfer some whole numbers encoded in binary
form, maybe by binary states encoded as voltage level <span class="term">0 Volt</span> and <span class="term">5
Volts</span>, over an electric wire and a long distance. It is clear that the long wire can
pick up some electromagnetic noise that can change the true <span class="lit">0</span> Volt data to a voltage
that is closer to <span class="lit">5</span> Volts than to the true <span class="lit">0</span> Volt level, so it is received
incorrectly. To catch such types of transmission errors, <span class="ndef">checksums</span> are added
to the actual data. A checksum is derived by a special mathematical formula from the
original data and transferred with it. The receiver applies the same formula to the
received data and compares the result with the received checksum. If it does not
match, then it is clear that the data transmission is corrupted, and a resend is
requested.</p>
</div>
<div class="paragraph">
<p>The opposite of digital is generally called analogue, a term which is used for data
which have or seems to have no granularity. For example, we speak of an analogue
voltage when the voltage can have each value in a given range and when the voltage
does not "jump" but change continuous.<sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>
For observing analogue voltages or currents, one can use a moving coil meter, a device
where the current flows through a coil in a magnetic field and the magnetic force
moves the hand/pointer.</p>
</div>
<div class="paragraph">
<p>We said in the previous section that nearly all of our current computers work with
digital data only. Basically that is that they work internally with integer numbers,
stored in sequences of binary bits. All input for computers must have the form of
integer numbers, and all output has the form of integer numbers. Whenever we want to
feed computers with some sort of analogue data, like an analogue voltage, we have to
convert it into a digital approximation. For that task, special devices called
<span class="ndef">analog to digital converters</span> (ADC) exists. And in some cases we have to
convert the digital output data of computers to analogue signals, like when a
computer plays music: The computer output in form of digital data is then converted
by a device called <span class="ndef">digital to analog converter</span> (DAC) into an analogue
voltage, that generates an analogue current through a coil in the speakers of our
sound box, and that electric current in the coil generates a magnetic field which
exercise mechanical forces and moves the membrane of the speaker, resulting in
oscillating motions, which generates air pressure variations that our ear can detect
and that we finally hear as sound.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_an_operating_system">What is an Operating System?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most computers, from cellphones to large super computers, use an <span class="ndef">operating system</span> (OS).
A well known OS is the GNU/Linux kernel. Operating Systems can be seen as the initial
program that is loaded and started when we switch the computer on and that works as
some kind of supervisor:<sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup> it can load other
programs, and it distributes resources like CPU cores or RAM between multiple running
programs. It also controls user input by keyboard and mouse, displays output data on
the screen&#8201;&#8212;&#8201;as text or graphics, controls how data is loaded and stored to
nonvolatile storage media like hard-disk or SSD, manages all the network traffic and
many more tasks. An important task of the OS is to allow user programs to access all
the various hardware components from different vendors in a uniform, high level
manner. An OS can be seen as an intermediate layer between user programs, like a text
processor or a game, and the hardware of the computer. The OS allows user programs to
work on a higher level of abstraction, so they do not need to know much about the low
level hardware details.</p>
</div>
<div class="paragraph">
<p>Computer operating systems have generally a close relation to software libraries, which
are collections of data types and functions working with that data types. Libraries can
be a part of the OS, or can be more or less independent of the OS. Libraries are software
components that provide data types and functions with a well-defined interface
 (API, Application Programming Interface) and behavior.</p>
</div>
<div class="paragraph">
<p>Libraries can be used as shared libraries, which are single binary files stored on the file system of a computer,
often with the file extension <span class="term">.so</span> or <span class="term">.dll</span>, which can be accessed from different computer programs simultaneously,
or as static libraries which are part of single programs. Shared libraries have some advantages: we need only one
instance on the file system of the computer, and the library is loaded only once into the computer memory (RAM), even when
it is used by different apps simultaneously. This saves space, and when the library has serious errors, it is in principle possible to
replace the library with a corrected version, which is then used by all the software on the computer. Shared libraries often come in
numbered versions, where a higher number denotes a newer, improved or extended library version. Sometimes some of the
programs we use may need still an older library version, while other software needs already a never one. In that case,
our file system has to provide multiple versions of a shared library, which can be used independently.
On the other hand, statically linked libraries are directly glued with a single computer program.
That makes the distribution of the program easier, as it can be shipped as a single entity,
and we do not have to ensure that all the needed dynamic libraries are available on the destination computer.
But if a statically linked library has serious errors, then we have to replace all the programs that are linked
statically with that corrupted library.</p>
</div>
<div class="paragraph">
<p>Small microcontrollers and embedded devices often do not need to use an operating system, as they generally
run only one single user program and because they usually do not have a large variety
of hardware components to support.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_computer_programming">What is Computer Programming?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Computer programming includes the creation, testing and optimizing of computer
programs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_computer_program">What is a Computer Program?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A computer program is basically a sequence of numbers, which make some sense to a
computer CPU, in such a way that the CPU recognizes the numbers as so-called
<span class="ndef">instructions</span> or <span class="ndef">numeric machine code</span>, maybe the instruction to add
two numbers.</p>
</div>
<div class="paragraph">
<p>The first computers, built in the 1950s, were indeed programmed by feeding sequences
of plain numbers to the device. The numbers were stored on so-called <span class="ndef">punch
cards</span>, consisting of strong paper, where the numbers were encoded by holes in the
cards. The holes could be recognized by electrical contacts to feed the numbers into
the CPU. As plain numbers do not match well to human thinking, soon more abstract codes
were used. A very direct code, which matches numerical instructions to symbols, is
the <span class="ndef">assembly language</span>. In that language, for example the character sequence
"add A0, $8" may map directly to a sequence of numbers which instructs the CPU to add
the constant integer number 8 to CPU register A0, where A0 is a storage area in the
CPU where numbers can be stored. As there exist many different types of CPUs, all
with their own instruction sets, there exists many different assembly instruction
sets, with similar, but not identical instructions. The rules that describe how these
basic instructions have to look are called the <span class="ndef">syntax</span> of the assembly
language.</p>
</div>
<div class="paragraph">
<p>The numerical machine code, or the corresponding assembly language, is the most basic
instruction set for a CPU. Every instruction which a CPU can execute maps to a
well-defined assembly instruction. So, each operation that a computer may be able to
perform can be expressed in a sequence of assembly instructions. But complicated
tasks may require millions of assembly instructions, which would take humans very
long to write, and even much longer to modify, proof and debug.<sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup></p>
</div>
<div class="paragraph">
<p>Just a few years after the invention of the first computers, people recognized that
they would need even more abstract instruction sets, like repeated execution,
composed conditionals, or other data types than plain numbers as operands. So higher
level programming languages like Algol, Fortran, C, Pascal or Basic were created.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_an_algorithm">What is an Algorithm?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An <span class="ndef">algorithm</span> is a detailed sequence of more or less abstract instructions to
solve a specific task, or to reach a goal. Cooking recipe books and car repair
instructions are examples of algorithms.</p>
</div>
<div class="paragraph">
<p>The basic math operations kids learn in
school&#8201;&#8212;&#8201;to add, multiply or divide two numbers with paper and pencil&#8201;&#8212;&#8201;are algorithms
too. Even starting a car follows an algorithm&#8201;&#8212;&#8201;when the temperature is below zero,
and snow covers the vehicle, then you first have to clean the windows and lights. And
when you first drive again after a longer break, you would have to check the tires
before you start the engine. The algorithm can be carried out by strictly following the
instructions&#8201;&#8212;&#8201;it is not necessary to really understand how and why it works.</p>
</div>
<div class="paragraph">
<p>So an algorithm is a perfect fit for a computer, as computers are excellent at
following instructions without really understanding what they are trying to
accomplish.</p>
</div>
<div class="paragraph">
<p>A math algorithm to sum up the first 100 natural numbers may look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>use two integer variables called i and sum
assign the value 0 to both variables

while i is less than 100 do:
  increase i by one
  add value of i to sum

optionally print the final value of sum</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_what_is_a_programming_language">What is a Programming Language?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most traditional programming languages were created to map algorithms to elementary
CPU instructions. Algorithms typically contain nested conditionals, repetition, math
operations, recovery from errors and maybe plausibility checks. A more complicated algorithm
generally can be split into various separate logical parts, which may include reading in data at one point,
multiple processing steps at another, and storing, or displaying data as plain text, graphic or
animation at yet another point. This splitting into parts is mapped to programming languages by grouping
tasks into subroutines, functions or procedures which accept a set of input
parameters and can return a result.</p>
</div>
<div class="paragraph">
<p>As algorithms often work not only with numbers,
but also with text, it makes sense to have a form of textual data type in a
programming language too. And all the data types can be grouped in various ways, for
example, as sequences of multiple data of the same type, like lists of numbers or
names. Or as collections of different types, like name, age and profession of a
citizen in an income tax database. For all these use cases, programming languages
provide some sort of support.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_compilers_and_interpreters">Compilers and Interpreters</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We already learned that the CPU in the computer can execute only simple instructions,
which we call numeric machine code or assembly instructions.</p>
</div>
<div class="paragraph">
<p>To run a program written in a high level language with many abstractions, we need some
sort of converter to transform that program into the basic instructions that the CPU can
execute. For the conversion process we have basically two options: We can convert the
entire program into machine code, store it to disk, and then run it on the CPU. Or we
can convert it in small portions, maybe line by line, and run each portion whenever
we have converted it. Tools that convert the whole program first are called
compilers. <span class="ndef">Compilers</span> process the program that we have written, include other
source code like needed library modules, check the code for obvious errors and then
generate and store the machine code that we then can run.</p>
</div>
<div class="paragraph">
<p>Tools that process the
source code in small portions, like single statements, are called
<span class="ndef">interpreters</span>. They read in a line of source code, investigate it to check if
it is a valid statement, and then feed the CPU with corresponding instructions to
execute it. It is similar to picking strawberries: you can pick one and eat it at
once, or you can put them all into a basket and eat them later. Both interpreters and
compilers have advantages and disadvantages for special use cases. Compilers can
already detect errors before the program is run, and compiled programs generally run
fast, as all the instructions are already available when the programs run. The
compiling step takes some time of course, at least a few seconds, but for some
languages and large programs it may take much longer. That can make the software
development process slow because as you add or change code, you have to compile it
before you can execute and test your program. That may be inconvenient for unskilled
programmers, as they may have to do much testing. Some use a programming style that
is: change a tiny bit of the source code, then run it and see what is does. But a
more common practice is that you think about the problem first and then write the
code, that then in most cases does nearly that of what you intended. For this style of
programming, you do not have to compile and execute your code that often. Compilers
have one important benefit: they can detect many bugs, mostly typing errors, already
in the compile phase, and they give you a detailed error message. Interpreters have
the advantage that you can modify your code and immediately execute it without delay.
That is nice for learning a new language and for some fast tests, but even simple
typing errors can only be detected when they are encountered while running the
program. If your test does not try to run a faulty statement, there will be no error,
but it may occur later. Generally, interpreted program execution is much slower than
running compiled executables, as the interpreter has to continually process the
source code in real-time as it&#8217;s being run, while the compiler does it only once before the program is run. At the
end of this section, a few additional notes:</p>
</div>
<div class="paragraph">
<p>Compilers are sometimes supported by
so-called linkers. In that case the compiler converts the source code, that can be
stored in multiple text files, each in a sequence of machine code instructions, and
finally the linker joins all these machine code files to the final executable. Some
compilers do not need the linking step or call the linker automatically. And some
interpreters convert the textual source code in one very fast, initial pre-processing
step ("on the fly") to so-called byte code, that can then be interpreted faster. The
languages Ruby and Python do that. Some languages, like Java, can compile and optimize
the source code while the program is running. For that process, a so-called virtual
machine is used, which builds an intermediate layer between the hardware and the user
program.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_types_of_programming_languages">Types of Programming Languages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are many different styles that software can be written in. A programming paradigm
is a fundamental style of writing software, and each programming language supports
a different set of paradigms. You’re probably already familiar with one, or more
of them, and at the very least you know what object-oriented programming (OOP) is,
because it’s taught as part of many computer science courses.</p>
</div>
<div class="paragraph">
<p>We already mentioned the assembly languages, which provide only the basic operations
that the CPU can perform. Assembly languages provide no abstractions, so maybe we
should not even call them programming languages at all. Then there are low level
languages like Fortran or C, with some basic abstractions which still work close to
the hardware and which are mostly designed for high performance and low resource
consumption (RAM) but not to detect and prevent programming errors or to make life
easy for programmers. These languages already support some higher order data types,
like floating point numbers or text (strings), and homogeneous, fixed size containers
(called arrays in C) or heterogeneous fixed size containers (called structs in C).</p>
</div>
<div class="paragraph">
<p>A different approach is taken by languages like Python or Ruby, which try to make
writing code easier by offering many high level abstractions and which have better
protection against errors, but are not as efficient. These languages support also
dynamic containers which can grow and shrink, or advanced data structures like hash
tables (maps) or support for textual pattern matching by regular expressions (regex).</p>
</div>
<div class="paragraph">
<p>Another way to differentiate programming languages is if they are statically, or
dynamically typed. Ruby, Python and JavaScript are all examples of dynamically typed languages,
that is, they use variables which can store any data type, so the variable&#8217;s type
of data that it accepts can therefore dynamically change during program execution. That seems comfortable for the user, and
sometimes it is, especially for short programs which may be written for one-time use
only and are sometimes called scripts. But dynamic typing makes discovery of logical
errors harder&#8201;&#8212;&#8201;an illegal addition of a number to a letter may be detected only at
run-time. And dynamically typed languages generally waste a lot of memory and their
performance is not that great.
It is as we would own a set of large, equally sized moving boxes, and we
would store all of our goods in it, each piece in one box.</p>
</div>
<div class="paragraph">
<p>For statically typed languages, each variable has a well-defined data type like
integer number, real number, a single letter, a text element and many more. The data
type is either assigned by the author of the program with a type declaration, or is detected
by the compiler itself when processing the program source code, called type inference, and
the variable&#8217;s type does never change. In this way, the compiler can check for logical
errors early in the compile process, and the compiler can reserve memory blocks
exactly customized to the variables that we want to store, so total memory
consumption and performance can be optimized. Referring again to our boxes example,
statically typing is like using customized boxes for all your goods.</p>
</div>
<div class="paragraph">
<p>All these types of programming languages are often called imperative programming
languages, as the program describes detailed what to do. There are other types of
programming languages too, for example languages like Prolog, which try to give only
a set of rules and then let the computer try to solve a problem with these rules. And
of course there are the new concepts of <span class="ndef">artificial intelligence</span> (AI) and
<span class="ndef">machine learning</span> (ML), which are less based on algorithms and more on neural
nets which are trained with a lot of data until it can provide the desired results. Nim,
the computer language this book is about, is an imperative language, so we will focus
on the imperative programming style in this book. But of course, Nim can be used to
create AI applications.</p>
</div>
<div class="paragraph">
<p>Further still, we can differentiate between languages like C, C++, Rust, Nim and many more
that compile to native executables and can run directly on the hardware of the
computer, contrasted with languages like Java, Scala, Julia and some more, that use a large
<span class="ndef">Virtual Machine</span> (VM) as an intermediate layer between the program and the
hardware, and interpreted languages like Ruby and Python. Languages using a virtual
machine generally need some startup time when a program is invoked, as the VM must be
loaded and initialized, and interpreted languages are generally not very
fast.<sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup> The distinction between languages that compile
to native executables, and those that are executed on a virtual machine, is not really sharp.
For example, Kotlin and Julia were executed on a virtual machine initially, but now
can compile the source code to native executables.</p>
</div>
<div class="paragraph">
<p>An important class of programming languages are the so called <span class="ndef">Object-Oriented-Programming</span> (OOP)
languages, which uses inheritance and dynamic dispatch, and become popular in the
1990s. For some time, it was assumed that Object-Oriented-Programming was the ultimate solution to manage
and structure really large programs. Java was the most prominent example of the OOP
languages. Java forces the programmer to use OOP design, and languages like C++,
Python or Ruby strongly push the programmer to use the OPP design. Practice has shown that
OOP design is not the ultimate solution for all computing problems, and OPP design
may prevent optimal performance. So newer languages, like Go, Rust and Nim, support
some form of OOP programming, but use it only as one paradigm among many others.</p>
</div>
<div class="paragraph">
<p>Another popular and important class of programming languages is JavaScript and its
more modern cousins like TypeScript, Kotlin or Dart and others. JavaScript was
designed to run in web browsers to support interactive web pages and programs and
games running in the browser. In this way, the program became nearly independent of
the native operating system of the computer. Note that unlike the name may indicate,
JavaScript is not closely related to the Java language. Nim can compile to a
JavaScript backend, so it supports web development well.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Language</th>
<th class="tableblock halign-left valign-top">Type System</th>
<th class="tableblock halign-left valign-top">Runtime</th>
<th class="tableblock halign-left valign-top">Memory Management</th>
<th class="tableblock halign-left valign-top">Generics</th>
<th class="tableblock halign-left valign-top">Macros</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nim</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">static, strong</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">native binaries</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GC, Destructors, manual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AST based, hygenic</p></td>
</tr>
</tbody>
</table>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Sometimes source code written in one programming language is converted into another
one. A prominent target for such conversions is JavaScript, as JavaScript enables
execution of programs in web browsers. Another important target language is C or
C++. Creating intermediate C code, which is then compiled by a C compiler to native
executables has some advantages compared to direct compilation to native executables:
C compilers exists for nearly all computer systems including microcontrollers and embedded
systems, so the use of a language is not restricted to systems for which a native
compiler backend is provided. And C as intermediate code simplifies the use of
system libraries, which typically provide a C compatible interface. Due to decades of
development, C compilers generally can do better code optimizations than young
languages may manage to do. Some people fear that intermediate C code carries the
problems of the C language, like verbosity, confusing and error-prone code or
undefined behavior to the source languages. But these well known concerns of C occur
only when humans write C code directly, in the same way when humans write assembly
code directly. Automatic conversions are well-defined and well tested, which means
they are free of errors to the same degree as direct machine code generation would
be. But indeed there are some small drawbacks when C or C++ is used as a backend of a
programming language: C does not always allow direct access to all CPU instructions,
which may make it difficult to generate optimal code for some special constructs like
exceptions. And C uses wrap around arithmetic for unsigned integer types, which may
not be what modern languages desire. The current Nim implementation provides a
JavaScript and a C and C++ backend. While the JavaScript backend is a design
decision to enable web development, the C and C++ backends are a more pragmatic
decision, and may be later replaced or at least supported by direct native code
generation or use of the popular LLVM backend. <sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup> When computer languages
are converted from one language to another, then sometimes the term
<span class="ndef">transpiler</span> is used to differentiate the translation process to a direct
compilation to a binary executable. When program code is converted between very
similar languages with nearly the same level of abstractions, then the term
transpiler may be justified. But Nim is very different from C and has a higher
abstraction level, and the Nim compiler performs many advanced optimizations. So it
should be not called a transpiler, even when compiling to JavaScript or to the C++
backend.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_nim">Why Nim?</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In this section we are using a lot of new Computer Science (CS) expressions but
do not explain them. That is intentional&#8201;&#8212;&#8201;when you already know them you may get a
better feeling of what Nim is, and when you do not know them, you will at least learn
that we can describe Nim with fancy-sounding terms.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Three well known traditional programming languages are C, Java and Python. C is
basically a simple, close-to-the-hardware language created in 1972, for which
compilers can generate fast, highly optimized native machine code, but it has cryptic
syntax, some strange semantics, and is missing higher concepts of modern languages.
Java, created in 1995, forces you strongly to the object-orientated style of
programming (OOP) and runs on a virtual machine, which makes it unsuitable for
embedded systems and microcontrollers. Python, created in 1991, is generally interpreted instead
of compiled, which makes program execution not very fast, and it does not really
allow writing low level code which operates close to the hardware. As many libraries
of the Python language are written in highly optimized C, Python can appear really fast
if a standard task, like sorting of data, processing of CSV or JSON files or website crawling
is performed. So Python is not a bad solution when we use it mostly for calling library
functions, but it reveals its low performance when we have to write some actual Python
code in order to solve a problem.
Of course, there
are many more programming languages, each with its own advantages and disadvantages&#8201;&#8212;&#8201;with some optimized for special use cases.</p>
</div>
<div class="paragraph">
<p>Nim is a state-of-the-art programming language well suited for systems and
application programming. Its clean Python-like syntax makes programming easy and fun
for beginners, without applying any restrictions to experienced systems programmers.
Nim combines successful concepts from mature languages like Python, Ada and Modula
with a few established features of the latest research. It offers high performance
with type and memory safety while keeping the source code short and readable. The
compiler itself and the generated executables support all major platforms including
Windows, Linux, BSD and Mac OS X. Cross-compiling to Android and other mobile and embedded devices and microcontrollers is possible, and
the JavaScript backend allows to create web apps and to run programs in web browsers.
The custom package managers, Nimble or Nimph, makes
use and redistribution of programs and libraries easy and secure. Nim supports
various "backends" to generate the final code. The C, C++ and LLVM-based backends
allow easy OS library calls without additional glue code, while the JavaScript
backend generates high quality code for web applications. The integrated
"Read/Eval/Print Loop" (REPL), "Hot code reloading", incremental compilation (expected for version 1.8), and
support of various development environments including debugging and language server
protocols makes working with Nim productive and enjoyable.</p>
</div>
<div class="sect2">
<h3 id="_some_facts_about_nim">Some Facts About Nim</h3>
<div class="ulist">
<ul>
<li>
<p>Nim is a multi-paradigm programming language. Unlike some popular programming
languages, Nim doesn’t focus on the OOP paradigm. It’s mainly an imperative and procedural
programming language, with varying support for OOP, data-orientated, functional, declarative, concurrent,
and other programming styles. Nim supports common OOP features, including inheritance,
polymorphism, and dynamic dispatch.</p>
</li>
<li>
<p>The generated executables are dependence free and small: a simple
chess program with a plain GTK-based graphical user interface is only 100 kB in size,
and the size of the Nim compiler executable itself is about 6.5 MB. It is possible to
shrink the executable size of "Hello World" programs to about 10 kB for use on tiny
microcontrollers.</p>
</li>
<li>
<p>Nim is fast. Generally, performance is very close to other
high-performance languages such as C or C++. There are some exceptions still: other
languages may have libraries or applications that have been tuned for performance for
many years, while similar Nim applications are so far less tuned for performance, or
maybe are more written with a priority of short and clean code or run-time safety.</p>
</li>
<li>
<p>Clean Python-like syntax with significant white-space, no need for block delimiters like
<span class="term">{}</span> or <span class="term">begin/end</span> keywords, and no need for statement delimiters like
<span class="term">;</span></p>
</li>
<li>
<p>Safety: Nim programs are type- and memory-safe&#8201;&#8212;&#8201;memory corruption is prevented by
the compiler as long as unsafe low level constructs like casts, pointers and the addr operator
or the {.union.} pragma are not used.</p>
</li>
<li>
<p>Fast compiler. The Nim compiler can compile itself and other medium-size packages
in less than 10 seconds, and upcoming incremental compilation will increase that
speed further.</p>
</li>
<li>
<p>Nim is statically typed: each object and each variable has a well-defined type,
which catches most programming errors already at compile time, prevents run-time
errors, and ensures the highest performance. At the same time, the statically typing
makes it easier to understand and to maintain larger code bases.</p>
</li>
<li>
<p>Nim supports various memory management strategies, including manually
allocations for critical low-level tasks as well as various garbage collectors
including a destructor based, fully deterministic memory manager.</p>
</li>
<li>
<p>Nim produces native, highly optimized executables and can also generate
JavaScript output for web applications.</p>
</li>
<li>
<p>Nim has a clean module concept which helps to structure large projects.</p>
</li>
<li>
<p>Nim has a well-designed library which supports many basic programming tasks.
The full source code of the library is included and can be viewed easily from within
the HTML-based API documentation.</p>
</li>
<li>
<p>Library modules like the OS module provides OS independent abstractions, which allows
to compile and run the same program on different operating system without modifications.</p>
</li>
<li>
<p>The Nim standard library is supported by more than 1000 external packages for a broad range
of use cases.</p>
</li>
<li>
<p>Asynchronous operation, threading and parallel processing is supported.</p>
</li>
<li>
<p>Nim supports all popular operating systems like Linux, Windows, macOS and Android.</p>
</li>
<li>
<p>Usage of external libraries written in C is easy and occurs directly
without any glue code, and Nim can even work together with code written in other
languages, for example there are some Nim &lt;-&gt; Python interfaces available.</p>
</li>
<li>
<p>Many popular editors have support for Nim syntax highlighting and other
IDE functionality like on-the-fly checking for errors and displaying detailed
information about imported functions and data types.</p>
</li>
<li>
<p>In the last few years Nim has reached some important milestones: Version 1.0
with some stability promises was released, and with the ARC and ORC
memory management strategies and full destructor support fully deterministic
memory management comparable to memory management in C++ or Rust
is available. So problems of conventional garbage collectors like delayed memory
deallocation or longer pausing of programs due to the GC process are gone. And some
larger companies have started using Nim in production, the most influential
may be currently the Status Corp. with their Ethereum client development.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_nim_supports_many_programming_styles">Nim supports many programming styles</h3>
<div class="paragraph">
<p>We mentioned already that
Nim is a multi-paradigm programming language, that supports
various programming styles. While we may regard Nim in
first line as an imperative, procedural programming language, it supports the popular functional
and object-orientated programming styles well.</p>
</div>
<div class="paragraph">
<p>In classical OOP programming languages, we have the concept of <span class="ndef">classes</span> with <span class="ndef">attributes</span>, and methods that are very closely bound to
the classes, as in Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-python" data-lang="python">class User:
  def say(self):
    print("It does not work!")

user = User()
user.say()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this Python snippet, we declare a class User, with a custom method named <span class="func">say()</span> bound
to this class. Then we create an instance variable of this class and call
its say() method.</p>
</div>
<div class="paragraph">
<p>This tight bounding of methods to classes is not very flexible, e.g. extending the set
of methods of a class may be difficult or impossible. Another problem with such a class concept
is, that it is not always clear to which class a method belongs when more than just one single
class is involved: Imagine that we need a method that appends a single character to a text string.
Is that method a member of the character class, or a member of the text string class?</p>
</div>
<div class="paragraph">
<p>Nim avoids such a strict class concept, while its generalized <span class="ndef">method call syntax</span> allows us
to use a class like syntax for all of our data types: e.g. to get the length of a string variable, we can
write len(myString) in classic procedural notation, or we can use the method syntax myString.len()
or just myString.len. The compiler regards all these notations as equivalent, so we have
the method syntax available without the restrictions of the class concept. The method call syntax
can be used in Nim for all data types, even for plain numbers&#8201;&#8212;&#8201;so the notation abs(myNum)
is fully equivalent with myNum.abs.</p>
</div>
<div class="paragraph">
<p>The Python code from
above may look in Nim like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type User = object

proc say(self: User) =
  echo ("It does not work!")

let user = User()
user.say()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the classes, we use object types in Nim, and we define procedures and methods
that can work on objects or other data types.</p>
</div>
<div class="paragraph">
<p>As an example for the functional programming style in Nim, we may
look at some code fragment from a real world app that has to generate
a string from four numbers, separated by commas. Using the mapIt()
procedure imported from the <span class="mod">sequtils</span> module and
the fmt() macro from the <span class="mod">strformat</span> module, we may write
that in functional programming style in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from strutils import join
from sequtils import mapIt
from strformat import fmt
const DefaultWorldRange = [0.0, 0, 800, 600]
let str = DefaultWorldRange.mapIt(fmt("{it:g}")).join(", ")
echo str # "0, 0, 800, 600"</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the imperative, procedural style, we would write it like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var str: string
for i, x in pairs(DefaultWorldRange):
  str.add(fmt("{x:g}"))
  if i &lt; DefaultWorldRange.high:
    str.add(", ")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_nim_is_efficient">Nim is Efficient</h3>
<div class="paragraph">
<p>Nim is a compiled and statically-typed language. While for interpreted,
dynamically-typed languages like Python we have to run every statement to check even
for trivial errors, the Nim compiler checks for most errors during the compile
process. The static typing together with the well-designed Nim type system allows the
compiler to catch most errors already in the compile phase, like the undefined
addition of a number and a letter, and to report the errors in the terminal window or
directly in the editor or IDE. When no errors are found or all errors have been
fixed, then the compiler generates highly optimized dependency free executables. And
this compilation process is generally really fast, for example the compiler compiles
itself in maybe 10 to 30 seconds on a typical modern PC.<sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup></p>
</div>
<div class="paragraph">
<p>Modern concepts like zero-overhead iterators, compile-time evaluation of user-defined
functions and cross-module inlining in combination with the preference of
value-based, stack-located data types leads to extremely efficient code.
Multi-threading, asynchronous input/output operations (async IO), parallel processing
and SIMD instructions including GPU execution are supported. Various memory
management strategies exists: selectable and tuneable high performance
<span class="ndef">Garbage Collectors</span> (GC), including a new fully deterministic destructor
based GC, are supported for automatic memory management. These can be disabled for
manual memory management. This makes Nim a good choice for application development
and close-to-the-hardware system programming at the same time. The unrestricted
hardware access, small executables and optional GC will make Nim a perfect solution
for embedded systems, hardware driver and operating system development.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nim_is_expressive_and_elegant">Nim is Expressive and Elegant</h3>
<div class="paragraph">
<p>Nim offers a modern type system with templates, generics and type inference. Built-in
advanced data types like dynamic containers, sets, and strings with full UTF support
are completed by a large collection of library types like hash tables and regular
expressions. While the traditional Object-Oriented-Programming programming style with inheritance and
dynamic dispatch is supported, Nim does not enforce this programming paradigm and
offers modern concepts, like procedural and functional programming.
The optional method call syntax allows to use all data types and functions in
an OOP like fashion, e.g. instead of len(myStr) we can also use the OOP style myStr.len.<sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>
The powerful
AST-based hygienic macro system offers nearly unlimited possibilities for the
advanced programmer. This macro and meta-programming system allows compiler-guided
code generation at compile time, so the Nim core language can be kept small and
compact, while many advanced features are enabled by user defined macros. For example,
the support of asynchronous IO operations has been created with these forms of
meta-programming, as well as many Domain Specific Language (DSL) extensions.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nim_is_open_and_free">Nim is Open and Free</h3>
<div class="paragraph">
<p>The Nim compiler and all modules of the standard library are implemented in Nim. All source
code is available under the less restricted MIT license.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nim_has_a_friendly_and_helpful_growing_community">Nim has a friendly and helpful growing community</h3>
<div class="paragraph">
<p>The Nim forum is hosted at:</p>
</div>
<div class="paragraph">
<p><a href="https://forum.nim-lang.org/" class="bare">https://forum.nim-lang.org/</a></p>
</div>
<div class="paragraph">
<p>and the software running the forum is coded in Nim.</p>
</div>
<div class="paragraph">
<p>Real-time chat is supported by IRC, Gitter, Discord, Telegram and others.</p>
</div>
<div class="paragraph">
<p>Nim is also supported by Reddit.com and Stackoverflow.com:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.reddit.com/r/nim/" class="bare">https://www.reddit.com/r/nim/</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/tagged/nim-lang" class="bare">https://stackoverflow.com/questions/tagged/nim-lang</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_nim_has_a_encouraging_future">Nim has a encouraging future</h3>
<div class="paragraph">
<p>Started more than 12 years ago as a small community project of some bright CS
students led by <span class="ndef">Mr. A. Rumpf</span>, it is now considered as one of the most
interesting and promising programming languages, supported by countless individuals
and leading companies of the computer industry, for instance, it&#8217;s actively used in the areas of application, game, web
and cryptocurrency development. Nim has made a large amount of progress in the last few years:
it reached version Nim v1.6 with some stability guarantees and a new deterministic memory
management system was introduced, which will improve support of parallel processing
and the use of Nim in the area of embedded systems development.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_is_nim_not_a_popular_mainstream_language_yet">Why is Nim not a popular mainstream language yet?</h3>
<div class="paragraph">
<p>Nim was created by Mr. A. Rumpf in 2008, supported by a few volunteers. Finally, in
2018 Nim got some significant monetary support by <span class="ndef">Status Corp.</span> and in 2019
the stable Nim version 1.0 was released. But still Nim is developed by a small core team
and some volunteers, while some other languages like Java, C#, Go, or Rust are
supported by large companies, or like C and C++ have a very long history and
well-trained users. And finally there are many competing languages, some with a
longer history, and some possibly better suited for special purposes, like JavaScript,
Dart or Kotlin for web development, Julia or R for numeric applications, or Zig, C and
Assembly for the tiny 8-bit microcontrollers with a small amount of RAM.</p>
</div>
<div class="paragraph">
<p>Nim is already supported by more than 1000 external packages which cover many
application areas, but that number is still small compared to really popular
languages like Python, Java or JavaScript. And some Nim packages can currently not
really compare with the libraries of other languages, which have been optimized for
years by hundreds or thousands of full-time developers.</p>
</div>
<div class="paragraph">
<p>Indeed, the future of Nim is not really secure. Core developers may vanish, financial
support may stop, or maybe a better language may appear. But even if the development
of Nim should stop some day, you will still be able to use it, and many concepts that
you may have learned with Nim can be used with other modern languages too.</p>
</div>
</div>
<div class="sect2">
<h3 id="_is_nim_a_good_choice_as_first_language_for_a_beginner">Is Nim a good choice as first language for a Beginner?</h3>
<div class="paragraph">
<p>When you use C as your first language, you may learn well how computers
really work, but the learning experience is not that nice, progress is slow and
C lacks many concepts of modern programming languages. C++, Rust or
Haskell are really too difficult for beginners. So currently many starts with Python.
While you can learn high level concepts well with Python and you get useful results fast,
you learn not much about the internal working of computers. So you may never
understand why your code is slow and consumes so many resources, and you
will have no idea how to improve the program or how you could run
it successfully on restricted hardware.
It&#8217;s like learning
to drive a car, without any knowledge about how a combustion engine, the
transmission, or the brakes really work. Nim has none of these restrictions, as
we have high level concepts available like in Python, but we have access to
low level stuff too, so we can really understand the internal workings, if we want.
Learning resources for Nim are still not that good as for mainstream languages,
but there exists some nice tutorials already, and hopefully this book will help beginners also a bit.</p>
</div>
</div>
<div class="sect2">
<h3 id="_is_nim_really_a_good_teaching_language">Is Nim really a good teaching language?</h3>
<div class="paragraph">
<p>Generally yes, in the same way as Pascal was in the 1980s, and Modula/Oberon were
at the end of the last century. But Nim still has the same problems
as the wirthian languages: They do not really help with finding a job. When we teach
the kids some JavaScript or C, they may find at least a simple employment when they
have to leave the intended education path early for some reason. With niche languages
this is unfortunately not the case, so teachers should know about their responsibility.
And of course teaching against the interests of the kids makes not much sense. When
they want to learn some JavaScript to make some visual effects or whatever easily, then it
is hard to teach another language which may be not immediately available on the PC at home or
their smartphone.</p>
</div>
</div>
<div class="sect2">
<h3 id="_so_is_nim_really_the_best_start_for_me">So is Nim really the best start for me?</h3>
<div class="paragraph">
<p>Maybe not. When you intend to learn a programming language today
and make a great video game tomorrow, then definitely not. This
is just not possible. While there are nice libs for making games
with Nim already available, there exists easier solutions
in other languages. With some luck you may find some source code
for that languages, so that you can patch a few strings
and perhaps modify some colors and the background music and call it your game.</p>
</div>
</div>
<div class="sect2">
<h3 id="_after_learning_nim_will_i_still_have_to_learn_other_programming_languages">After learning Nim, will I still have to learn other programming languages?</h3>
<div class="paragraph">
<p>Nim is a quite universal language, so it is a good candidate for
someone who intends to learn only one single language. But of course, it
is always a good idea to learn a few other languages later. Generally, we can not
really avoid learning C, as so much C code exists worldwide. Most algorithm that have
ever been invented are available as a C implementation somewhere, and most
libraries are written in C or have at least a C API, which you can use from other languages including
Nim. As C is a small language without difficult language constructs, some minimal C
knowledge is typically sufficient to convert a C program to another language. Often that
conversion process is supported by tools, like the Nim c2nim tool. So learning some C later
is really a good idea, and when you have some basic understanding of Nim and CS in general,
learning some C is an easy task. Learning C before Nim would be an option still, as for
C more learning resources exists. So, years ago, some people recommended learning C or Python
before Nim. But Nim has enough learning resources now, so we recommend indeed starting with
Nim directly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_why_should_i_not_use_nim">Why should I not use Nim?</h3>
<div class="paragraph">
<p>Perhaps it is just not the ideal solution for you. A racing bicycle or a mountain bike are
both great devices, but for cycling a few hundred meters to the bakers shop both may
be not the perfect solution. A plain old bicycle would do better. Even as Nim
seems to join the benefits of a racing bicycle and a mountain bike well&#8201;&#8212;&#8201;high performance and
robust design&#8201;&#8212;&#8201;and is not expensive, it is just not the optimal solution for everybody.
People who write only tiny scripts and have not to care about performance can continue
using Python. People who are only interested in special applications, maybe only
in web development or only in tiny 8-bit microcontrollers, may not really need Nim. Nim can
do this and much more well, but for special use cases better suited languages may still
exist. And someone who has managed to learn C++ really well over a period of
many years may decide to continue with C++ also. Currently, another possible reason for not using Nim
can be missing libraries. When you require some important libraries for your project, and
these are currently not available for Nim, this can be of course a big problem in the case that you
have not the skills or the time to write them from scratch or at least create high level bindings
to a C library.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_our_first_nim_program">Our first Nim Program</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To keep our motivation, we will present a first tiny Nim program now. Actually, we
should have delayed this section until we have installed the Nim compiler on our
computer, but we can already run and test the program by just copying it into one of
the available Nim online playgrounds like</p>
</div>
<div class="paragraph">
<p><a href="https://play.nim-lang.org/" class="bare">https://play.nim-lang.org/</a></p>
</div>
<div class="paragraph">
<p>In the section <a href="#_what_is_an_algorithm">What is an Algorithm?</a> we described an algorithm to sum up the
first 100 natural numbers. Converting that algorithm into a Nim program is
straightforward and results in the text file below. You can copy it into the
playground and run it now if you want. The program is built using some elementary Nim
instructions, for which we will give only a very short description here. Everything is
explained in much more detail in the next part of this book.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var sum: int
var i: int
sum = 0
i = 0
while i &lt; 100:
  inc(i, 1)
  inc(sum, i)
echo sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>We write Nim programs with an editor tool in the form of plain text files, and you will learn how to
create them soon. We call these text files the <span class="ndef">source code</span> of the program.
The source code is the input for the compiler. The compiler processes the source
code, checks it for obvious errors and then generates an executable file, which
contains the final CPU instructions and can be run. Executable files are sometimes
called executables or binary files. The term binary is misleading, as all files on
computers are indeed stored as binary data, but the expression "binary" is used to
differentiate the executable program from text files like the Nim source code which
we can read, print and edit in an editor. Don&#8217;t try to load the executable files
generated by the Nim compiler into a text editor, as the content is not plain text,
but numeric machine code that may confuse the editor. On the Windows OS, executable
files typically get a special name extension <span class="term">.exe</span>, but on Linux no special
name extensions are used.</p>
</div>
<div class="paragraph">
<p>Nim source code files are processed by the Nim compiler from the top to the bottom, and
for the generated executable the program execution also starts in principle at the top.
But for the program execution there exists some exceptions, e.g. program code enclosed in functions
is not immediately executed where it appears in the program source code file, but later
when the function is called. And the program execution is not a linear process&#8201;&#8212;&#8201;we can use
conditional expressions to skip parts of the program, or various loop constructs to repeat
the execution of some program segments. Actually, the program execution in Nim is more
similar to languages like Python or Ruby than to the C language: A C program always
needs a main() function with exactly this name, and the execution of a C program
always starts by a compiler generated call of this function.</p>
</div>
<div class="paragraph">
<p>Elementary entities of computer programs are variables, which are basically named
storage areas in the computer. As Nim is a compiled and statically-typed language, we
have to declare each variable before we can use it. We do that by choosing a
meaningful name for the variable and specifying its data type. To tell the compiler
about our intention to declare a variable, we start the line with the <span class="key">var</span>
keyword, followed by the chosen name, a colon and the data type of our variable. The
first line of our program declares a new variable named <span class="var">sum</span> of data type <span class="type">int</span>. Int is
short for integer and indicates, that our variable should be able to store negative or
positive integer numbers. The <span class="key">var</span> at the start of the line is a
<span class="ndef">keyword</span>. Keywords are reserved symbols which have a special meaning for the
compiler. Var indicates that we want to introduce a new variable. The compiler will
recognize that and will reserve a memory location in the RAM of the computer which
can store the actual value of the variable.</p>
</div>
<div class="paragraph">
<p>The second line is nearly identical to the first line: we declare another variable,
again with <span class="type">int</span> type and plain name <span class="var">i</span>. Variable names like i, j, k are typically used when
we have no idea for a meaningful name and when we intend to use that variable as a
counter in a loop.</p>
</div>
<div class="paragraph">
<p>In the lines 3 and 4 of our program we initialize the variables, that is, we give
them a well-defined initial value. To do that, we use the <span class="op">=</span> operator to
assign it a value. Operators are special symbols like <span class="op">&#43;</span>, <span class="op">-</span>,
<span class="op">*</span> or <span class="op">/</span> to indicate our desire to do an addition, a subtraction, a
multiplication or a division. Note that the <span class="op">=</span> operator is used in Nim like
in many other programming languages for assignment, and not like in traditional
mathematics as an equality test. The reason for that is that in computer programming,
assignments occur more frequently than equality tests. Some early languages like Pascal
use the compound <span class="op">:=</span> operator for assignment, which may be closer to
mathematics use, but is more difficult to type on a keyboard and looks not too nice
for most people. An expression like <span class="code">x = y</span> assigns the content of variable y
to x, that is, x gets the value of y, the former value of x is overwritten and lost,
and the content of y remains unchanged. After that assignment, x and y contain the
same value. In the above example, we do not assign the content of a variable to the
destination, but instead use a literal numeric constant with value <span class="lit">0</span>. When the
computer has executed lines 3 and 4 the variables sum and i each contain the start
value <span class="lit">0</span>.</p>
</div>
<div class="paragraph">
<p>Line 5 is much more interesting: it contains a <span class="key">while</span> condition. The line
starts with the term <span class="key">while</span>, which is again a reserved keyword, followed by
the logical expression <span class="code">i &lt; 100</span> and a colon. An expression in Nim is
something which has a result, like a math expression as <span class="code">2 &#43; 2</span> which has the
result 4 of type integer. A logical expression has no numerical result, but a logical (boolean)
one, which can be <span class="lit">true</span> or <span class="lit">false</span>. The logical expression <span class="code">i &lt;
100</span> depends on the actual content of variable <span class="var">i</span>. The two lines following
the line with the <span class="key">while</span> keyword are each indented by two spaces, meaning
that these lines start with two spaces more than the line before. That form of
indentation is used in Nim (and Python) to indicate blocks. Blocks are grouped statements. The
complete while loop consists of the line containing the <span class="key">while</span> keyword followed by a
block of statements. The block after the <span class="key">while</span> condition is executed as long as the
<span class="key">while</span> condition evaluates to the logical value <span class="lit">true</span>. For the first loop iteration <span class="var">i</span> has the
initial value <span class="lit">0</span>, the condition <span class="code">i &lt; 100</span> evaluates to the boolean value <span class="lit">true</span>
and the block after the <span class="key">while</span> condition is executed for the first time. In
the following block, we have the <span class="func">inc()</span> instruction. <span class="func">inc</span> is short
for increment. <span class="func">inc(a, b)</span> increases the value of <span class="var">a</span> by <span class="var">b</span>, <span class="var">b</span> remains unchanged. So
in the above block <span class="var">i</span> is increased by one, and after that <span class="var">sum</span> is
increased by the current value of <span class="var">i</span>. So when that block has been executed for the
first time, <span class="var">i</span> has the value <span class="lit">1</span> and <span class="var">sum</span> also has the value
<span class="lit">1</span>. At the end of that block, execution starts again at the line with the
<span class="key">while</span> condition, now testing the expression <span class="code">i &lt; 100</span> with <span class="var">i</span>
containing the value <span class="lit">1</span>. Again it evaluates to <span class="lit">true</span>, the block is
executed again, <span class="var">i</span> gets the new value <span class="lit">2</span>, and <span class="var">sum</span> gets the
value <span class="lit">3</span>. This process continues until <span class="var">i</span> has the value <span class="lit">100</span>,
so the condition <span class="code">i &lt; 100</span> evaluates to <span class="lit">false</span> and execution proceeds
with the first instruction after the <span class="key">while</span> block. That instruction is an
<span class="func">echo</span> statement, which is used in Nim to write values to the terminal or
screen of the computer. Some other languages use the term <span class="func">print</span> or
<span class="func">put</span> instead of <span class="func">echo</span>.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t worry if you have not understood much of this short explanation, we will
explain all that in much more detail later.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>If you should decide to try the above program, maybe in a playground
internet page or already on your local computer, then it is best to copy the source code verbatim
instead to type it in from scratch, as for beginners tiny typos can generate a lot of trouble.
For the case that you should decide to type it in with your keyboard, you should try to
type it exactly as displayed above. All the program code should start directly at
the first column, but the two lines after the <span class="key">while</span> keyword should start
with two spaces. This strict indentation is used in Nim and some other programming languages
like Python or Haskell to structure the program code and to mark the extent of code blocks.
Some other programming languages like C do a similar alignment of the source code for readability,
but that alignment is ignored by the C compiler&#8201;&#8212;&#8201;instead blocks have to be enclosed in curly braces <span class="term">{}</span>.
Note that you have to do the indentation really with spaces, as Nim does not accept tabulator characters in
its source files.
Also note that the Nim compiler does distinguish between words starting with a lower or an upper case letter.
Nim keywords are written always in lower case, and when we define a variable as <span class="var">sum</span> then we
should always refer to it in exactly this notion.footnote:[Actually Nim relaxes this strict notation a bit, which is called</p>
</div>
<div class="paragraph">
<p>Also note that spaces in the Nim source code are important and can change the semantic: While
in C spaces are mostly only used to separate distinct symbols, in Nim spaces have some more functionality.
For instance in mathematically expressions, <span class="code">a - b</span> or <span class="code">a-b</span> is both a valid subtraction in
the case when <span class="var">a</span> and <span class="var">b</span> both have a numeric type for which an infix subtraction operator is defined, but
the code segment <span class="code">a -b</span> may give us an error message from the compiler. The reason is, that in this case,
the <span class="op">-</span> sign is directly attached to <span class="var">b</span> but separated to <span class="var">a</span> by at least one space. In this
case, the Nim compiler would interpret the <span class="op">-</span> sign as a unary operator attached to <span class="var">b</span>.
Even in the case that such a unary <span class="op">-</span> may have been defined before, then the operands
<span class="var">a</span> and <span class="var">b</span> would be not separated by an infix operator, which is an invalid syntax in Nim.
An expression like <span class="code">a - -b</span> would be a valid syntax instead&#8201;&#8212;&#8201;unary minus attached to <span class="var">b</span>, and
<span class="var">a</span> and <span class="var">(-b)</span> separated by an infix <span class="op">-</span> operator. In this example, we have learned already that the same symbol
can have a different meaning in the Nim language, depending on the context. For operators or
functions, this is called overloading, which most modern programming languages use.
This sensitivity to the asymmetric use of spaces applies also to the <span class="term">less than</span> operator that we used in the above example:
<span class="code">a &lt; b</span> or <span class="code">a&lt;b</span> is the infix notation that we generally intend for a comparison operation, while <span class="code">a &lt;b</span> would be mostly invalid code.
For infix operators we typically put a space on each side, as this improves readability, but it is not really needed
and so some people do not insert these spaces. Unary operators, like the unary <span class="op">-</span> sign, should always precede
a variable or a literal without a space.</p>
</div>
<div class="paragraph">
<p>All this may sound a bit complicated, and for beginners the compiler error messages about this formatting
rules may be not always fully clear. But finally it is just how we would write the code with
paper and pencil, and after the initial learning phase you just will do it right without thinking about it.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_binary_numbers">Binary Numbers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When we write numbers in ordinary life we typically use the decimal system with base
10 and the 10 available digits 0, 1, &#8230;&#8203; 9. To get the value of a decimal number, we
multiply each digit with powers of 10 depending on the position of the digit and sum
the individual terms. The rightmost digit is multiplied with 10^0, the next digit
with 10^1, and so on. A literal decimal number like 7382 has then the numerical
value <span class="term">2 * 10^0 &#43; 8 * 10^1 &#43; 3 * 10^2 &#43; 7 * 10^3</span>. We have used here the
exponential operator <span class="term">^</span>&#8201;&#8212;&#8201;with <span class="term">10^3 = 10 * 10 * 10</span>. Current
computers use binary representation internally for numbers. Generally we do not care
much about that fact, but it is good to know some facts about binary numbers. Binary
numbers work nearly identically to decimal numbers. The distinction is that we have
only two available digits, which we write as <span class="term">0</span> and <span class="term">1</span>. A number in
binary representation is a sequence of these two digits. Like in the decimal system,
the numerical value results from the individual digits and their position: The binary
number <span class="term">1011</span> has the numerical value <span class="term">1 * 2^0 &#43; 1 * 2^1 &#43; 0 * 2^2 &#43; 1
* 2^3</span>, which is 11 in decimal notation. For binary numbers, the base is 2, so we
multiply the binary digits by powers of two. Formally, addition of two binary numbers
works like we know it from the decimal system: we add the matching digits and take
carry into account: <span class="term">1001 &#43; 1101 = 10110</span> because we start by adding the two
least significant digits of each number, which are both 1. That addition 1&#43;1 results
in a carry and result 0. The next two digits are both zero, but we have to take the
carry from the former operation into account, so the result is 1. For the next position,
we have to add 0 and 1, which is just 1 without a carry. And finally we have 1 &#43; 1,
which results in 0 with a carry. The carry generates one more digit, and we are done.
In the decimal system with base 10 a multiplication with 10 is easily calculated by
just shifting all digits one place to the left and writing a 0 at the now empty
rightmost position. For binary numbers it is very similar: a multiplication by the
base, which is two in the binary system, is just a shift left, with the rightmost
position getting digit 0.<sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup></p>
</div>
<div class="paragraph">
<p>In the binary system we call the digits typically <span class="ndef">bits</span>, and we number the bits
from right to left, starting with 0 for the rightmost bit&#8201;&#8212;&#8201;we say that the binary
number 10010101 is an 8-bit number because writing that number in binary
representation needs 8 digits. Often we imagine the individual bits as small bulbs, a
1 bit is imagined as a lit bulb, and a 0 bit is imagined as a dark bulb. For lit
bulbs we say also that the bit is set, meaning that in the binary number 10010101,
bits 0, 2, 4 and 7 are set, and the other bits are unset or cleared.</p>
</div>
<div class="paragraph">
<p>Groups of 8 bits are called a <span class="ndef">byte</span>, and sometimes 4 bits are called a
<span class="ndef">nibble</span>.</p>
</div>
<div class="paragraph">
<p>One, two, four or 8 bytes are sometimes called a <span class="ndef">word</span>, where a word is an
entity which the computer can process in one single instruction. When we have a CPU
with 8 byte word size, this means that the computer can for example add two variables,
each 8 byte in size, in one single instruction.</p>
</div>
<div class="paragraph">
<p>Let us investigate some basic properties of binary numbers. Let us assume that we
have an 8-bit word (a byte). An 8-bit word can have 2^8 different states, as each bit
can be set or unset independently of the other bits. That corresponds to numbers 0
up to 255&#8201;&#8212;&#8201;we assume that we work with positive numbers only for now, we will come
to negative numbers soon. An important property of binary numbers in computers is the
wrapping around, which is a consequence of the fact that we have only a limited set
of bits available to store the number. So when we continuously add 1 to a number, at
some point all bits are set, which corresponds to the largest number that can be
stored with that number of bits. When we then add again 1, we get an overflow. The
run-time system may catch that overflow, so we get an overflow error, or the number
is just reset to zero, as it may happen in our car when we manage to drive one
million miles, or when the ordinary clock jumps from 23:59 to 00:00 of the next day.
A useful property of binary numbers is the fact that we can easily invert all bits,
that is, replace set bits by unset ones and vice versa. Let us use the prefix
<span class="term">!</span> to indicate the operation of bit inversion, then <span class="term">!01001100</span> is
<span class="term">10110011</span>. It is an obvious and useful fact that for each number x we get a
number with all bits set when we add x and !x. That is <span class="term">x &#43; !x = 11111111</span>
when we consider an 8 bit word. And when we ignore overflow, then it follows that
<span class="term">x &#43; !x &#43; 1 = 0</span> for each number x. That is a useful property, which we can
use when we consider negative numbers.</p>
</div>
<div class="paragraph">
<p>Now let us investigate how we can encode negative numbers in binary form. In the
binary representation we have only two states available, 0 or 1, a set bit or an
unset bit. But we have no unitary minus sign. We could encode the sign of a number in
the topmost bit of a word&#8201;&#8212;&#8201;when the topmost bit is set, that indicates that the
number is regarded as negative. Generally a modified version of this encoding is used,
called <span class="ndef">two&#8217;s complement</span>: a negative number is constructed by first inverting all the
bits&#8201;&#8212;&#8201;a 0 bit is transferred into a 1 bit and vice versa&#8201;&#8212;&#8201;and finally the number
1 is added. That encoding simplifies the CPU construction, as subtraction can be
replaced by addition in this way:</p>
</div>
<div class="paragraph">
<p>Consider the case that we want to do a subtraction of two binary encoded numbers. The
operation has the symbolic notation A - B for arbitrary numbers A and B. The
subtraction is by definition the inverse operation of the addition, that is A &#43; B - B
= A for each number A and B, or in other words, B - B = 0 for each number B.</p>
</div>
<div class="paragraph">
<p>Assume we have a CPU that can do additions and that can invert all the bits of a
number. Can we do subtraction with that CPU? Indeed, we can. Remember the fact that
for each number X <span class="term">X &#43; !X &#43; 1 = 0</span> as long as we ignore overflow. If that
relation is true for each number, then it is obviously true for each B in the
expression A - B, and we can write A - B = A &#43; (B &#43; !B &#43; 1) - B = A &#43; (!B &#43; 1) when
we use the fact that in mathematics addition and subtraction is associative, that is
we can group the terms as we want. But the term in the parenthesis is just the
two&#8217;s complement, which we get when we invert all bits of B and add 1. So to do a subtraction
we have to invert the bits of B, and then add A and !B and 1 ignoring overflow. That
may sound complicated, but a bit inversion is a very cheap operation in a CPU, which is
always available, and adding 1 is also a very simple operation. The advantage is that
we do not need separate hardware for the subtraction operation. Typically,
subtraction in this way is not slower than addition because the bit inversion and the
addition of 1 can be performed at the same time in the CPU as an ordinary addition.</p>
</div>
<div class="paragraph">
<p>From the equation above, indicating A - B = A &#43; (!B &#43; 1) it is obvious that we
consider the two&#8217;s complement (!B &#43; 1) as the negative of B. Note that the two&#8217;s complement of zero
is again zero, and two&#8217;s complement of 00000001 is 11111111. All negative numbers in this
system have a bit set to 1 at the leftmost position. This restricts all positive
numbers to all the bit combinations where the leftmost bit is unset. For an 8-bit
word, this means that positive numbers are restricted to the bits 00000000 to
01111111, which is the range 0 to 127 in decimal notation. The two&#8217;s complement of decimal
127 is 10000001. Seems to be fine so far, but note that there exists also the bit pattern
10000000 which is -128 in decimal. For that bit pattern, there exists no positive
value. If we try to build the two&#8217;s complement of that bit pattern, we would get the same
pattern again. This is an asymmetry of two&#8217;s complement representation, which can not be
avoided. It generally is no problem, with one exception. We can never invert the sign
of the smallest available integer; that operation would result in a run-time
error.<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup></p>
</div>
<div class="paragraph">
<p>Summary: when we work only with positive numbers, we can store in an 8-bit word,
which is called a byte, numbers from 0 up to 255. In a 16-bit word we could
store values from 0 up to 2^16 - 1, which is 65535. When we need numbers which can be
also negative, we have for 8-bit words the range from -128 to 127 available, which is
-2^7 up to 2^7 - 1. For a signed 16-bit word, the range would be -2^15 up to 2^15 - 1.</p>
</div>
<div class="paragraph">
<p>While we can work with 8 or 16-bit words, for PC programming the CPU usually supports
32 or 64-bit words, so we have a much larger number range available. But when we
program microcontrollers or embedded devices we may indeed have only 8 or 16-bits words
available, or we may use such small words size intentionally on a PC to fit all of
our data into a smaller memory area.</p>
</div>
<div class="paragraph">
<p>One important note at the end of this section: whenever we have a word with a
specific bit pattern stored in the memory of our computer, then we can not decide
from the bit pattern directly what type of data it is. It can be a positive or a
negative number, but maybe it is not a number at all but a letter or maybe something
totally different. As an example, consider this 8 bit word: 10000001. It could be 129
if we have stored intentionally positive numbers in that storage location, or could
be -127 if we intentionally stored a negative value. Or it could be not a number at
all. Is that a problem? No, it is not as long as we use a programming language like
Nim which use static typing. Whenever we are using variables, we declare their type
first, and so the compiler can do bookkeeping about the type of each variable stored
in the computer memory. The benefit is, that we can use all the available bits to
encode our actual data, and we do not have to reserve a few bits to encode the actual
data type of variables. For languages without static typing, that is not the case. In
languages like Python or Ruby, we can use variables without a static type, so we can
assign whatever we want to it. That seems to be comfortable at first, but can be
confusing when we write larger programs and the Python or Ruby interpreter has to do
all the bookkeeping at run-time, which is slow and wastes memory for the bookkeeping.</p>
</div>
<div class="paragraph">
<p>To say it again in other words: for deciding if an operation is valid, it is
generally sufficient to know the data type of the operands only. We do not have to
know the actual content. The only exception is if we invert the sign of the most
negative integer number or if we do an operation with causes an overflow, as there
are not enough bits available to store the result&#8201;&#8212;&#8201;we may get a run-time error for
that case.<sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup> In a
statically-typed language each variable has a well-defined type, and the compiler can
ensure at compile time that all operations on that variables are valid. If an
operation is not valid, then the compiler will give an error message. Then when these
operations are executed at run-time they are always valid operations, and the actual
content, like the actual numeric value, does not matter.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hexadecimal_numbers">Hexadecimal Numbers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>These number type with base 16 is by far not that important than the binary numbers,
and it has not really a technical justification to exist, but you may get in touch
with these numbers from time to time. Hexadecimal numbers are mostly a legacy from
early days of computers, where computer programming was done not in real programming
languages but with numeric codes. To represent the 16 hexadecimal digits, the 10
decimal digits are supported by the characters 'A' .. 'F'. The most significant
property of a hexadecimal digit is that it can represent four bits, a unit half of a
byte, which is called sometimes a nibble. In old times, when it was necessary to type
in binary numbers, it was sometimes easier to encode a nibble with a hexadecimal
digit:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Decimal</th>
<th class="tableblock halign-left valign-top">Binary</th>
<th class="tableblock halign-left valign-top">Hexadecimal</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0001</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0010</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0011</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0111</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1001</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1010</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1011</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">B</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1101</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">D</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1110</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">E</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1111</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">F</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The only location where we hear about hexadecimal characters again in this book
should be when we introduce the character and string data types&#8201;&#8212;&#8201;there control
characters like a newline character are sometimes specified in hexadecimal form like
"\x0A" for a newline character.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_installation_of_the_compiler">Installation of the Compiler</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We will not describe in too much detail how you can install the Nim compiler, because
that strongly depends on your operating system, and because the installation instructions
may change in the future. We assume that you have a computer with an installed
operating system and internet access, and you are able to do at least very basic
operations with your computer, such as switching it on, log in and opening a web
browser or a terminal window. If that is not the case, then you really should ask
someone for help for this basic step, and maybe for some more help for other basic
tasks.</p>
</div>
<div class="paragraph">
<p>Detailed installation instructions are available on the Nim internet homepage at
<a href="https://nim-lang.org/install.html.footnote:">To visit and read that page, you have to
enter this string in the address input field of your internet browser.</a> Try to follow
those instructions, and when they are not sufficient, then please ask at the Nim
forum for help: <a href="https://forum.nim-lang.org/" class="bare">https://forum.nim-lang.org/</a></p>
</div>
<div class="paragraph">
<p>If you are using a Linux operating system, then your system generally provides a
package manager, which should make the installation very easy.</p>
</div>
<div class="paragraph">
<p>For example, for a Gentoo Linux system, you would open a root terminal and simple type
<span class="term">emerge -av nim</span>. That command would install Nim, including all necessary dependencies
for you. It may take a few minutes as Gentoo compiles all packages fresh from source
code, but then you are done. Similar commands exist for most other Linux
distributions.</p>
</div>
<div class="paragraph">
<p>Another solution, which is preferable when you want to ensure that you get the most
recent Nim compiler, is compiling directly from the latest git sources. That process
is also easy and is described here: <a href="https://github.com/nim-lang/Nim" class="bare">https://github.com/nim-lang/Nim</a>. But before you
can follow those instructions, you have to ensure that the git software and a working
C compiler is available on your computer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_creation_of_source_code_files">Creation of Source Code Files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nim source code, as most source code of other programming languages, is based on text
files. Text files are documents saved on your computer that contain only ordinary
letters, which you can type on your keyboard. No images or videos, no HTML content
with fancy CSS styling. Generally, source code should contain only ordinary ASCII
text, that is, no umlauts or Unicode characters.</p>
</div>
<div class="paragraph">
<p>To create source code, we typically use a text editor, which is a tool designed for
creating and modifying of plain text files. If you do not have a text editor yet, you
may also use a word processor for writing some source code, but then you have to
ensure that the file is finally saved as plain ASCII text. Editors typically support
syntax highlighting, that is keywords, numbers and such are displayed with a unique
color or style to make it easier to recognize the content. Some editors support
advanced features like checking for errors while you type the program source code.</p>
</div>
<div class="paragraph">
<p>A list of recommended editors is available at <a href="https://nim-lang.org/faq.html" class="bare">https://nim-lang.org/faq.html</a></p>
</div>
<div class="paragraph">
<p>If you do not want to use a special editor now, then for Linux gedit or at least
<span class="term">nano</span> should be available. For Windows, maybe something like notepad.</p>
</div>
<div class="paragraph">
<p>Typically, we store our Nim source code files in its own directory, that is a separate
section of your hard-disk. If you work on Linux in a terminal window, then you can
type</p>
</div>
<div class="listingblock">
<div class="content">
<pre>cd
mkdir mynimfiles
cd mynimfiles
gedit test.nim</pre>
</div>
</div>
<div class="paragraph">
<p>You type these commands in the terminal window and press the <span class="term">return</span> key
after each of the above lines&#8201;&#8212;&#8201;that is, you type <span class="term">cd</span> on your keyboard and
then press the <span class="term">return</span> key to execute that command. The same for the next
three commands. What you have done is this: you go to your default working area
(home directory), then create a subarea named mynimfiles, then you go into that
subarea, and finally you launch the gedit editor&#8201;&#8212;&#8201;the argument test.nim tells gedit
that you want to create a new file called test.nim. If gedit is not available, or if
you work on a computer without a graphical user interface, then you may replace the
gedit command by nano. While gedit opens a new window with a graphical interface,
nano opens only a very simple interface in the current terminal. An interesting
editor without a GUI is vim or neovim. That is a very powerful editor, but it is
difficult to learn, and it is a bit strange as you have a command mode and an ordinary
text input mode available. For neovim there is very good Nim support available.</p>
</div>
<div class="paragraph">
<p>If you do not want to work from a terminal, or if you are using Windows or macOS,
then you should have a graphical user interface which enables you also to create a
directory and to launch an editor.</p>
</div>
<div class="paragraph">
<p>When the editor is opened, you can type in the Nim source code from our previous
example and save it to a file named test.nim. Then you can terminate the editor.</p>
</div>
<div class="paragraph">
<p>Note that the <span class="term">return</span> key behaves differently in editors than in the terminal
window: In the terminal window, you type in a command and finally press the return key
to "launch" or execute the command. In an editor, the return key is not that special:
if you press ordinary keys in your editor, then that key is inserted and the cursor
moves one position to the right. And when you press the return key, then an invisible
newline character is inserted and the cursor moves to the start of the next line.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_launching_the_compiler_and_running_the_program">Launching the compiler and running the program</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you are working from a Linux terminal, then you can type</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ls -lt
cat test.nim</pre>
</div>
</div>
<div class="paragraph">
<p>That is, you first show the content of your directory with the ls command and then
display the content of the Nim source code file that you just have typed in with the
cat command.</p>
</div>
<div class="paragraph">
<p>Now type</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nim c test.nim</pre>
</div>
</div>
<div class="paragraph">
<p>That invokes the Nim compiler and instructs it to compile your source code. The "c"
letter is called an option, it tells the Nim compiler to compile your program and to
use the C backend to generate an executable.</p>
</div>
<div class="paragraph">
<p>The compiler should display nearly immediately a success message. If it displays some
error messages instead, then you launch gedit or nano again, fix your typing error,
save the modified file and call the compiler again.</p>
</div>
<div class="paragraph">
<p>Finally, when the source text is successfully compiled, you can run your program by
typing</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./test</pre>
</div>
</div>
<div class="paragraph">
<p>In your terminal window, you see a number now, which is the sum of the numbers 1 to
100.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>You may wonder why you have to type the prefix <span class="term">./</span> in front of the name of
your generated executable program, as you can launch most other executables on your
computer without such a prefix. The prefix is generally needed to protect you and
your computer from erroneously launching a program in the current directory while
you intended to launch a system command. Imagine you downloaded a zip file from
internet, extract it, cd into the extracted directory and type <span class="term">ls</span> to see the
directory content. Imagine now that the directory contains an executable named ls,
which is executed instead of system <span class="term">ls</span>. That foreign ls command may damage
your system. So to execute non system commands, you generally have to use the prefix
<span class="term">./</span> where the period refers to the current directory. Of course, you can
install your own programs in a way that you don&#8217;t need such a prefix anymore&#8201;&#8212;&#8201;just
ask your Mom or Grandma if you don&#8217;t know yourself already.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>If you have not managed to open a terminal where you can invoke the compiler&#8201;&#8212;&#8201;well,
maybe then you should install some advanced editors like VS-Code. They should
be able to launch the compiler and run the program from within the editor directly.</p>
</div>
<div class="paragraph">
<p>The command</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nim c test.nim</pre>
</div>
</div>
<div class="paragraph">
<p>is the most basic compiler invocation. The extension .nim is optional, the compiler
can infer that file extension. This command compiles our program in default debug mode, it
uses the C compiler back end and generates a native executable. Debug mode means,
that the generated executable contains a lot of checks, like array index checks,
range checks, nil dereference checks and many more. The generated executable will run
not very fast, and it will be large, but when your program has bugs, then the program
will give you a meaningful error message in most cases. Only after you have tested
your program carefully, you may consider compiling it without debug mode. You may do
that with</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nim c -d:release test.nim

nim c -d:danger test.nim</pre>
</div>
</div>
<div class="paragraph">
<p>The compiler option -d:release removes most checks and debugging code and enables the
backend optimization by passing the option "-O3" to the C compiler backend, giving a
very fast and small executable file. The option -d:danger removes all checks, it
includes -d:release. You should be aware that compiling with -d:danger means that
your program may crash without any useful information, or even bad, may run, but
contain uncatched errors like overflows and so may give you wrong results. Generally,
you should compile your program with plain <span class="term">nim c</span> first. When you have tested
it well, and you may need the additional performance, you may switch to -d:release
option. For games, benchmarks or other uncritical stuff you may try -d:danger.</p>
</div>
<div class="paragraph">
<p>There exists many more compiler options, you can find them explained in the Nim
manual, or you may use the command nim --help and nim --fullhelp to get them
displayed. One important new option is --gc:arc to enable the new deterministic
memory management. You may combine --gc:arc with -d:useMalloc to disable Nim&#8217;s own
memory allocator, this reduces the executable size and enables the use of Valgrind to
detect memory leaks. Similar to --gc:arc is the option --gc:orc which can deal with
cyclic data structures. Finally, a very powerful option is --passC:-flto. This option
is for the C compiler backend and enables link time optimization (LTO). LTO enables
inlining for all procedure calls and can significantly reduce the final program size.
For a recent Nim compiler version, instead of --passC:-flto also -d:lto can be used.
We should mention that you can also try the C++ compiler backend with the cpp command
instead of plain c command, and that you may compile with clang backend instead of
default GCC backend with the --cc:clang option. You can additional specify the option
-r to immediately run the program after successful build. For testing small scripts,
the compiler invocation in the form "nim r myfile.nim" can be used to compile and run
a program without generation of a permanent executable file. Here is an example how
we use all these options:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nim c -d:release --gc:arc -d:useMalloc --passC:-flto --passC:-march=native board.nim</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we additionally pass -march=native to the C compiler backend to enable
use of the most efficient CPU instructions of our computer, which may result in an
executable that will not run on older hardware. Of course, we can save all these
parameters in configuration files, so that we don&#8217;t have to actually type then for each
compiler invocation. You may find more explanations to all the compiler options in
the Nim manual, or in later sections of this book, this includes the options for the
JavaScript backend.</p>
</div>
</div>
</div>
<h1 id="_part_ii_the_basics" class="sect0">Part II: The Basics</h1>
<div class="openblock partintro">
<div class="content">
In this part we will introduce the most essential constructs of the Nim programming
language, like statements and expression, conditional and repeated execution,
functions and procedures, iterators, templates, exceptions, and we will discuss
various basic data types including the basic container types array, sequence and
string.
</div>
</div>
<div class="sect1">
<h2 id="_declarations">Declarations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We can declare constants, variables, procedures or our custom data types.
Declarations are used to give information to the compiler, for example, about the type
of a variable that we intend to use.</p>
</div>
<div class="paragraph">
<p>We will explain type and procedure declarations in later sections. Currently, only
constant and variable declarations are important.</p>
</div>
<div class="paragraph">
<p>A constant declaration in its simplest form maps a symbolic name to a value, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const Pi = 3.1415</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the reserved word <span class="key">const</span> to tell the compiler that we want to declare a
constant which we have named Pi, and we assign it the numeric decimal value 3.1415.
Nim has a small set of reserved words like <span class="key">var, const, proc, while</span> and
others, to tell the compiler that we want to declare a variable, a constant, a
procedure or that we want to use a while loop for some repeated execution.
Reserved words in Nim are special symbols that have a special meaning for the compiler, and we should
avoid using these symbols as names for other entities like variables, constants or functions, as that
would confuse the compiler.
The
<span class="op">=</span> is the assignment operator in Nim, it assigns the value or expression on the
right side of it to the symbol on the left. You have to understand that it is
different from the equal sign we may use in mathematics. Some languages like Pascal
initially used the compound operator <span class="op">:=</span> for assignments, but that is not
easy to type on the keyboard and looks a bit angry for sensible people. And source
code usually contains a lot of assignments, so use of <span class="op">=</span> makes some sense. We
call <span class="op">=</span> an operator. Operators are symbols which perform some basic operation,
like <span class="op">&#43;</span> for the addition of two numbers, or <span class="op">=</span> for the assignment of a
value to a symbol. With the above constant declaration, we can use the symbol
<span class="term">Pi</span> in our program&#8217;s source code and don&#8217;t have to remember or retype the
exact sequence of digits. Using named constants like our Pi above makes it easy to
modify the value&#8201;&#8212;&#8201;if we notice that we need more precision, we can look up the
exact value of Pi and change the constant at one place in our source code, we don&#8217;t
have to search for the digit sequence 3.14 in all our source code files.</p>
</div>
<div class="paragraph">
<p>For numeric constants like our <span class="var">Pi</span> value the compiler will do a substitution in the
source code when the program is compiled, so where we write the symbol <span class="var">Pi</span>
the actual numeric value is used.</p>
</div>
<div class="paragraph">
<p>For constant declarations, it must be possible to determine its value at compile time.
Expressions assigned to constants can contain simple operations like basic math, but
some functions calls may be not allowed.</p>
</div>
<div class="paragraph">
<p>Variable declarations are more complicated, as we ask the compiler to reserve a named
storage location for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var velocity: int</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we put the reserved keyword <span class="key">var</span> at the beginning of the line to tell the
compiler that we want to declare a variable, then we give our chosen name for that
variable followed by a colon and the data type of the variable. The int type is a
predefined numeric type indicating a signed integer type. The storage capacity of an
integer variable depends on the operating system of your computer. On 32-bit systems
32 bits are used, and on 64-bit systems 64 bits are used to store one single integer
variable. That is enough for even large signed integer numbers: the range is <span class="lit">-2^31</span>
up to <span class="lit">2^31 - 1</span> for 32-bit systems and <span class="lit">-2^63</span> up to <span class="lit">2^63 - 1</span> for 64-bit systems.</p>
</div>
<div class="paragraph">
<p>For variables, we generally use lower case names, but names of constants may start
with an upper case letter.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>In some Nim documentation and in this book, the terms <span class="ndef">declaration</span> and <span class="ndef">definition</span> may be
used alternately, which is not fully correct. Precisely, a declaration is a statement that something exists, while
a definition is a more detailed description. In the C programming language we differentiate between a
function declaration, which describes only the name of the function and the number and data types of its parameters, and
a function definition, which also has to specify the names of the function parameters as well
as the source code of the function body. In Nim, function declarations are not used that often, as
they are only really needed when two functions call each other. For that case we declare the first function, so
that we can already use it in the definition of the other function, before we finally also define the first function.
For other entities like constants, variables, data types or modules a distinction between the terms
declaration and definition makes not that much sense, that is why we may use both terms alternately.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_statements">Statements</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Statements, or instructions, are a core component of Nim programs: they tell the
computer what it shall do. Often statements are procedure calls, like the call of the
<span class="func">echo()</span> or <span class="func">inc()</span> procedure, which we have already seen in part I of
the book. We will learn what procedures exactly are in later sections. For now, we
just regard procedures as entities that perform a well-defined task for us when we
call (or invoke) them. We call them by just writing their name in our source file, followed
by a list of parameters, also called arguments. When we write <span class="code">echo 7</span> then
echo is the procedure which we call, and 7 is the argument, an integer literal in
this case. When the parameter list has more than one argument, then we separate
the arguments with a comma each, and generally we put an optional space after that comma.
The effect of our procedure call is that the decimal number 7 is written
to the terminal when we run the program after compilation. While in languages like
C the parameter list has to be always enclosed in brackets, in Nim we can frequently leave the
brackets out, which is called command invocation syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const SquareOfFive = 5 * 5
echo(5 * 5, SquareOfFive) # ordinary procedure call
echo 5 * 5, SquareOfFive # command invocation syntax</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command invocation syntax is often used with the <span class="func">echo()</span> procedure,
or when a procedure has only one single argument. For multiple
arguments, or when the argument is a complicated expression, the use
of brackets may be preferable. Some coding styles of other programming
languages, like C, sometimes put a space between the procedure name and
the opening bracket. For Nim, we should not do that, the reason will become clear
when we later explain the tuple data type. A few procedures have no parameters at all.
When we call these functions, we have to use always the syntax <span class="func">myProc()</span> with an empty
pair of brackets, to make it for the compiler clear that we want to call that function.
<span class="code">res = myProc()</span> assigns the result of the <span class="proc">proc</span> call to <span class="var">a</span>, while
<span class="code">res = myProc</span> would assign the <span class="proc">proc</span> itself to <span class="var">a</span>, which is very different.</p>
</div>
<div class="paragraph">
<p>A special form of
procedures are functions, that are procedures which perform operations to return a value, or a result. In
mathematics, sin() or cos() would be functions&#8201;&#8212;&#8201;we pass an angle as argument and
get the sine, or cosine as a result.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at this minimal Nim program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a: int
a = 2 + 3
echo a
echo(cos(0) + 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Nim program above consists of a variable declaration and three statements: in the
first line, we declare the variable we want to use. In the next line we assign the
value <span class="lit">2 &#43; 3</span> to it, and finally in line 3 we use the procedure
<span class="func">echo()</span> to display the content of our variable in the terminal window.
In the last line we use again the <span class="func">echo</span> procedure with an ordinary parameter list
enclosed in brackets. The parameter list has only one parameter, which is the
sum of a function call and the literal value <span class="lit">2</span>. Here the compiler would first
call <span class="func">cos(0)</span> and then add the literal value <span class="lit">2</span> to that result, before finally the sum
is passed to the <span class="func">echo</span> proc to print the value.<sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup></p>
</div>
<div class="paragraph">
<p>Nim programs are generally processed from top to bottom by the compiler, and when we
execute the program after successful compilation, then it also executes from top to
button. A consequence of this is that we have to write the lines of the above program
exactly in that order. If we moved the variable declaration down, then the compiler
would complain about an undeclared variable because the variable is used before it
has been declared. If we exchanged lines 2 and 3, then the compiler would be still
satisfied, and we would be able to compile and run the program. But we would get a
very different result, because we would first try to display the value of variable <span class="var">a</span>,
and later assign a value to it.</p>
</div>
<div class="paragraph">
<p>When we have to declare multiple constants or variables, then we can use a block,
that is we write the keyword <span class="key">var</span> or <span class="key">const</span> on its own line, followed by the actual
declarations like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const
  Pi = 3.1415
  Year = 2020
var
  sum: int
  age: int</code></pre>
</div>
</div>
<div class="paragraph">
<p>These blocks are also called sections, e.g. const section or var section, as known from the wirthian languages.
Note the indentation&#8201;&#8212;&#8201;the lines after <span class="key">const</span> and <span class="key">var</span> start with some space
characters, so they build a block which allows the compiler to detect where the
declaration ends. Typically, we use two spaces for each level of indentation. Other
numbers would work also, but the indentation scheme should be consistent. Two spaces
is the general recommendation, as it is clearly recognizable for humans in the source
code, and because it doesn&#8217;t waste too much space, that is, it would not generate
long lines which may not fit onto the screen.</p>
</div>
<div class="paragraph">
<p>Also note that in Nim we generally write each statement onto its own line. The line
break indicates to the compiler that the statement has ended. There are a few
exceptions&#8201;&#8212;&#8201;long mathematical expressions can continue on the next line (see the
Nim manual for details). We can also put multiple statements on a single line when we
separate them by a semicolon:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a: int
echo a; inc(a) <i class="conum" data-value="1"></i><b>(1)</b>
a = 2 * a + <i class="conum" data-value="2"></i><b>(2)</b>
  a * a</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>two statements separated by a semicolon on a single line</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>a longer math expression split over multiple lines. An operator as the last character on a line indicates
that the expression continues on the next, indented line.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We can also declare multiple variables of the same type in one single declaration,
like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  sum, age: int</code></pre>
</div>
</div>
<div class="paragraph">
<p>or we can assign an initial start value to a variable like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  year: int = 1900</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, for variable declarations we can use type inference when we assign an
initial start value, that is we can write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  year = 1900</code></pre>
</div>
</div>
<div class="paragraph">
<p>The compiler recognizes in this case that we assign an integer literal to that
variable, and so silently gives the variable the <span class="type">int</span> type for us. Type inference can
be comfortable, but may make it harder for readers to understand the code, or the
type inference may not always do exactly what we want. For example, in the above code,
year gets the type int, which is a signed 4 or 8 byte number. But maybe we would
prefer an unsigned number, or a number which occupies only two bytes in memory. So
use type inference with some caution.</p>
</div>
<div class="paragraph">
<p>Note: For integral data, we mostly use the int data type in Nim, which is a signed
type with 4 or 8-byte size. It usually does not make sense to use many different
integral types&#8201;&#8212;&#8201;signed, unsigned, and types of different byte size. Mixing them in
numerical expressions can be confusing and potentially even decrease performance, because
the computer may have to do type conversion before it can do the math operation. For
unsigned types, another problem is that math operations on unsigned operands could
have a negative result. Consider the following example, where we use a hypothetical
data type "unsigned int" to indicate unsigned integers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a, b: unsigned int
a = 3
b = 7
a = a - b</code></pre>
</div>
</div>
<div class="paragraph">
<p>The true result would be <span class="lit">-4</span>, but <span class="var">a</span> is of unsigned type and can never contain a
negative content. So what should happen&#8201;&#8212;&#8201;an incorrect result or a program
termination?</p>
</div>
<div class="paragraph">
<p>Related to variable declarations is the initial start value of variables. Nim clears
for us all the bits of our variables when we declare them, that is, numbers
always get the initial start value zero if we do not assign a different value in the
variable declaration.</p>
</div>
<div class="paragraph">
<p>In this declaration</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  a: int = 0
  b: int</code></pre>
</div>
</div>
<div class="paragraph">
<p>both variables get the initial value zero.</p>
</div>
<div class="paragraph">
<p>There exists a variant for variable declarations which uses the <span class="key">let</span> keyword
instead of the <span class="key">var</span> keyword. Let is used when we need a variable which only once gets
a value assigned, while var is used when we want to change the content of the
variable during program execution. Let seems to be similar to <span class="key">const</span>, but in <span class="key">const</span>
declarations we can use only values that are known at compile time. Let allows us to
assign to variables values that are only available at program run time, maybe because
the value is a result of a prior calculation. But let indicates, at the same time, that
the assignment occurs only once, the content does not change later, during the program&#8217;s execution. We say that the
variable is immutable. Use of the <span class="key">let</span> keyword may help the human reader of the
source code with understanding what is going on, and it may also help the compiler doing
optimizations to get faster, or more compact code. For now, we can just ignore <span class="key">let</span>
declarations and use <span class="key">var</span> instead&#8201;&#8212;&#8201;later, we may use <span class="key">let</span> where appropriate, and the
compiler will tell us when <span class="key">let</span> will not work, and we have to use <span class="key">var</span>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The way how we declare constants, variables, types and procedures in Nim is very
similar as it was done in the wirthian languages Pascal, Modula and Oberon. People
coming from languages like C sometimes argue that C uses a shorter and better
variable declaration of the form <span class="code">int velocity;</span> instead of Nim&#8217;s <span class="code">var
velocity: int</span>. Indeed, that declaration is shorter in this case. And some people
like it better that the data type is written first, they consider the data type more
important than the name of the variable. That is a matter of taste, and the C
notation would not work well for var/let/const distinction and for type declarations.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>With what we have learned in this section, we can rewrite our initial Nim example from
part I in this form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const
  Max = 100
var
  sum, i: int
while i &lt; Max:
  inc(i)
  inc(sum, i)
echo sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code above, we declare both variables of type <span class="type">int</span> in a single line and take
advantage of the fact that the compiler will initialize them with <span class="lit">0</span> for us. And we
use a named constant for the upper loop boundary. Another tiny fix is that we write
<span class="code">inc(i)</span> instead of <span class="code">inc(i, 1)</span>. We can do that because there exists
multiple procedures with the name <span class="func">inc()</span>&#8201;&#8212;&#8201;one which takes two arguments,
and one which takes only one argument and always increases that argument by one.
Procedures with the same name, but different parameter lists, are called overloaded procedures.
Instead of <span class="code">inc(i)</span> we could have written also <span class="code">i = i &#43; 1</span> and instead
of <span class="code">inc(sum, i)</span> we could write <span class="code">sum = sum &#43; i</span>. That would generate
identical code in the executable, so we can use whatever we like better.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_input_and_output">Input and Output</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have already used the <span class="func">echo()</span> procedure for displaying textual output in the terminal
window. In the code examples of the previous sections we always passed arguments of integer
type to the <span class="func">echo</span> <span class="proc">proc</span>, and the <span class="func">echo</span> <span class="proc">proc</span> automatically converted the integer numbers
to a textual sequence of decimal digits, so that we could read it in the terminal. In the Nim programming language, text is a predefined, built in
data type that is called <span class="ndef">string</span>. We will learn all the details of the string data type in the next section,
for now it is sufficient that it exists and that we can use the <span class="func">echo()</span> <span class="proc">proc</span> to print text strings.
The <span class="func">echo()</span> <span class="proc">proc</span> has the ability to convert other data types like numbers or the boolean data type (true/false)
automatically to human-readable text strings,
so that we can read the output in the terminal. Recall that most data types are stored internally in our computer
as bits and bytes, which have no true human-readable representation by default. Numbers, as most other data
types stored in the computer, are actual abstract entities. We have learned already that all data in the computer
is internally stored in binary form, that is, as a bit pattern of <span class="lit">0</span> and <span class="lit">1</span>. But even that bit pattern is still an abstraction, we would
require a procedure that prints a <span class="lit">0</span> for each unset bit and a <span class="lit">1</span> for each set bit to display the content of an internally stored
number in binary form in the terminal or elsewhere. In the same way, we require a procedure to print an internally stored number
as a human-readable sequence of decimal digits.
Even text strings are internally stored as abstract bit patterns, and we need
conversion <span class="proc">procs</span> to print the content for us as ordinary text. All that can be done by the <span class="func">echo</span> <span class="proc">proc</span>,
but we do not care for the actual details at this point of the book.</p>
</div>
<div class="paragraph">
<p>For our further experiments, we may also want to be able to enter some user data
in the terminal. As we do not know much about the various available data types and the
<span class="proc">procs</span> that can be used to read them in, we will just present a procedure that can read in
a text string that the user has typed in the terminal window.
We use a function with the name
<span class="func">readLine()</span> for this task.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo "Please enter some text"
var mytext = readLine(stdin)
echo "you entered: ", mytext</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you have to press the <span class="term">return</span> key after you have entered your text.</p>
</div>
<div class="paragraph">
<p>The first line of our program show how we can print a text literal string
with the <span class="func">echo()</span> <span class="proc">proc</span>. To mark text literals unambiguously and to separate them
from other literals like numeric literals or from variables, the string literals have to
be enclosed in quotation marks.
In
the second line of our example program, we use the <span class="func">readLine()</span> function to read textual user input.
Note that we call <span class="func">readLine()</span> a function, not a procedure, to emphasize that it returns a value.
The <span class="func">readLine()</span> function needs one parameter to know from where it should read&#8201;&#8212;&#8201;from the terminal window or from a file, for example. The <span class="var">stdin</span> parameter
indicates that it should read from the current terminal window&#8201;&#8212;&#8201;<span class="var">stdin</span> is a global
variable of the <span class="mod">system</span> (<span class="mod">io</span>) module and indicates the standard input stream. Finally,
in line 3 we use again the <span class="func">echo()</span> procedure to print some text. In this case
we pass two arguments to <span class="func">echo()</span>, a literal text enclosed in quotes, and then
separated by a comma, the <span class="var">mytext</span> variable. The <span class="var">mytext</span> variable has
the data type <span class="type">string</span>. We used type inference in this example to declare that data
type: the <span class="func">readLine()</span> procedure always returns a <span class="type">string</span>, the
compiler knows that, so our <span class="var">mytext</span> variable is automatically declared with
type <span class="type">string</span>. We will learn more about the data type <span class="type">string</span> and other
useful predefined data types in the next section.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Nim supports the <span class="ndef">method call syntax</span>, which was earlier called
<span class="ndef">Uniform Function Call Syntax</span> in the D programming language. With that syntax, we can
write procedure calls in the form <span class="code">a.f</span> instead of <span class="code">f(a)</span>. We will discuss that syntax in
more detail when we explain procedures and functions. For now, it is enough that you know about the
existence of that syntax, as we may use it at some places in the following sections.
For example, for the length of text strings, we generally write <span class="code">myTextString.len</span>
instead of <span class="code">len(myTextString)</span>. Both notations are fully equivalent.<sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup></p>
</div>
</div>
</div>
<div class="paragraph">
<p>When you try the example code from above, you may want a variant of it that does read
in the textual input not on its own line, but directly after the prompt like "What is your name: Nimrod".
As the <span class="func">echo</span> <span class="proc">proc</span> always writes a newline character after the last argument has been written, we have
to use a different function to get the input prompt on the same line. We can use the <span class="func">write()</span> <span class="proc">proc</span>
from the <span class="mod">system</span> module for this. As <span class="func">write()</span> can not only write to the terminal, but also to files,
it needs an additional parameter which specifies the destination. We can pass the variable <span class="var">stdout</span>
from the <span class="mod">system</span> module to indicate that write() should write to our terminal window. Another desire of beginners is, generally,
to have the ability to read single character input without the need to press additional the return key.
For that, we can use the getch() function from the <span class="mod">terminal</span> module&#8201;&#8212;&#8201;that functions waits (blocks) until
a key is pressed and returns the ASCII character of the pressed key:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from terminal import getch

stdout.write("May you tell me your name: ")
var answer = readLine(stdin)
if answer != "no":
  echo "Nice to meet you, ", answer
echo "Press any key to continue"
let c = getch()
echo "OK, let us continue, you pressed key:", c</code></pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t get confused by the fact that the first <span class="func">write()</span> call and the following <span class="func">readline()</span>
call does not appear on the same line in our example. The actual format of our source code
does in this case not influence the program output. We could write both function calls
on a single line, separated with a semicolon. But that would make no difference for the program
output. The significant difference of the code above is just, that write() prints the text, but does not move the
cursor in the terminal window to the next line, while echo() moves the cursor to the next line when all
arguments have been printed. We say that echo prints automatically a "\n" character, which we call newline
character, after all the arguments have been printed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_types">Data types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The most fundamental data type&#8201;&#8212;&#8201;in real life and in computer science&#8201;&#8212;&#8201;are integer (whole) numbers.
All other numeric data types, like fractional, floating point or complex numbers,
and other fundamental types like the boolean type with its two values <span class="lit">true</span> and <span class="lit">false</span>, or character and
text string types, can be represented as integers. For that reason, the early computers built in the 1950s
as well as today&#8217;s tiniest microcontrollers work internally only with integer numbers. As all CPUs are
able to do basic bit operations like setting or clearing individual bits, and as bit patterns
map well to mathematical sets, set data types are well-supported by all CPUs, and so
<span class="type">set</span> operations are generally very efficient.
Advanced computers
built in the 1980s got support for the important class of floating point numbers by special
floating point processors for fast numerical computations. These floating point units are
today typically integrated into the CPU, and GPUs can even process many floating point operations in parallel,
where the precision is typically restricted to ranges needed for games and graphics animation, that is 32 or even 16 bit.
Modern CPUs have often also some form of support for vector data types to process multiple
values in one instruction (SIMD, single instruction, multiple data).</p>
</div>
<div class="paragraph">
<p>None numeric types like characters or text strings are internally represented by integer numbers&#8201;&#8212;&#8201;in the C language the data type to present text strings is called char, but it is indeed only an 8-bit
integer type which supports all the mathematical operations defined for ordinary int types. In Nim and
the wirthian languages, most math operations are not directly allowed for the <span class="type">char</span> data type,
which should prevent misuse and allows catching logical errors by the compiler.</p>
</div>
<div class="paragraph">
<p>Nim supports also
some built in homogeneous container types like arrays and sequences, and many built in derived types
like enums, sub-ranges and slices, distinct types and view types (experimental).
The built-in inhomogeneous container types object and tuple, which allow
to group other types, are supported by a variant type container, which allows
instances of that type to contain different child types at runtime. These inhomogeneous container types
are similar to the struct and union types from the C programming language.</p>
</div>
<div class="paragraph">
<p>Other basic and advanced data types like complex and fractional numbers, types with arbitrary-precision arithmetic as well as
hash sets and hash tables, dynamically linked list or tree structures are available through the Nim standard library
or external packages. And of course we are able to define our own custom data types with our own operators, functions and
procedures working on them.</p>
</div>
<div class="paragraph">
<p>Note that all the data types that are build into the language, like the primitive types int, float or char, as well
as the built-in container types like tuple, object, seq and string, are written in lower case, while
data types that are defined by the Nim standard library or that we define our self, by convention starts
with a capital letter like the CountTables type defined in the <span class="mod">tables</span> module. Some people may regard this as an inconsistency,
some may say that in this way we can differentiate built in types from types defined by libraries. At least we may agree
that using capital notation for common types as in Int, Float or String would be more difficult to type and
would look not that nice.</p>
</div>
<div class="sect2">
<h3 id="_integer_types">Integer types</h3>
<div class="paragraph">
<p>We have already used the <span class="type">int</span> data type, which indicates a signed integer
type of <span class="lit">4</span> or <span class="lit">8</span> byte size, depending on the operating system. The reason why the size of that type depends on the
word size of the OS will become clear later, when we explain what references and
pointers are.</p>
</div>
<div class="paragraph">
<p>Beside the <span class="type">int</span> data type, Nim has some more data types for signed and unsigned
integers: <span class="type">int8</span>, <span class="type">int16</span>, <span class="type">int32</span> and <span class="type">int64</span> are signed
types with well-defined bit and byte size, and <span class="type">uint8</span>, <span class="type">uint16</span>,
<span class="type">uint32</span> and <span class="type">uint64</span> are the unsigned equivalents. The number at the
end of the type name is the bit size; we get the byte size when we divide that value
by <span class="lit">8</span>. Additionally, we have the type <span class="type">uint</span>, which corresponds to <span class="type">int</span>
and has the same size, but stores unsigned numbers only. <sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>
Generally, we should try to use the <span class="type">int</span> type for all integral numbers, but sometimes it
can make sense to use the other types. For example, when you have to work with a
large collection of numbers, you know that each number is not very big, and your RAM
is not really that large, then you may decide for example to use <span class="type">int16</span> for
all your numbers. Or when you know that your numbers will be huge and will not
fit in a 4 byte integer, then you may use the <span class="type">int64</span> type to ensure that the
numbers fit in that type even when your program is compiled and executed on a
computer with a 32-bit OS.</p>
</div>
<div class="paragraph">
<p>For integer numbers we have the predefined operators <span class="op">&#43;</span>, <span class="op">-</span> and <span class="op">*</span>
available for addition, subtraction and multiplication. Basically, these operations
works as we may expect, but we have to remember that we may get overflows. For signed
ints we get compile- or run-time errors in that case, while unsigned ints just wrap
around, see example at the end of this section. For division of integers we have the
operators <span class="op">div</span>, <span class="op">mod</span>, and <span class="op">/</span> available. The <span class="op">div</span> operator
does an integer division ignoring the remainder, <span class="op">mod</span> is short for modulus and
gives us the remainder of the division, and <span class="op">/</span> finally is currently only
predefined for the signed int type and gives us a fractional result of data type
<span class="type">float</span>.  That type is introduced in the next section.</p>
</div>
<div class="paragraph">
<p>Remembering how <span class="op">div</span> and <span class="op">mod</span> behaves when the divisor or dividend are
negative can be confusing, and it may differ for other programming languages. You may
find a detailed justified explanation for the concrete behavior in the Nim manual and at Wikipedia.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Result of i div j
   -4 -3 -2 -1  0  1  2  3  4
-4  1  1  2  4    -4 -2 -1 -1
-3  0  1  1  3    -3 -1 -1  0
-2  0  0  1  2    -2 -1  0  0
-1  0  0  0  1    -1  0  0  0
 0  0  0  0  0     0  0  0  0
 1  0  0  0 -1     1  0  0  0
 2  0  0 -1 -2     2  1  0  0
 3  0 -1 -1 -3     3  1  1  0
 4 -1 -1 -2 -4     4  2  1  1

Result of i mod j
   -4 -3 -2 -1  0  1  2  3  4
-4  0 -1  0  0     0  0 -1  0
-3 -3  0 -1  0     0 -1  0 -3
-2 -2 -2  0  0     0  0 -2 -2
-1 -1 -1 -1  0     0 -1 -1 -1
 0  0  0  0  0     0  0  0  0
 1  1  1  1  0     0  1  1  1
 2  2  2  0  0     0  0  2  2
 3  3  0  1  0     0  1  0  3
 4  0  1  0  0     0  0  1  0</pre>
</div>
</div>
<div class="paragraph">
<p>When performance matters we generally should try to use the "CPU native" number type,
what for Nim is the <span class="type">int</span> type. And we should try to avoid using math expressions with
different types, as the CPU may have to do type conversion in that case before the
math operation can be applied. Adding two <span class="type">int8</span> types can on some CPUs be slower than
adding two <span class="type">ints</span>, because the CPU may have to size extend the operands before the math
operation is performed. But this depends on the actual CPU, and there are important
exceptions: Multiplying two ints would result in an int128 result if int size is 64
bit, which can be slow when the CPU does not support that operation well. Another
essential point to consider for maximum performance is the cache usage. If you are
performing operations on a large set of data, then you may get a significant
performance gain when large fractions of your data fits in the caches of your
computer, as cache access is much faster than ordinary RAM access. So using smaller
data types, i.e. <span class="type">int32</span> instead Nim&#8217;s default <span class="int">int</span> which is int64 on a 64-bit OS, may
increase performance in this special application.</p>
</div>
<div class="paragraph">
<p>When we use Nim on tiny microcontrollers, maybe even on 8-bit controllers like the popular AVR
devices, it may be best to use only integers of well-defined size like <span class="type">int8</span>.</p>
</div>
<div class="paragraph">
<p>When we write integer literal numbers, then we use generally our common decimal
notation, as in <span class="code">var i = 100</span>.
To increase the readability for long number literals we can use the underscore character
as in <span class="lit">1_000</span>, that underscore character is just ignored by the compiler.
We can also write integer literals in binary, octal or
hexadecimal notation. For that we prefix the literal value with <span class="lit">0b</span>, <span class="lit">0o</span> or <span class="lit">0x</span>. The leading
zero is necessary, and the next letter indicates binary, octal or hexadecimal encoding.
But such integer literal notation is very rarely used.</p>
</div>
<div class="paragraph">
<p>More important is the actual size of integer literals, in particular when we use type inference.
Ordinary integer literals have the <span class="type">int</span> type, but integer literals not fitting
in 32 bit have <span class="type">int64</span> type. We can also specify the type of integer literals by appending
the literal with <span class="lit">i8</span>, <span class="lit">i16</span>, <span class="lit">i32</span> or <span class="lit">i64</span> for signed types and with <span class="lit">u</span>, <span class="lit">u8</span>, <span class="lit">u16</span>, <span class="lit">u32</span> or <span class="lit">u64</span> for
unsigned types. We can separate the actual number and the suffix with a <span class="lit">'</span> character,
but that is not necessary for the integer literals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  a = 100 # int literal in decimal notation
  b = 1234567890000 # int64
  c = 5'i8 # 8 bit integer
  d = 7u16 # unsigned integer with 2 byte size
  e = 0b1111 # ordinary integer in binary notation, value is 15 in decimal notation
  f = 0o77 # integer in octal notation, value is 7 * 8^0 + 7 * 8^1 in decimal notation
  g = 0xFF # integer in hexadecimal notation

echo g, typeof(g)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In arithmetic expressions, integer types of different sizes are generally compatible
when all the types are signed or unsigned, e.g.
in the example code from above we could write <span class="code">echo a &#43; b &#43; c</span>, and
typeof(a &#43; b &#43; c) is int64, that is the expression is propagated to
the largest type of all the involved operands. But <span class="code">echo a &#43; b &#43; c &#43; d</span>
would not compile, as for such a mix of signed and unsigned operands it is
not clear if signed or unsigned arithmetic should be used.
Also note that
even on a 64-bit OS, <span class="code">echo typeof(a) is typeof(b)</span> would print <span class="lit">false</span>.</p>
</div>
<div class="paragraph">
<p>An important property of the current Nim implementation of A. Rumpf, used with the C
backend, is the fact that unsigned integers does not generate overflow errors but
simple wrap around:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var x: int8 = 0

while true:
  inc(x)
  echo x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code would print the numbers <span class="lit">0</span> up to <span class="lit">127</span> and then terminate program execution
due to an overflow error. But when we change the data type to <span class="type">uint8</span>, we would get a
continues sequence of the numbers <span class="lit">0</span> up to <span class="lit">255</span>. After the value <span class="lit">255</span> is reached, the
value wraps around to <span class="lit">0</span> again and the process continues. This behavior can lead to
strange bugs and is the reason that the Nim team generally recommends avoiding
unsigned integers.</p>
</div>
<div class="paragraph">
<p>For compatibility with external libraries, Nim has also the integer types <span class="type">cint</span> and
<span class="type">cuint</span>, which exactly match the C types <span class="type">int</span> and <span class="type">uint</span> when we compile for the C or
C++ backend. For the JavaScript backend, the LLVM backend or other backends these
types may be also available, for details you should consult the compiler
documentation. For most operating system and C compilers the <span class="type">int</span> and <span class="type">uint</span> types in C are 4 bytes
in size, but there can be exceptions, so we better should not write code that depends
on the actual byte size of the types. The Nim types <span class="type">cint</span> and <span class="type">cuint</span> are mainly only
used for parameter lists of &#169; library functions. To match other integer types like
C <span class="type">char</span>, <span class="type">short</span>, <span class="type">long</span>, <span class="type">longlong</span> Nim supports these types when we put a c letter in
front of the name like clong. Again, you should consult the Nim compiler manual when
you need more details, i.e. when you create bindings to external libraries.</p>
</div>
</div>
<div class="sect2">
<h3 id="_floating_point_types">Floating point types</h3>
<div class="paragraph">
<p>Another important numeric data type is <span class="type">float</span>, for floating point numbers. Floats are
an approximation of real numbers. They can also store fractions, and are most often
printed in the decimal system with a decimal point, or in scientific notation with an
exponent. Examples for the use of variables of <span class="type">float</span> data type are</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  mean = 3.0 / 7.9
  x: float = 12
  y = 1.2E3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable <span class="var">mean</span> is assigned the result of the division of two
<span class="type">float</span> literals&#8201;&#8212;&#8201;the result has again the data type <span class="type">float</span>,
and so the compiler can infer for the type of variable <span class="var">mean</span> that same type.
If we printed the result of the division, there
would be a decimal point and some digits following it. For variable <span class="var">x</span> we specify the
<span class="type">float</span> type explicitly and assign the value <span class="lit">12</span>. We could use type inference if we
assigned <span class="lit">12.0</span>, because the compiler can recognize by the decimal point that we want a
<span class="type">float</span>, not an <span class="type">int</span> variable. In line 3 we use scientific notation for the float literal that we
assign to <span class="var">y</span>, and the assigned value is <span class="term">1.2 * 10^3 = 1200.0</span>. Literal values, like
<span class="lit">2E3</span>, are also valid <span class="type">float</span> literals&#8201;&#8212;&#8201;the value would be <span class="lit">2000.0</span>. But
literals with a decimal point and no digits before or after the point&#8201;&#8212;&#8201;<span class="lit">1.</span> or <span class="lit">.2</span>&#8201;&#8212;&#8201;are not valid in Nim.</p>
</div>
<div class="paragraph">
<p>In the current Nim implementation, <span class="type">float</span> variables always occupy 64 bits. Nim has also the
data type <span class="type">float64</span> which is currently identical to plain <span class="type">float</span>, and <span class="type">float32</span> which can
store only smaller numbers and has less precision.<sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup> Floats can store values up to a magnitude of approximately
<span class="lit">1E308</span> with a positive or negative sign, and floats have a typical precision
of 16 digits. That is, when you do a division of two arbitrary floats and print the
result, you will get up to 16 valid digits.
If you tried to print more than 16 significant digits, then the additional decimal places
would be just some form of random garbage.
Note: The number of significant digits of a floating point number is the
total number of digits before and after the decimal point, but possible leading zero
digits would not be counted. The reason that leading zeros are not significant is
just that in the ordinary notation of numbers, we always assume that there is just nothing
before the first non-zero digit. For our car odometer
<span class="term">001234.5 km</span> is identical to <span class="term">1234.5 km</span>. And if we give our body size as
<span class="lit">1.80 m</span> or <span class="lit">180 cm</span> makes no difference, both values have 3 significant digits.</p>
</div>
<div class="paragraph">
<p>Generally, we use floats whenever integers are not sufficient for some reason. For
example, when we have to do complicated mathematical operations which include
fractional operands like <span class="var">Pi</span>, or when we have to do divisions and need the exact
fractional value.</p>
</div>
<div class="paragraph">
<p>The <span class="type">float</span>, <span class="type">float32</span> and <span class="type">float64</span> data types provides the <span class="op">&#43;</span>, <span class="op">-</span>, <span class="op">*</span>
and <span class="op">/</span> operators for addition, subtraction, multiplication and division. Unlike
for the <span class="type">int</span> types, for the <span class="type">float</span> types we never get overflow or underflow errors, and
also no error for a division by zero. But the result of an operation of two <span class="type">float</span>
operands can be a special value like system.Inf, system.NegInf or system.NaN. The
first two indicate an over- or underflow, and NaN (Not a Number) indicates that the result of an
operation is not a valid number at all, for example the result of a division by zero
or the result of calculating the square root of a negative number. This behavior is
sometimes called saturated arithmetic. When a variable has one of these special
values, and we apply further math operations, then this value is kept. So we can
detect at the end of a longer mathematical calculation if something went wrong&#8201;&#8212;&#8201;we
have not to check after each single operation.<sup class="footnote">[<a id="_footnoteref_17" class="footnote" href="#_footnotedef_17" title="View footnote.">17</a>]</sup>
An interesting property of floating point numbers is, that
when we test two variables of <span class="type">float</span> type for equality, and one has the value <span class="lit">NaN</span>, then the test is always false.
That is, the test <span class="code">a == NaN</span> is always false.
When we forget this fact, we may initialize a <span class="type">float</span> variable to the value
<span class="lit">NaN</span> and later test with <span class="code">if a == NaN:</span> to check if we have already assigned a value,
which is not what we really had in mind, as that test has always a negative result.
The actual test for the value <span class="lit">NaN</span> is <span class="code">a == a</span>, which is only false when <span class="var">a</span> has the value <span class="lit">NaN</span>,
or we may use math.isNaN().
More useful constants and functions for the <span class="type">float</span> data types can be found in the
<span class="mod">std/fenv</span> module, and functions working with floats like the trigonometric ones
are available from the <span class="mod">std/math</span> module.</p>
</div>
<div class="paragraph">
<p>For floats, we have the operators <span class="op">&#43;</span>, <span class="op">-</span>, <span class="op">*</span> and <span class="op">/</span>
for addition, subtraction, multiplication and division. For powers with integral
exponents, you can use the <span class="op">^</span> operator, but you have to import it from the
<span class="mod">std/math</span> module. The expression <span class="code">x ^ 3</span> is the same as <span class="code">x * x
* x</span>. The <span class="mod">math</span> module contains many more functions like <span class="func">sin()</span> or
<span class="func">cos()</span>, <span class="func">sqrt()</span> and <span class="func">pow()</span>. The function name <span class="func">sqrt()</span> is short for
square-root, and <span class="func">pow()</span> stands for power, so <span class="func">pow(x, y)</span> is <span class="var">x</span> to the power of <span class="var">y</span>,
when both operands have type float. For performance critical code you should always
keep in mind that <span class="func">pow()</span> is an actual function call, maybe a call of a dynamic library which can not be inlined,
so a call of <span class="func">pow(x, 2)</span> may be a lot
slower than a plain <span class="code">x * x</span>. And even when using the <span class="op">^</span> operator as in <span class="code">x ^ 3</span>
we should be a bit critical. But of course we always hope that the compiler will
optimize all that for us.</p>
</div>
<div class="paragraph">
<p>The operators <span class="op">&#43;</span>, <span class="op">-</span>, <span class="op">*</span> and <span class="op">/</span> can be used also when
one operand is a <span class="type">float</span> variable and the other operand is an <span class="type">int</span> literal.
In that case, the compiler knows that we really intend to do a float operation and
converts the int literal automatically to float type.
But when one
operand is a <span class="type">float</span> variable and the other is an <span class="type">int</span> variable, then an explicit type conversion
is necessary, like in <span class="code">float(myIntVal) * myFloatVal</span>.
One explanation why in this case the int value is not automatically converted to float is,
that this may mean a loss in precision, as large int64 values can not be presented as a float.
Well, for int32 this reason does not really apply, but still there is no automatic conversion.
But indeed as Nim is used as a systems programming language, it seems to be a good
decision to need explicit conversions in this case, as it makes it more clear what really is intended.
And generally we should try to avoid using a lot of operations with mixed types, as
that may make type conversions necessary, which may cost performance.
If we really do not care, we may import the module
<span class="mod">std/lenientOps</span>, which defines the arithmetic operations for mixed operands.</p>
</div>
<div class="paragraph">
<p>Float literals have the float data type by default, but as for integer literals we can also
explicitly specify the data type: The suffixes <span class="lit">f</span> and <span class="lit">f32</span> specify a 32-bit float type, and
<span class="lit">d</span> and <span class="lit">f64</span> specify a 64-bit type. We can separate the suffix from the actual number
with a <span class="lit">'</span> character, but that is not required as long as there is no ambiguity. We can also
specify float literals in binary, octal or hexadecimal notation, when we append one of these
suffixes. In case of hexadecimal notation, the <span class="lit">'</span> is obviously needed to separate the suffix, as
<span class="lit">f</span> and <span class="lit">d</span> are valid hex digits.</p>
</div>
<div class="paragraph">
<p>As for integer variables, Nim supports also the compatible types <span class="type">cfloat</span> and <span class="type">cdouble</span>
which match the C types float and double when the C backend is enabled. For most C
compilers, C float matches Nim&#8217;s float32 and C double matches Nim&#8217;s float64.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Some CPUs and C compilers support also other floating point types beside the common
float32 and float64 types. Intel x86 compatible CPUs generally support float80 math
operations, and the GCC C compiler may support float128. But these types are not yet
supported by the Nim compiler of A. Rumpf. But there may exist external packages
which supports these types by calling C functions, when the C backend is used.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Two important properties of floats are that not all numbers can be represented
exactly, and that math operations are not absolutely accurate.
Recall that in our decimal system, some fractions like <span class="lit">1/2</span> can be represented exactly
as <span class="lit">0.5</span> in decimal notation, while others like <span class="lit">1/3</span> can be only approximated as <span class="lit">0.3333&#8230;&#8203;</span>
As all data, floats are stored internally in binary form following the
<span class="ndef">IEEE Standard for Floating-Point Arithmetic (IEEE 754)</span>.
In that format some values, e.g. the value <span class="lit">0.1</span>, can not be represented exactly.
As a result, some simple arithmetic operations, executed in the computer, will
give us not exactly that result that we may expect. As we should really remember this
important fact, we will investigate this behavior with a small example program where we
divide a few small integer numbers after conversion to float by another to float converted integer n
and sum the result n times:<sup class="footnote">[<a id="_footnoteref_18" class="footnote" href="#_footnotedef_18" title="View footnote.">18</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">for i in 1 .. 10:
  echo "--"
  for j in 2 .. 9:
    let a = i.float / j.float
    var sum: float
    for k in 1 .. j:
      sum += a
    echo sum</code></pre>
</div>
</div>
<div class="paragraph">
<p>which generates this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>--
1.0
1.0
1.0
1.0
0.9999999999999999
0.9999999999999998
1.0
1.0
--
2.0 # for all iterations!
--
3.0 # for all iterations!
--
4.0
4.0
4.0
4.0
4.0
3.999999999999999
4.0
4.000000000000001
--
5.0
5.0
5.0
5.0
5.0
5.0
5.0
4.999999999999999
--
6.0
6.0
6.0
6.0
6.0
5.999999999999999
6.0
6.0
--
7.0
7.0
7.0
7.0
7.000000000000001
7.0
7.0
7.0
--
8.0
8.0
8.0
8.0
7.999999999999999
7.999999999999998
8.0
8.000000000000002
--
9.0 # for all iterations!
--
10.0
10.0
10.0
10.0
10.0
10.0
10.0
9.999999999999998</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">echo()</span> procedure prints up to 16 significant digits for a <span class="type">float</span> value, and so the
accumulated tiny arithmetic errors become visible. After our remarks above that
should be not surprising anymore, the general solution is to round results to
less than 16 decimal digits before printing. Various ways to do that will be shown
later in the book. A related issue of float arithmetic is caused by scaling and extinction.
When we add numbers with very different magnitudes, the result may be just
the value of the largest number, as in <span class="code">echo 1.0 == 1.0 &#43; 1e-16</span>, which prints <span class="lit">true</span>.
The tiny summand is just too small to actually change the result, that is as when you
switch on a torch on a sunny day, it will not really become brighter.
Maybe more surprising is, that calling <span class="func">echo()</span> with some simple <span class="type">float</span> literals
will print a different value, like <span class="code">echo 66.04</span> which gives <span class="lit">66.04000000000001</span>
for Nim v1.6, while with Python3 we get <span class="lit">66.04</span> exactly. But indeed that is only
surprising for people who do not understand well what a statement like
<span class="code">echo 66.04</span> really does: We know already, that the value <span class="lit">66.04</span> is converted
by the compiler to an internally binary representation, and then converted
back to a decimal string when we run the program. So it is not that surprising that
in this process some tiny inaccuracies can accumulate. Actually, it is possible to
get exact 16 digits precision when a very smart conversion routine like the
<span class="ndef">ryu</span> or <span class="ndef">dragonbox</span> algorithm is used.</p>
</div>
<div class="paragraph">
<p>From the discussions above, it should be clear that testing two floats for
equality is regularly problematic. Instead of just testing for equality, we may better
define a small epsilon value like <span class="code">eps = 1e-14</span> and then write <span class="code">(a - b).abs &lt; eps</span>.
Seems to be not bad, and can be seen frequently and often works, but not always.
Imagine you write a program which processes chemical elements, and you work
with atomic mass and radii. So maybe the result with the above test is that all the
atoms of the periodic table have equal mass and equal size, at least when
you should use the SI system with meter and kilogram as base units. So an equality test like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const eps = 1e-16 # an arbitrary relative precision
if (a == 0 and b == 0) or (a - b).abs / (a.abs + b.abs) &lt; eps: # avoid div by zero

if (a - b).abs / (a.abs + b.abs + 1e-32) &lt; eps: # a similar check, avoiding also a div by zero</code></pre>
</div>
</div>
<div class="paragraph">
<p>may be a better solution in the general case.
Whenever you need a general equality test, you should think about the problem
and do some tests&#8201;&#8212;&#8201;the code above are just untested possible examples.</p>
</div>
<div class="paragraph">
<p>At the end of this section some remarks about the performance of float data types
compared to plain ints: On modern hardware like the popular x86 systems
for the basic operations
performance of floats and ints is very similar, addition, subtraction and even multiplication is basically done in
only one clock cycle, and division may be a bit slower. Even operations like sqrt() which have
been regarded as slow in the past are now close to a plain addition on modern hardware.
As the CPU does its float arithmetic internally with 64 or even with 80 bits, float32
is not faster than float 64, as long as the operations are not memory bound, that
is large data sets are processed, so that it is an advantage when the data types are smaller so that more
of it fits into the cache. For tiny microcontrollers and embedded devices, things are very different, as these devices
typically have no floating point units. So the compiler has to emulate all the float arithmetic,
maybe by use of libraries. This is very slow and produces large executables. So when
writing software for modern desktop PCs, there is no reason to try to avoid float math, when
solving the problem with float is easier. When the data extends a very width range, e.g. from
nm to millions of km, or when operations like square root or trigonometric functions are needed,
then there is typically no way and reason to avoid float.
In the case that float or ints may work both, it is generally a good strategy to try to use
ints as first try. Ints may still provide better performance for SIMD, threading and parallel processing,
as ints may avoid the expensive saving of floating point CPU registers. For restricted hardware, we should better
try to avoid float math. But all this is a difficult topic, and these advices can give you only some
simple recommendations, which may be wrong for a concrete case. So finally you have to decide yourself,
and as always it is a good idea to do some performance tests.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic" class="bare">https://en.wikipedia.org/wiki/Floating-point_arithmetic</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/2100490/floating-point-inaccuracy-examples" class="bare">https://stackoverflow.com/questions/2100490/floating-point-inaccuracy-examples</a></p>
</li>
<li>
<p><a href="https://forum.nim-lang.org/t/5983" class="bare">https://forum.nim-lang.org/t/5983</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_distinct_types">Distinct types</h3>
<div class="paragraph">
<p>Before we continue with subrange types, we should introduce the distinct types. In the
real world, we have a lot of quantities for which the set of meaningful math
operations is restricted and which should not be mixed with quantities of other
types. For example, we may have the quantities time and distance measured in seconds
and meters and mapped to the float or int data type. While adding seconds and adding
meters is a valid operation, adding seconds to meters makes no sense and would be a
program bug if it should occur in the program code. But again, dividing a distance by
a time period resulting in the average speed would be a valid operation. Nim provides
the distinct keyword, which allows us to define new data types that are based on
existing types, but that are not compatible with them or with other distinct types.
And the new defined distinct types have no predefined operations, we have to define
all desired operations our self.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Time = distinct float # in seconds
  Distance = distinct float # in meters

var t: time = 0.2 # not allowed
var t: Time = Time(0.2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For distinct types, we have to define all the allowed operations our self. We can
convert distinct types to the base types and then use operations of the base type, or
we can borrow operations from the base type by use of the {.borrow.} pragma. Using
distinct types can be complicated when the new type should support many operations,
but it can make our code more save. For some data type with a very limited set of
operations, distinct types can be used easily. Distinct types are explained in detail
in the Nim manual, we may explain them in more detail in later sections. For now, it
is enough that we know about their existence.</p>
</div>
</div>
<div class="sect2">
<h3 id="_subrange_types">Subrange types</h3>
<div class="paragraph">
<p>Sometimes it makes sense to limit the range of numeric variables to only a sub-range.
For this, Nim uses the <span class="key">range</span> keyword with this notation: <span class="code">range[LowVal
.. HighVal]</span>. Values of this type can never be smaller than LowVal or larger than
HighVal. For Nim v1.6 we can define range types also by leaving out the <span class="code">range[]</span>, that is,
by just two constants separated by <span class="code">..</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Year = range[2020 .. 2023] # software update required at least for 2024!
  Month = range[1 .. 12]
  Day = 1 .. 31 # same as range[1 .. 31]

var a: int = 0
var d: Day = 1 # OK
d = 0 # compile time error
d = a # run time test and error
echo d</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the above example the base type of the defined ranges is int, so the ranges are
compatible with the predefined int type, we can assign values of int type to our
range types and vice versa. In our example the size of the range types is the size of the int base type,
but of course we could use other base types, like <span class="code">type Weekday = 1.int8 .. 7.int8</span>.
If we try to assign to a range type a value that falls not into the allowed range,
then we get a compile-time or run-time range error. This can help us to prevent or to
discover errors in our programs.
Note that whenever we use range types, the compiler may have to add additional
checks to ensure that variables are always restricted to the specified range.
This check is active in debug mode and also when we compile with option <span class="term">-d:release</span>,
and is only ignored when we compile with <span class="term">-d:danger</span> or explicitly disable range checks.
So using a lot of range types may increase code size and decrease performance. For the example
above, the line with the assignment <span class="code">d = a</span> generates a runtime check. An important and often used
range type is the data type Natural, defined as <span class="code">range[0 .. int.high]</span>. That type is compatible with the int type and
does not wrap around as <span class="type">uint</span> would do. It is regularly used as type for procedure parameters when
the arguments have to be not negative. In the <span class="proc">proc</span> body we sometimes copy arguments of natural type
to an ordinary integer&#8201;&#8212;&#8201;that way we can ensure a none negative start value, and can avoid many
range checks in the procedure body.</p>
</div>
<div class="paragraph">
<p>We can also declare sub-range types with float base
types like <span class="term">type Probability = range[0.0 .. 1.0]</span>.</p>
</div>
<div class="paragraph">
<p>Note that we can still mix different sub-range type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var d: Day = 13
var m: Month = 3
d = d + m</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such an operation is generally a bug, to prevent it we can put the distinct keyword
in front of our ranges. But then again we have to define the allowed operations our
self or to borrow them from the base type.</p>
</div>
</div>
<div class="sect2">
<h3 id="_enums">Enums</h3>
<div class="paragraph">
<p>While enums in C are nothing more than integers with some special syntax for
creation, Nim&#8217;s enums are more complex.</p>
</div>
<div class="paragraph">
<p>In Nim <span class="type">enums</span> can be used whenever some form of symbols are needed like the colors
red, yellow and green of a traffic light or the directions north, south, east and
west for a map or a game.</p>
</div>
<div class="paragraph">
<p>Most of the time, we declare an enum type and the corresponding values by simple
listing them like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  TrafficLight = enum
    red, yellow, green</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use variables of type TrafficLight then like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var tl: TrafficLight
tl = green
if tl == red:
  tl = ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enums support assignment, plain tests for (in)-equality and for smaller or greater.
Additionally, the functions <span class="func">succ()</span> and <span class="func">pred()</span> are defined for <span class="type">enums</span> to get the successor
or predecessor of an enum, <span class="func">ord()</span> or <span class="func">int()</span> deliver the corresponding integer number
and the <span class="op">$</span> operator can be used to get the name of an enum. We can also iterate over
enums, so we can print all the colors of our TrafficLight by</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">for el in TrafficLight:
  echo el.ord, ' ', $el</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ordinary enums start at <span class="lit">0</span> and uses continues numbers for the internal numeric value,
so that enums can be used as array indices.<sup class="footnote">[<a id="_footnoteref_19" class="footnote" href="#_footnotedef_19" title="View footnote.">19</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  A = array[TrafficLight, string]

var a: A
a[red] = "Rot"
echo a[red]</code></pre>
</div>
</div>
<div class="paragraph">
<p>But we can also assign custom numbers like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  TrafficLigth = enum
    red = -1, yellow = 3, green = 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>We should avoid that, as these "enums with holes" generate some problems for the
compiler and may be later deprecated. For example, array indexing or iterating is
obviously not possible for enums with holes.</p>
</div>
<div class="paragraph">
<p>It is also possible to set the string that the stringify operator <span class="op">$</span> returns, like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  TrafficLigth = enum
    red = "Stop"
    yellow = (2, "Caution")
    green = ("Go")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the assigned numerical values should be 0, 2 and 3. Currently, the enums numerical values
must be specified in ascending order always.</p>
</div>
<div class="paragraph">
<p>When we have many enums in a program then name conflicts may occur, for example we
may have an additional enum type named BaseColor, which also has red and green
members. For that case, the {.pure.} pragma exists:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  BaseColor {.pure.} = enum
    red, green, blue</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the pure pragma applied, we can use the full qualified enum name when necessary,
like BaseColor.red. But we can still use unqualified names like blue when there is no
name conflict.</p>
</div>
</div>
<div class="sect2">
<h3 id="_boolean_types">Boolean types</h3>
<div class="paragraph">
<p>Boolean types are used to store the result of logic operations. The type is called
<span class="type">bool</span> in Nim and can store only two values, <span class="lit">false</span> and <span class="lit">true</span>. Although we have only two
distinct states for a boolean variable and so one single bit would suffice to store a
<span class="type">bool</span>, generally a whole byte (8 bits) is used for storing a boolean variable. Most
other programming languages, including C do the same. The reason is that most CPUs
can not access single bits in the RAM&#8201;&#8212;&#8201;the smallest entity that can be directly
accessed in RAM is a byte. The default initial state of a boolean variable is <span class="lit">false</span>,
corresponding to a byte with all bits cleared.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  age = 17
  adult: bool = age &gt; 17
  iLikeNim = true
  iLikeOtherLangaugeBetter = false.</code></pre>
</div>
</div>
<div class="paragraph">
<p>In line three, we assign to the variable adult the result of a logical comparison. The
next two lines assign the boolean constants <span class="lit">true</span> and <span class="lit">false</span> to the
variables, with their type <span class="type">bool</span> inferred.</p>
</div>
<div class="paragraph">
<p>Variables of type <span class="type">bool</span> support the operators <span class="op">not</span>, <span class="op">and</span>,
<span class="op">or</span> and <span class="op">xor</span>. <span class="op">Not</span> inverts the logic value, <span class="code">a and b</span> is only
true when both values are true, and false otherwise. And <span class="code">a or b</span> is true when
at least one of the values is true, and only false when both values are false.
<span class="op">Xor</span> is not used that often. It is called <span class="ndef">exclusive or</span>, <span class="code">a xor b</span> is
false when both values have the same logic state, that is when both are true, or both
are false. When the values are not the same, then the result of the xor operator is
true. The <span class="op">xor</span> operator makes more sense for bit operations, which we will
learn later&#8201;&#8212;&#8201;for the boolean type, <span class="code">a xor b</span> is identical to <span class="code">a != b</span>.</p>
</div>
<div class="paragraph">
<p>When using conditional execution, some people like to write expressions like
<span class="code">if myBoolExp == false:</span>, which is identical to <span class="code">if not myBoolExp:</span>.
Well they may do, but please never write <span class="code">if myBoolExp == true:</span>, that looks
really too stupid.</p>
</div>
<div class="paragraph">
<p>Sometimes it is useful to know that <span class="lit">false</span> is mapped to the int value <span class="lit">0</span>, and <span class="lit">true</span>
to the int value <span class="lit">1</span>. That is similar to the C language, but C has not a bool type, instead
the numerical value <span class="lit">0</span> is interpreted as <span class="lit">false</span> in conditional expressions, and all
none zero values are interpreted as true.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a: int = 0
if cond:
  a = 7

a = 7 * cond.int</code></pre>
</div>
</div>
<div class="paragraph">
<p>The effect of the last line is identical to the <span class="key">if</span> statement above. In very, very rare cases,
working with the actual int value of boolean variables may make sense, but generally we should
avoid that. Later in the book there is a section about <span class="ndef">branchless code</span> where we will
present a <span class="proc">proc</span> that actually may get faster by using such a trick.</p>
</div>
</div>
<div class="sect2">
<h3 id="_characters">Characters</h3>
<div class="paragraph">
<p>The data type for single characters is called <span class="type">char</span> in Nim. A variable of type <span class="type">char</span>
has 8 bits and can store single characters. Indeed, it stores 8-bit integers which are
mapped to characters. The mapping is described by the ASCII table. For example, the
integer value <span class="lit">65</span> in decimal is mapped to the character <span class="lit">A</span>. When we use single
character literals, then we have to enclose the letter in single quotes. As only 8
bits are used to store characters, we only have 256 different values, including upper
and lower case letters, punctuation characters and some characters with a special
meaning like a newline character to move the cursor in the terminal to the next line,
or a backspace character to move the cursor one position backwards. Single characters
are not used that often, since we generally group them in sequences called strings to
build text.</p>
</div>
<div class="paragraph">
<p>The initial ASCII table contains only the characters with numbers 0 up to 127, here
is an overview generated with the small program listed in the appendix:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Visible ASCII Characters

      +0   +1   +2   +3   +4   +5   +6   +7   +8   +9  +10  +11  +12  +13  +14  +15
  0
 16
 32        !    "    #    $    %    &amp;    '    (    )    *    +    ,    -    .    /
 48   0    1    2    3    4    5    6    7    8    9    :    ;    &lt;    =    &gt;    ?
 64   @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O
 80   P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _
 96   `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o
112   p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~</pre>
</div>
</div>
<div class="paragraph">
<p>The position in the table is the sum of the number on the left and the number on the
top, i.e, character <span class="lit">A</span> has position <span class="code">64&#43;1=65</span>, which is the value the Nim standard
function <span class="code">ord('A')</span> or <span class="code">int('A')</span> would return. The characters with a
decimal value less than 32 can not be printed and are called <span class="ndef">control characters</span>, like
linefeed, carriage return, backspace, audible beep and such. Character 127 is also
not printable, and is called DEL. An important property of this table is the fact
that decimal digits and upper- and lower-case letters form contiguous blocks. So to
test for example if a characters is an uppercase letter, we can use this simple
condition: <span class="code">c &gt;= 'A' and c &lt;= 'Z'</span>.</p>
</div>
<div class="paragraph">
<p>Characters with <span class="code">ord() &gt; 127</span> are so-called umlauts, exotic characters of other
languages, and some special characters. But these characters may be different on
different computers, as the characters depend on the active <span class="ndef">code-page</span>, which maps
position to actual character, and there are multiple code pages. When we need more
than the plain ASCII characters, then we use strings in Nim, which display many more
glyphs by using UTF-8 encoding.</p>
</div>
<div class="paragraph">
<p>The control characters with a decimal value less than 32 can not be typed on the
keyboard directly, and for some characters with decimal value greater than 126 it can
be difficult to enter them on some keyboards. For these characters as well as for all
other characters, escape sequences can be used. Escape sequences start with the
backslash character, and the following characters are interpreted in a special way:
The backslash can follow a numeric value in decimal or hexadecimal encoding, or a
letter which is interpreted in a special way. We mentioned already that the character
'A' is mapped to the decimal value 65, which is its position in the ASCII table. So
instead of 'A' we could use the escape sequence '\65' for this character. Or, as
decimal 65 is 41 in hexadecimal notation <span class="term">(4 * 16^1 &#43; 1 * 16^0)</span> we can use
'\x41' where the x indicates that the following digits are hexadecimal. For common,
often used control characters it is not easy to remember their numeric value, so
another notation with a letter following the backslash can be used. For the important
newline character we can use the decimal numeric value '\10', the hexadecimal value
'\xA' or the symbolic form '\n'. Here, the letter n stands for newline.</p>
</div>
<div class="paragraph">
<p>We can regard the backslash character, which introduces escape sequences, as a special
hinting symbol for the compiler: <span class="ndef">Caution, the following characters must be interpreted in a special
way</span>.</p>
</div>
<div class="paragraph">
<p>It is important that you understand that all these escape sequences are only
a way to help the programmer to enter these invisible control characters&#8201;&#8212;&#8201;the
compiler replaces the control sequences immediately with the correct 8-bit
value from the ASCII table, so in the final compiled executable '\65' or '\n'
are both only a plain 8-bit integer value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a, b: char
a = 'A'
b = '\65'
echo a, ord(a), b, ord(b) # if you don't know the output, read again this section and run this code.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following
table lists a few important control characters:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Decimal</th>
<th class="tableblock halign-left valign-top">Hexadecimal</th>
<th class="tableblock halign-left valign-top">Symbolic</th>
<th class="tableblock halign-left valign-top">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\n, \l</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">newline or linefeed&#8201;&#8212;&#8201;move cursor one position down</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\f</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">formfeed</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x9</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tabulator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\v</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">vertical tabulator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">92</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x5C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\\</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backslash</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">39</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\'</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">single quote, apostrophe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">alert, audible beep</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">backspace</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">27</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x1B</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escape, [ESC]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">\r, \c</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">return or carriage return&#8201;&#8212;&#8201;move cursor at the beginning of the line</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The hexadecimal numbers after the <span class="term">\x</span> character can be upper or lower case
and can have one or two hexadecimal digits. For symbolic control characters like '\a'
for alert, the upper case variant '\A' seems to be identical currently. The single
quote entered as <span class="lit">'''</span> does give an error message, so you have to escape it as <span class="lit">'\''</span>.
Unfortunately, by supporting this form of escaping it becomes impossible to enter a
backslash character directly, so we have to escape the backslash character as <span class="lit">'\\'</span> to
print a single backslash.</p>
</div>
<div class="paragraph">
<p>For Nim the most important control character is <span class="lit">'\n'</span> which is used to start the
output in a terminal window at the beginning of a new line. But <span class="lit">'\n'</span> is generally not
used as a single character but embedded in <span class="type">strings</span>, that is, sequences of characters.
We will learn more about strings soon. Note that the <span class="func">echo()</span> function inserts a
newline character automatically after each printed line, but the <span class="func">write()</span> function
does not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo 'N', 'i', 'm'
stdout.write 'N', 'i', 'm', '\n'</code></pre>
</div>
</div>
<div class="paragraph">
<p>What may be a bit confusing is the fact that we use the backslash character as an escape
symbol, and at the same time the above table has an entry <span class="lit">'\e'</span> which is also called
[ESC]. These <span class="lit">'\e'</span> control character with decimal value <span class="lit">27</span> is fully unrelated to the
backslash character that we use to type in control characters. [ESC] is a different special
character to start control sequences, it was used in the past to send special
commands to printers or modems, and can be used to control font style or colors in
terminal windows.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s control characters should, with few exceptions, be identical with control
characters of the C language, so you may also consult C literature for more details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_ordinal_types">Ordinal types</h3>
<div class="paragraph">
<p>In Nim integers, enumerations, characters and the boolean types are ordinal types.
Ordinal types are countable and ordered, and for each of these types a lowest and
largest member exists. The integer ordinal types support the inc() and dec()
operations to get the next larger or next smaller value, and the other ordinal types
use succ() and pred() for this operation. These operations can produce overflow or
underflow like errors if applied to largest or smallest value. The function ord() can
be used on ordinal types to get the corresponding integer value. Note that unsigned
integers are currently not called ordinal types in Nim, and that these unsigned types
wrap around instead of generation overflow and underflow errors.</p>
</div>
</div>
<div class="sect2">
<h3 id="_sets">Sets</h3>
<div class="paragraph">
<p>From mathematics, we know that sets are some form of unordered collection for which we
can test membership (x is included in mySet) and we can perform general set
operations like union of multiple sets. In Nim we can have sets of all the ordinal
types and the unsigned integer types, but due to memory restrictions, integer
types larger than two bytes can not be used as set base types.
All elements in a set must have the same base type. A set can be empty, or it
can contain one or multiple elements. For a specific element, it can be contained in a
given set, or it can be not contained, but it can be never contained multiple times.
One very basic set operation is to test if an element is contained in a set or is
not contained in it. Sets are unordered data types, that is sets containing the same
elements are always equal, it does not matter in which sequence we added the
elements. Important set operations are building the union and building the
difference of two sets with the same base type: The union of set <span class="var">a</span> and set <span class="var">b</span> is a set which contains all the elements
that are contained in set <span class="var">a</span> or in set <span class="var">b</span> (or in both). The intersection of set <span class="var">a</span> and set <span class="var">b</span>
is a set which contains only elements which are contained in set <span class="var">a</span> and in set <span class="var">b</span>.</p>
</div>
<div class="paragraph">
<p>The mathematical concept of sets maps well to words and bits of computers, as most
CPU&#8217;s have instructions to set and clear single bits and to test if a bit is set or
unset. And CPU&#8217;s can do <span class="op">and</span>, <span class="op">or</span> and <span class="op">xor</span> operations which
corresponds to the union and intersection operation in mathematical set.</p>
</div>
<div class="paragraph">
<p>Nim supports sets with base type bool, enum, char, int8, uint8, int16 and uint16.
Note that we need a bit in the computer memory for each member of the base type. The
types char, int8 and uint8 are 8 bit types and can have 2^8 = 256 distinct values, so
we require 256 bits in the computer memory to represent such a set. That would be 32
bytes or four 64-bit words. To represent a set of the base type uint16 or int16, we
need already 2^16 bits, that is 2^13 bytes or 2^10 words on a 64-bit CPU. So it
becomes clear that supporting base types with more than 16 bit makes not much sense.</p>
</div>
<div class="paragraph">
<p>While testing if an element is included or is not included in a set with the <span class="op">in</span> or
<span class="op">notin</span> operators is always a very fast operation, other
operations like building the intersection or union and set comparison operations
may be not that fast when we use the int16 or uint16 base types, as for
these operations the whole set, that is 2^10 words on a 64-bit CPU, has
to be processed.</p>
</div>
<div class="paragraph">
<p>We will start our explanation with sets with character base type, as these sets are
very easy to understand and at the same time very useful. Let us assume that we have
a variable of character type, and we want to test if that variable is alphanumeric,
that is, if it is a lower or upper case letter or a digit. A traditional test would be
<span class="code">(x &gt;= a and x &lt;=+z) or (x +&gt;= A and x &lt;= Z) or (x &gt;= 0 and x &lt;= 9)</span>. Using Nim&#8217;s set
notation, we can write that in a simpler form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const
  AlphaNum: set[char] = {'a' .. 'z', 'A' .. 'Z', '0' .. '9'}

var x: char = 's'
echo x in AlphaNum</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we defined a constant of <span class="type">set[char]</span> type which contains lower and upper case
letters and the decimal digits. We used the range notation to save us a lot of typing
({'a', 'b', 'c', &#8230;&#8203;}). It works in this case only, as we know that all the lowercase
letters, the upper case letters and the decimal digits built an uninterrupted range
in the ASCII table.</p>
</div>
<div class="paragraph">
<p>With that definition, we can use a simple test with the <span class="key">in</span> keyword. These test
is equivalent to the procedure call AlphaNum.contains(x). In compiled languages (most) set
operations are generally very fast as they map well to CPU instructions.</p>
</div>
<div class="paragraph">
<p>Older languages like C have not a dedicated set data type, but as sets are so useful
and efficient, C emulates these operations by using bit-wise <span class="op">and</span> and <span class="op">or</span>
operations in conjunction with bit shifts.</p>
</div>
<div class="paragraph">
<p>Two important operations for sets are building the union and the intersection:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const
  AlphaNum: set[char] = {'a' .. 'z', 'A' .. 'Z', '0' .. '9'}
  MathOp = {'+', '-', '*', '/'} # set[char]

  ANMO = AlphaNum + MathOp # union
  Empty = AlphaNum * MathOp # intersection</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constant ANMO would now contain all the characters from AlphaNum and from MathOp,
that is letters, digits and math operators. The constant Empty would get all the
characters that are at the same time contained in set AlphaNum and in set MathOp. As
there is not a single common character, the set Empty is indeed empty. Remembering
the two operators <span class="op">&#43;</span> and <span class="op">*</span> for union and intersection is not easy. For
the intersection operator <span class="op">*</span> it may help when we imagine the set members as
bits, and we assume that we multiply the bits of both operands bitwise, that is we
multiply the set or unset bits at corresponding position each. The resulting bit
pattern would get set bits only for positions where both arguments have set bits.</p>
</div>
<div class="paragraph">
<p>We can use the functions <span class="func">incl()</span> and <span class="func">excl()</span> to add or remove single set members:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s: set[char]
s = {} # empty set
s = {'a' .. 'd', '_'}
s.excl('d')
s.incl('?')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The result is a <span class="type">set</span> with letters <span class="lit">a</span>, <span class="lit">b</span>, <span class="lit">c</span> and the characters <span class="lit">_</span> and <span class="lit">?</span>. Note that
calling <span class="func">incl()</span> has no effect when the value is already included in the set, and
calling <span class="func">excl()</span> has no effect when the value is not contained in the set at all.</p>
</div>
<div class="paragraph">
<p>Another operation is the difference of two sets&#8201;&#8212;&#8201;<span class="code">a - b</span> is a set which
contains only the elements of <span class="var">a</span> which are not contained in <span class="var">b</span>. In Nim there is
currently no operator for the complement or the symmetric difference of sets
available. We can produce a set complement by using a fully filled set and then
removing the elements of which we want the complement. For a character set that would
look like <span class="code">{'\0'..'\255'} - s</span>, where <span class="var">s</span> is the set to complement. And the symmetric
difference of set <span class="var">a</span> and set <span class="var">b</span> can be generated by the operation <span class="code">(a&#43;b) -
(a*b)</span> or by <span class="code">(a-b) &#43; (b-a)</span>.</p>
</div>
<div class="paragraph">
<p>As the <span class="op">not</span> operator binds more tightly than the <span class="op">in</span> operator, we have to use brackets
for the inverted membership test like <span class="code">not(x in a)</span> or we can use the <span class="op">notin</span>
operator and write <span class="code">x notin a</span>. We can test for equality of sets <span class="var">a</span> and <span class="var">b</span> like
<span class="code">a == b</span> and for subset relation <span class="code">a &lt; b</span> or <span class="code">a &lt;= b</span>. <span class="code">a &lt;= b</span>
indicates that <span class="var">b</span> contains at least all members of <span class="code">a</span>, and <span class="code">a &lt; b</span> that <span class="var">b</span>
contains all members of <span class="var">a</span> and at least one more element.</p>
</div>
<div class="paragraph">
<p>Finally, we can use the function <span class="func">card()</span> to get the cardinality of a <span class="type">set</span> variable, that
is the number of contained members.</p>
</div>
<div class="paragraph">
<p>We should also mention that we can have character sets which are restricted to a
range of characters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  CharRange = set['a' .. 'f']

# var y: CharRange = {'x'} #invalid

var y: CharRange = {'b', 'd'}
echo 'c' in y</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code above, the compiler detects the assignment to variable <span class="var">y</span> as invalid.</p>
</div>
<div class="paragraph">
<p>Set of numbers work in principle in the same way as sets of characters. One problem
is that in Nim integer numbers are generally 4 or 8 bytes large, but sets can contain
only numbers with 1 or 2 byte size. So we have to specify the type of set members
explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  ChessPos = set[0'i8 .. 63'i8]

var baseLine: ChessPos = {0.int8 .. 7.int8}
var p: int8
echo p in baseLine</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code above, we defined a set type which can contain <span class="type">int8</span> numbers in the range <span class="lit">0</span>
to <span class="lit">63</span>.</p>
</div>
<div class="paragraph">
<p>We can use also another notation for numeric sets when we define an explicit range
type like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  ChessSquare = range[0 .. 63]
  ChessSquares = set[ChessSquare]

const baseLine = {0.ChessSquare .. 7.ChessSquare}
# or
const baseLineExplicit: ChessSquares = {0.ChessSquare .. 7.ChessSquare}
assert baseLine == baseLineExplicit</code></pre>
</div>
</div>
<div class="paragraph">
<p>What may be a bit surprising is the fact that Nim&#8217;s sets work also for negative
numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  XPos = set[-3'i8 .. +2'i8]

var xp: XPos = {-3.int8 .. 1.int8}
var pp: int8 = -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enum sets are also very useful and can be used to represent multiple boolean
properties in a single set variable instead of using multiple boolean variables for
this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  CompLangFlags = enum
    compiled, interpreted, hasGC, isOpenSource, isSelfHosted
   CompLangProp = set[CompLangFlags]

const NimProp:  CompLangProp = {compiled, hasGC, isOpenSource, isSelfHosted}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enum sets can be used to interact with functions of C libraries where for flag
variables often or&#8217;ed ints are used. For example, for the gintro C bindings there is
this definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  DialogFlag* {.size: sizeof(cint), pure.} = enum
    modal = 0
    destroyWithParent = 1
    useHeaderBar = 2

  DialogFlags* {.size: sizeof(cint).} = set[DialogFlag]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the {.size.} pragma is used to ensure that the byte size of that set type
matches the size of integers in C languages.</p>
</div>
<div class="paragraph">
<p>When we define a set of enums in this way to generate bindings to C libraries, then we
have to ensure that the enum values start with zero, otherwise Nim&#8217;s definition will
not match with the C definition. For example, in the gdk.nim module we have</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  AxisFlag* {.size: sizeof(cint), pure.} = enum
    ignoreThisDummyValue = 0
    x = 1
    y = 2
    pressure = 3
    xtilt = 4
    ytilt = 5
    wheel = 6
    distance = 7
    rotation = 8
    slider = 9

  AxisFlags* {.size: sizeof(cint).} = set[AxisFlag]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first enum with ordinal value zero was automatically added by the bindings
generator script to ensure type matching. Nim&#8217;s devs sometimes recommend to use plain
(distinct) integer constants for C enums. That may be easier, but integer constants
provide no name spaces, so names may be aFlagWheel instead of AxisFlag.wheel or plain
wheel when there is no name conflict for pure enums. And with integer constants we
have to combine flags by or operation like (aFlagWheel or aFlagSlider) instead of
clean {AxisFlag.wheel, slider}.</p>
</div>
<div class="paragraph">
<p>Can we print sets easily? As sets are an unordered type, it is not fully trivial, but
we can iterate over the full base type and check if the element is contained in our
set like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s: set[char] = {'d' .. 'f', '!'}

for c in 0.char .. 255.char:
  if c in s:
    stdout.write(c, ' ')
echo ' '</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>! d e f</pre>
</div>
</div>
<div class="paragraph">
<p>We will learn how the for loop work soon. Note that the sequence in which the set
members are printed is determined by our query loop, not by the set content itself,
as sets are unordered types.</p>
</div>
</div>
<div class="sect2">
<h3 id="_strings">Strings</h3>
<div class="paragraph">
<p>The <span class="type">string</span> data type is a sequence of characters. It is used whenever a textual input
or output operation is performed. Usually it is a sequence of ASCII-only characters,
but multiple characters in the string can be interpreted as so called utf-8 Unicode
characters, that allow displaying nearly unlimited symbols as long as all the needed
fonts are installed on your computer, and you manage to enter them&#8201;&#8212;&#8201;Unicode
characters may be not accessible by a simple keystroke. For now, we will only use
ASCII characters, as they are simpler and work everywhere. String literals must be
enclosed in double quotes. Nim&#8217;s strings are similar to the Nim seq data types: both
are homogeneous variable-size containers. That means that a string or a seq expands
automatically when you append or insert characters or other strings. Don&#8217;t confuse
short strings with only one character with single characters: A string is a non-trivial
entity with internal state like data buffer (the actual contained
characters), length and storage capacity, while a variable of <span class="type">char</span> type is nothing more than a
single byte interpreted in a special way. So a string like <span class="lit">"x"</span> is fully different
from <span class="lit">'x'</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  str: string = "Hello"
  name: string
echo "Please tell me your name"
name = readLine(stdin)
add(str, ' ')
echo str, name</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example code, we declare a variable called <span class="var">str</span> and assign it the initial
literal value <span class="lit">"Hello"</span>. We use the <span class="func">echo()</span> procedure to ask the user
for his name, and use the <span class="func">readLine()</span> procedure to read the user input from
the terminal. To show how we can add characters to existing <span class="type">string</span> variables, we call
the <span class="func">add()</span> procedure to append a space character to our <span class="var">str</span> variable, and
finally call the <span class="func">echo()</span> procedure to print the hello message and the name to
the screen. Note that the <span class="func">echo()</span> procedure automatically terminates each
output operation with a jump to the next line. If you want an output operation
without a newline, you can use the similar <span class="func">write()</span> procedure. But write()
needs an additional first parameter, for which we use the special variable
<span class="var">stdout</span> when we want to write to the terminal window.</p>
</div>
<div class="paragraph">
<p>So we could substitute the last two lines of the above code by</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">write(stdout, str)
write(stdout, ' ')
echo name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Nim standard library provides a lot of functions for creating and modifying
strings, most of these functions are collected in the <span class="mod">system</span> and in the <span class="mod">strutils</span>
module. The most important procedures for strings are <span class="func">len()</span> and <span class="func">high()</span>. The <span class="func">len()</span>
procedure returns the length of a string, that is, the number of ASCII characters or
bytes that the string currently contains. The empty string <span class="lit">""</span> has length zero. Note
that the plain <span class="func">len()</span> function returns the number of 8-bit characters, not the number
of Unicode glyphs, when the string should be interpreted as Unicode text. To determine
the number of glyphs of Unicode strings, you should use some of the <span class="mod">unicode</span> modules.
The <span class="func">high()</span> function is very similar to the <span class="func">len()</span> function, it returns the index of
the last character in the string. For each string <span class="var">s</span> <span class="code">high(s) == len(s) -1</span>,
so <span class="func">high("")</span> is <span class="lit">-1</span>.
Remember
that Nim supports method call syntax, so we can also write <span class="code">s.len</span> instead of <span class="code">len(s)</span>.</p>
</div>
<div class="paragraph">
<p>The most important operators for strings are the subscript operator <span class="op">[]</span> which
allows access to individual characters of strings, and the <span class="op">..</span> slice operator,
which allows access to sub-strings. The first character in a string has always the
index zero. For concatenation of string literals or string variables, Nim uses the
<span class="op">&amp;</span> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s = "We hate " &amp; "Nim?"
s[3 .. 6] = "like"
s[s.high] = '!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we define the string variable <span class="var">s</span> by use of two literal strings to show the
use of the concatenation operator. In line two we use the slice operator to replace
the sub-string <span class="lit">"hate"</span>, that is the characters with index position 3 up to 6, with the string literal <span class="lit">"like"</span>. In
this case the replacement has exactly that many characters as the text to replace,
but that is not necessary: We can replace sub-strings with longer or shorter strings,
which includes the empty string <span class="lit">""</span> to delete a text area. In the last line of the above
example, we use the subscript operator <span class="op">[]</span> to replace the single character <span class="lit">'?'</span>
at the end of our string with an exclamation mark. For subscript and slice operators,
Nim supports also a special notation which indicates indexing from the end of the
string. Python and Ruby use negative integers for this purpose, while Nim uses the
<span class="op">^</span> character. So <span class="code">[^1]</span> is the last character, <span class="code">[^2]</span> the one before
the last. So we could have written <span class="code">s[^1] = '!'</span> for the last line of our code
fragment above. The reason that Nim does not use negative integers for this purpose
is that Nim arrays don&#8217;t have to start at index zero, but can start with an arbitrary
index including negative indices, so for negative indices it may be not always clear
if a regular index or a position from the end of the string is desired. The term
<span class="code">s[^x]</span> is equivalent to <span class="code">s[s.len - x]</span>. We will learn some more
details about the slice operator in a later section when we have introduced arrays
and sequences.</p>
</div>
<div class="paragraph">
<p>Another important operator for strings is the "toString" or stringify operator
<span class="op">$</span>. It can be applied to variables of nearly all data types
and returns its string representation,
which can then be printed. Some procedures like <span class="func">echo()</span> apply this operator on its
arguments automatically. When we define our own data types, then it can make some
sense to define the <span class="op">$</span> for them, in case we need a textual representation of
our data&#8201;&#8212;&#8201;maybe only for debugging purpose. Note that applying the <span class="op">$</span>
operator on a string directly has no effect and is ignored, as the result would not
change.</p>
</div>
<div class="paragraph">
<p><span class="type">Strings</span> can contain all characters of the <span class="type">char</span> data type, including the control
characters. The most essential control character for strings is the newline character
<span class="lit">'\n'</span> which is used at the end or sometimes also in the middle of strings to start a new line. For
strings, Nim also supports the virtual character <span class="lit">"\p"</span> to encode an OS dependent line
break. When compiled for Windows, <span class="lit">"\p"</span> is automatically converted to <span class="lit">"\r\n"</span>, and to
a plain <span class="lit">'\n'</span> on Linux. Note that <span class="lit">"\p"</span> can be used in strings, but not as a single
character, as it is two byte on Windows. <span class="lit">"\p"</span> is only needed to support very old
Windows version or potentially other exotic operating system, as modern Windows recognizes plain <span class="lit">'\n'</span>
well.</p>
</div>
<div class="paragraph">
<p>As strings support utf-8 Unicode, an escape sequence starting with <span class="lit">"\u"</span> is supported
to insert Unicode code points. The <span class="lit">"\u"</span> follows exactly 4 hexadecimal digits or an
arbitrary number of hex digits enclosed in curly braces {}.</p>
</div>
<div class="paragraph">
<p>As string literals are enclosed in quotation marks, it follows that strings can not
directly contain this character, we have to escape it as in <span class="code">"\"Hello\", she
said"</span>.</p>
</div>
<div class="paragraph">
<p>Perhaps we should mention that Nim strings use copy semantics for assignment. As we
have not yet introduced references or pointers, copy semantics is what you should
expect&#8201;&#8212;&#8201;strings behave just like all the other simple data types we used before
like integer or float numbers or enums and characters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  s1: string
  s2: string
s1 = "Nim"
s2 = s1
s1.add(" is easy!")
echo s1 &amp; "\n" &amp; "s2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Nim is easy!
Nim</pre>
</div>
</div>
<div class="paragraph">
<p>The assignment <span class="code">s2 = s1</span> creates a copy of <span class="var">s1</span>, so the subsequent <span class="func">add()</span>
operation does only modify <span class="var">s1</span> but not <span class="var">s2</span>. Probably not surprising for you, but other
programming languages may behave differently, i.e. the assignment may not copy the
textual content but create only a reference to the first string, so that modifying
one of them also affect the other. We will learn more about the concept of references
when we introduce the object data type.</p>
</div>
<div class="sect3">
<h4 id="_entering_unicode_characters">Entering Unicode Characters</h4>
<div class="paragraph">
<p>UTF-8 is a variable-width character encoding. To cite the introducing section from
<a href="https://en.wikipedia.org/wiki/UTF-8" class="bare">https://en.wikipedia.org/wiki/UTF-8</a>:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>UTF-8 is capable of encoding all 1,112,064[nb 1] valid character code points in
Unicode using one to four one-byte (8-bit) code units. Code points with lower
numerical values, which tend to occur more frequently, are encoded using fewer bytes.
It was designed for backward compatibility with ASCII: the first 128 characters of
Unicode, which correspond one-to-one with ASCII, are encoded using a single byte with
the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded
Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points
into UTF-8, UTF-8 is safe to use within most programming and document languages that
interpret certain ASCII characters in a special way, such as "/" (slash) in
filenames, "\" (backslash) in escape sequences, and "%" in printf.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In Nim we have four ways to enter Unicode characters: As hexadecimal digits following
the "\x", as Unicode code point following the "\u" or we can type the Unicode sequence
directly on our keyboard, as one single keystroke when our keyboard layout supports
that, or as a special OS dependent sequence of keystrokes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo "\xe2\x99\x9A \xe2\x99\x94"
echo "\u265A \u2654"
echo "\u{265A} \u{2654}" # {} is only necessary for more than 4 hex digits
echo "♚ ♔"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code above shows three ways to print the symbol for a black and a white king of a
chess game. In the first line we typed the Unicode sequence directly as hexadecimal
digits, this method is rarely used today. In the second line we used "\u" to enter
the code point directly, we get the code from
<a href="https://en.wikipedia.org/wiki/List_of_Unicode_characters" class="bare">https://en.wikipedia.org/wiki/List_of_Unicode_characters</a>. And finally we entered the
glyph directly in an editor. For some Linux editors like gedit we can hold down shift
and control key and then type u, release all keys and type the Unicode digits like
265a and a space. See <a href="https://en.wikipedia.org/wiki/Unicode_input" class="bare">https://en.wikipedia.org/wiki/Unicode_input</a> for details and
other operating system.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_cstring_data_type">The CString data type</h4>
<div class="paragraph">
<p>In the C programming language, strings are just pointers to sequences of characters of fixed
length.<sup class="footnote">[<a id="_footnoteref_20" class="footnote" href="#_footnotedef_20" title="View footnote.">20</a>]</sup> The end of such a C string is generally marked with the character <span class="lit">'\x0'</span>&#8201;&#8212;&#8201;a null byte with all bits cleared.
C functions like <span class="func">printf()</span> needs these <span class="lit">"\x0"</span> characters to determine the end of the C
string. While Nim strings are complex entities that store its current size and other
properties, and can grow dynamically, the character sequence of Nim strings has also
a hidden terminating <span class="lit">'\x0'</span> character at the end to make them compatible with C
strings. Nim has also the data type cstring, called "compatible string" in modern
Nim, which matches the strings in C language if we compile as usual with the C backend.
Cstrings are used in bindings definitions for C libraries, but as cstrings can not
grow and do support only few string operations, they are only used in rare cases in
ordinary Nim source code. The Nim compiler passes automatically the zero terminated
data buffer of Nim strings to C libraries whenever we call a C library, so there is
no expensive type conversion involved. But the other way is much more expensive: When
you have an existing cstring and need a Nim string with the same content, then a simple
conversion is not possible as a Nim string is a different, more complex entity. So we
have to create a Nim string and copy the content, you can use the stringify operator
<span class="op">$</span> for this like in <span class="code">myNimStr = $myCString</span>. Generally, string creation
is an expensive operation compared to plain operations like adding two numbers, so
when performance matters one should try to avoid unnecessary string creation and also
unnecessary string operations. This is mostly important in loops, which are executed
often. We will explain more about the internal of strings and why string creation and
dynamically allocating memory is expensive in later sections of the book.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>When we access text ranges with the slice operator or single characters with the
subscript operator, we should never access indices below the currently last index,
which is the index mystr.high or ^1. If we do that, we get an exception, as that
index would contain undefined data or would not exist at all. We said earlier that
Nim strings grow automatically if we insert or append data. But that does not mean
that we can use the subscript or slice operator to access characters after the
current end of the string. Such an operation would really make not much sense:
Imagine we have a string var str = "Nim" and now use the subscript operator and
assign a character at position 10 with <span class="code">str[10] = '!'</span>. What should become the content
of characters 4 .. 9? Well, maybe spaces would make some sense, but in fact such
access after the currently last valid character of the string is forbidden. You could
do <span class="code">str.add("      !")</span> for this purpose.</p>
</div>
<div class="paragraph">
<p>Another operation you should avoid is inserting the <span class="lit">'\x0'</span> null byte character
somewhere in an existing Nim string. Nim stores the actual length of strings
explicitly and additional terminates the end of the actual data with a <span class="lit">'\x0'</span> to
make the string compatible with C strings and allow passing the data buffer
directly to C library functions. A <span class="lit">'\x0'</span> character somewhere in the middle of a
Nim string would generate an inconsistency, as C library functions like <span class="func">printf()</span>
would regard <span class="lit">'\x0'</span> as the string end marker, while pure Nim functions
may assume still a longer string. Intermediate <span class="lit">'\x0'</span> bytes in strings can in very rare cases
be a problem when we get the actual byte sequence from C libraries. For the
same reason, a Nim string is not identical or fully compatible with s <span class="type">seq[char]</span>,
as a <span class="type">seq[char]</span> may contain multiple zero byte data, while Nim strings should not.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_escape_sequences_in_strings">Escape Sequences in Strings</h4>
<div class="paragraph">
<p>We learned about control characters already in the section about characters, and
earlier in this section we mentioned that strings can also contain control
characters. As the use of control characters may be not really easy to understand, we
will explain their use in strings in some more detail and give a concrete example.</p>
</div>
<div class="paragraph">
<p>The most important control character for strings is the newline character, which
moves the cursor in the terminal window to the beginning of the next line. The
<span class="func">echo()</span> procedure prints that character automatically after each output
operation. Indeed, it can be important, to terminate each output operation with that
character, as the output can be buffered, and writing just a string without a
termination newline may not appear at once on the screen, but can be delayed. That is
bad when the user is asked something and should respond, but the message is still
buffered and not yet visible.</p>
</div>
<div class="paragraph">
<p>The problem with special characters like backspace or newline is that we can not
enter them directly with the keyboard.<sup class="footnote">[<a id="_footnoteref_21" class="footnote" href="#_footnotedef_21" title="View footnote.">21</a>]</sup> To solve
that problem, escape sequences were introduced for most programming languages. An
escape sequence is a special sequence of characters, that the compiler can discover
in strings and then replace with a single special character. Whenever we want a
newline in a string we type it as <span class="lit">"\n"</span>, that is, the backslash character
followed by an ordinary letter n, n for newline.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo "\n"
echo "Hello\nHello\nHello"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first line prints two empty lines&#8201;&#8212;&#8201;two because the <span class="lit">\n</span> generates a jump
to next the line, and because <span class="func">echo()</span> always adds one more jump to the next line. The
second line prints three lines which each contains the word <span class="lit">Hello</span>, and the cursor is
moved below the last <span class="lit">Hello</span>, because <span class="func">echo()</span> automatically adds one more
newline character.</p>
</div>
<div class="paragraph">
<p>Older Windows versions used generally a sequence of two control characters to start a
new line, one <span class="lit">'\r'</span> (carriage-return) to move to the start of the line, and one <span class="lit">'\l'</span>
(linefeed) to move down. You may still find these two characters in old Windows text
files at the end of each line. Old printers used this combination too, so it was
possible to send that text files to old printers directly. Nim also has the special
escape sequence <span class="lit">"\p"</span> which is called platform dependent newline and maps to <span class="lit">"\c\l"</span> on
Windows. That is, when we compile our program on Windows, then the compiler replaces
<span class="lit">"\p"</span> in our strings with a carriage-return and a linefeed character, and when we
compile on Linux then the compiler replaces <span class="lit">"\p"</span> only with a newline character. But
modern Windows supports <span class="lit">'\n'</span>, so we generally can use that.</p>
</div>
</div>
<div class="sect3">
<h4 id="_raw_strings_and_multi_line_strings">Raw Strings and multi-line Strings</h4>
<div class="paragraph">
<p>In rare situations you may want to print exactly what you have typed, so you do not
want the compiler to replace a <span class="lit">'\n'</span> by a newline character. You can do that in two
ways: You can escape the escape character, that is, you put in front of the backslash
one more backslash. When you print the string <span class="lit">"\\n"</span> you will get a backslash and the
<span class="lit">n</span> character in your terminal. Or you can use so-called raw strings, that is, you put
the character <span class="lit">r</span> immediately in front of your string like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo r"\n"
echo "\\n"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multi-line strings are also raw strings, that is contained escape-sequences are not
interpreted by the compiler, and additional multi-line strings, as the name implies,
can extend over multiple lines of the source text. Multi-line texts starts and ends
with three quotes like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo """this is
three lines
of text"""

echo "this is\nthree lines\nof text"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both echo() commands above generates exactly the same machine code!</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comments">Comments</h3>
<div class="paragraph">
<p>Comments are not really a data type, but they are also important. Ordinary comments
starts with the hashtag character <span class="lit">#</span> and extend to the end of the line. The <span class="lit">\</span>#
character itself and all following characters up to the line end are ignored by the
compiler. You can also start the comment with <span class="lit">\</span>\##, then it is a documentation comment.
It is also ignored by the compiler, but can be processed when you use later tools to
generate documentation for your code. Documentation comments are only allowed at
certain places, often they are inserted at the beginning of a procedure body to
explain its use. There are also multi-line comments, which starts with the two
characters #[ and ends with ]#. These form of comment can extend over multiple
lines and can be nested, that is multi-line comments can contain again plain or multi-line
comments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># this is comment
## important note for documentation
#[ a longer
but useless comment
#]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multi-line documentation comments also exists and can also be nested.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc even(i: int): bool =
  ##[ This procedure
  returns true if the integer argument is
  even and false otherwise.
  ]##
  return i mod 2 == 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the #[ comment ]# notation to insert comments everywhere in the
source code at places where a white-space character is allowed, but these form of in
source comments is rarely used.</p>
</div>
</div>
<div class="sect2">
<h3 id="_other_data_types">Other data types</h3>
<div class="paragraph">
<p>There exists some more predefined types like the container types <span class="type">array</span> and <span class="type">seq</span>, which
can contain multiple elements of the same type, or the <span class="type">tuple</span> and the <span class="key">object</span>  type which can contain data of
different types. Nim tuples and objects are
similar to C structs, they are not so verbose as Java classes. We will learn more
about all these types in later sections of the book.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nim_source_code">Nim Source Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You have already seen a few examples of simple Nim source code. The code is basically
a plain text file consisting of ASCII characters, that is the ordinary characters
which you can type on your keyboard. Generally Nim source code can also contain
Unicode utf-8 characters, so instead of using names consisting of ASCII characters
for your symbol names, you could just use single Unicode characters or sequences of
Unicode characters. But typically that makes not much sense, entering unicode is not
that easy with a keyboard, and it is displayed only correctly on the screen or in the
terminal when the editor or terminal supports Unicode properly and when all necessary
fonts are installed. That may be the case for your local computer, but what when
someone others may edit your source code?</p>
</div>
<div class="paragraph">
<p>Starting with Nim version 1.6 we got some support for Unicode operators, which may
be useful for some applications. For details, please see the Nim compiler manual.</p>
</div>
<div class="paragraph">
<p>Nim currently does not allow inserting tabular characters (tabs) in your source code,
so you have to do the indentation of blocks by spaces only. Typically, we use two
spaces for each indentation level. Other numbers work also, but you should stick to a
fixed value.</p>
</div>
<div class="paragraph">
<p>Names in Nim, as used for modules, variables, constants, procedures, user defined
types and other symbols may contain lower and upper case letters, digits, Unicode
characters and additional underscores. But the names are not allowed to start with
digits or to start or end with an underscore, and one underscore may not follow
directly after another underscore.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  pos2: int # OK
  leftMargin: int # OK
  next_right_margin: int # OK
  _privat: int # illegal
  custom_: int # illegal
  strange__error: int # illegal</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generally we use camel case like <span class="var">leftMargin</span> for variable names, not snake case like
<span class="var">left_margin</span>.</p>
</div>
<div class="paragraph">
<p>Current Nim has the special property that names are case-insensitive and that
underscores are simply ignored by the compiler. The only exception is the first
letter of a name, that letter is case-sensitive. So the names <span class="var">leftMargin</span>, <span class="var">leftmargin</span>
and <span class="var">left_margin</span> are identical for the compiler. But <span class="var">LeftMargin</span> is different to all
the others, because it starts with a capital letter. This may sound a bit strange at
first, but works well in practice. One advantage is, that a library author may use
<span class="var">snake_case</span> in his library for names, but the users of the library can freely decide
if they prefer <span class="var">camelCase</span>. But still, you may think that all this generates confusion.
In practice, it does not, it prevents confusion. Imagine a conventional programming
language, fully case-sensitive and not ignoring underscores: In a larger program, we
may then have names like <span class="var">nextIteration</span> and <span class="var">next_Iteration</span> or <span class="var">keymap</span> and <span class="var">keyMap</span>. What
when both names are visible in current scope, and we type the wrong one. The compiler
may not detect it when types match, but the program may do strange things. Nim would
not allow that similar looking names, as the compiler would regard them as identical
and would complain about a name redefinition.</p>
</div>
<div class="paragraph">
<p>You may ask why the first letter is case-sensitive. That is to allow for user defined
types to use capital type names and then write something like <span class="code">var window:
Window</span>. So we can declare a variable named <span class="var">window</span> of a user defined data type named
<span class="type">Window</span>. That is a common practice.</p>
</div>
<div class="paragraph">
<p>The case insensitivity and the ignoring of underscores may be not the greatest
invention of Nim, but it does not really hurt. The only exception is when we make
bindings to C libraries, where leading or trailing underscores are used, that can
make some renamings necessary.</p>
</div>
<div class="paragraph">
<p>The only minor disadvantage of Nim&#8217;s fuzzy names is when you use tools like grep or
your editor search functionality: You could not be sure if a search for "KdTree"
would give you all results, you would have to try "Kd_Tree" or "KDTree" and potentially
some more variants too. For that task, Nim provides a tool called nimgrep that does a
case- and style-insensitive search. And possibly your editor supports that type of
search also. You can also enforce a consistent naming scheme when you call the
compiler with the command line argument <span class="term">--styleCheck:error</span> or
<span class="term">--styleCheck:hint</span>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Languages like C uses curly braces to mark blocks, while other languages like Pascal
uses begin/end keywords for this purpose. At the same time, blocks are generally
indented by tabs or spaces to make it easier for the programmer to recognize the
extent of the block. This is some redundancy, which is not always helpful&#8201;&#8212;&#8201;block
marks and indentation range can contradict each other and can generate strange bugs.
Like Python or Haskell, Nim does not need additional block markers, the indent level
is enough to mark the block extend for the compiler and the human programmer. This
style looks clean and compact and was used in pseudocode of textbooks for decades
already. Some people still argue that this style is less "safe", as the behavior of
the code depends on invisible white-space. But this is a strange argumentation&#8201;&#8212;&#8201;the white-space is always visible due to the fact that there are visible characters
on the right. Of course, changing the indention of the last line of a block would
affect the behavior of the code. But that change is well visible. And program code
contains many locations where changing one character breaks it. All numeric literals
would suffer from adding a digit or deleting a digit. Or the operators like &#43;&#43; or &#43;=
from C&#8201;&#8212;&#8201;the code may compile well after deleting the leading &#43;, but it would be
wrong. Computer programming is working carefully! Indeed, use of curly braces for
blocks has some advantages, e.g. many editors can highlight such blocks well, the editor
may support jumping back and forth between the braces, and for really large blocks it
may be indeed simpler to discover the whole block range. But practice has shown that
marking blocks with indentation only works fine, most people who have used it for
some time just prefer it.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blocks_scopes_visibility_locality_and_shadowing">Blocks, Scopes, Visibility, Locality and Shadowing</h3>
<div class="paragraph">
<p>Like most other programming languages, Nim has the concept of <span class="ndef">code blocks</span> or scopes.
The body of procedures, functions, iterators and templates, as well as the body of various loop constructs
or code following conditional statements builds an indented block and creates a new scope.
In this new scope we can define variables, named constants, or types
with the <span class="key">var</span>, <span class="key">let</span>, <span class="key">const</span> and <span class="key">type</span> keywords which
are local to this block.
These symbols are only visible in this scope, and
local variables that need storage are actually created when the program
executes the block, and destroyed when the block is left. Well, in principle, and at least for
ordinary stack allocated value variables, for references and pointer
variables, things are a bit more complicated, we will discuss that in more
detail when we introduce references.
Here we have used the term code block, to clearly separate them from the <span class="key">const</span>, <span class="key">var</span>,
<span class="key">type</span> and <span class="key">import</span> sections which are a different form of indented blocks.
Remember that the compiler processes our program code from the top to the bottom, so
we have always to define symbols before we can actually use them.
When we define an entity
in a code block, and a symbol with that name was already declared before
outside this block, then that symbol is shadowed, that is the prior
declaration gets temporary invisible.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc doSomething =
  type NumType = int
  const Seven = 7
  var a: NumType = Seven
  var b: bool = true
  if b:
    echo a, ' ', b # variables of outer scope are visible
    var a, sum: float # now outer a is shadowed
    a = 2.0
    sum = a * a + 1
    echo a, ' ', sum # local data only visible in if block

  echo a # initial int variable with value 7 become visible again

doSomething()</code></pre>
</div>
</div>
<div class="paragraph">
<p>While we have not officially introduced procedures as units
to structure our program code yet, we have put the above code
this time by intend into the body of a <span class="proc">proc</span> called <span class="func">doSomething()</span>.</p>
</div>
<div class="paragraph">
<p>This way, we can guarantee that the two variables <span class="var">a</span> and <span class="var">b</span> defined
in that <span class="proc">proc</span> are really stack allocated. Actually in real life programs
nearly all the program code is embedded in <span class="proc">procs</span>. We will discuss
the peculiarity of global code later. In the <span class="proc">proc</span> body from above the
two variables <span class="var">a</span> and <span class="var">b</span> are local to the <span class="proc">proc</span> <span class="func">doSomething()</span>&#8201;&#8212;&#8201;they are
created on the stack when the procedure is called, that is when we ask
to start it execution by a statement like <span class="func">doSomething()</span>. These two
variables are never visible in code outside this <span class="proc">proc</span>, and the
storage for these two variables is automatically released when execution
of that procedure ends, in this case when the last line of the <span class="proc">proc</span> is reached.
In the body of the <span class="proc">proc</span> we define although a new custom type and a named constant&#8201;&#8212;&#8201;just to show that it is possible. Both symbols are also local to this <span class="proc">proc</span> and invisible outside.</p>
</div>
<div class="paragraph">
<p>The indented block following the <span class="code">if b:</span> statement is sometimes called an <span class="ndef">"if then"</span> block
or just <span class="key">if</span> block&#8201;&#8212;&#8201;in that block
we define
two other variables called <span class="var">a</span> and <span class="var">sum</span> of <span class="type">float</span> type, which are also
stack allocated.
If these two variables are already allocated when the
proc starts its execution, or only when the <span class="ndef">then</span> block following the <span class="key">if</span> statements
is executed, is actually an implementation detail. As the variable <span class="var">a</span> of <span class="type">float</span> type in the
<span class="key">if</span> then block has the same name as the outer variable of <span class="type">int</span> type, that integer variable
is shadowed in the <span class="key">if</span> block&#8201;&#8212;&#8201;the outer value gets temporary invisible
as soon as the new symbol is declared.
Other symbols of outer scopes remain visible.
In the <span class="ndef">if then block</span> as well as in most other indented code blocks we could also define
named constants or custom types, these would be visible only in this block.
Indented code blocks can be nested&#8201;&#8212;&#8201;in one block we can have more indented block, for which all
declared symbols are again local and invisible outside.
The last <span class="func">echo()</span> statement in our code example from above is already below the <span class="ndef">if then
block</span>, so the initial variable a of integer type becomes again visible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_global_code">Global code</h3>
<div class="paragraph">
<p>In the introducing sections of the book, we have generally used program
code at a global level, not embedded in a <span class="proc">proc</span> body.
We did that for simplicity and as we had not already introduced <span class="proc">procs</span>.
Global code is sometimes used in small scripts or for
special purposes, like program initialization. But for larger
programs, most of the code is typically grouped in procedures.
For variables defined in global code it is not that well-defined
where they are stored, it may depend on the actual Nim compiler implementation
and the compiler backend. The performance of global code can be
worse than code enclosed in <span class="proc">proc</span> bodies, so when performance maters we should
put our code in <span class="proc">procs</span>. One reason for the not optimal performance of global code is, that
global variables are not located on the stack, but in the global BSS segment of the program,
and that the backend can not optimize global code that well, e.g. global variables
may not be cached in CPU registers. Note that variables that have to exist and keep it value
for the whole runtime of the program, and not only for the duration of the execution of
a single <span class="proc">proc</span>, has to be defined as global. The same holds obviously for global variables that
are used from code of different <span class="proc">procs</span>, like the stdout and stdin variables of the <span class="mod">system</span> module.
An alternative to the use of global variables when a variable used in a <span class="proc">proc</span> should keep its value
between different <span class="proc">proc</span> calls is to attach the {.global.} pragma to a <span class="proc">proc</span> local variable.
This way that variable is still only visible in that <span class="proc">proc</span> where the variable is declared, but
the variable is stored in the BSS segment instead on the stack and so its value is preserved
between <span class="proc">proc</span> calls.</p>
</div>
<div class="paragraph">
<p>Note that structured named constants, e.g. constant strings, are stored also in the BSS
segment, even when they are only defined local to a <span class="proc">proc</span>. So large structured constants
can increase the executable size, as the BSS segment is a part of the program executable.</p>
</div>
</div>
<div class="sect2">
<h3 id="_white_space_punctuation_and_operators">White space, punctuation and operators</h3>
<div class="paragraph">
<p>The space character with decimal ASCII value <span class="lit">32</span> is used in Nim program code
to indent code blocks and to separate different symbols from each other. Nim&#8217;s keywords
are always separated with leading and trailing white-space from other symbols, while
other symbols are most often separated by punctuation and an additional optional space character.
Whenever the syntax allows a space, we can also insert multiple spaces or a comment
enclosed in #[ ]# in the source code. Tabulator characters are not allowed in the Nim source code, but we
can use them in comments and of course in string literals. We mentioned already,
that spaces can make a difference how operators or function parameters are handled.
In expressions like <span class="code">a&#43;b</span> or <span class="code">a &#43; b</span> the <span class="op">&#43;</span> operator is regarded as an infix operator, but
in <span class="code">a &#43; -b</span> the minus sign is regarded as an unary operator bound to <span class="var">b</span>.
This way asymmetric expressions like <span class="code">a &#43;b</span> or <span class="code">a &lt;b</span> would be invalid,
as the operators are interpreted as unary ones attached to <span class="var">b</span>, and then there
is no infix operator between the two variables.
A <span class="proc">proc</span> call like
<span class="code">echo(1, 2)</span> is interpreted as a call of <span class="func">echo()</span> with two integer literal arguments, while
a call like <span class="code">echo (1, 2)</span> with a space after the <span class="proc">proc</span> name is interpreted in command invocation syntax as a call with a
tuple argument. While in C code it is not uncommon to always insert a space
between the function name and its parameter list, we should avoid that in Nim for the described reason.
We will learn more about <span class="proc">proc</span> calls and the tuple data type later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_operators">Operators</h3>
<div class="paragraph">
<p>Nim uses the following punctuation characters as operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=, +, -, *, /, &lt;, &gt;, @, $, ~, &amp;, %, |, !, ?, ^, ., :, \</pre>
</div>
</div>
<div class="paragraph">
<p>These symbols can be used as single entities or in combination, and we can
define our own operators or redefine existing operators.
All these symbols can be used as infix operators between two arguments,
or as unary prefix operators, but Nim does not support unary postfix
operators, so a notation like <span class="code">i&#43;&#43;</span> as known from the C language is not possible in Nim.
There exists a few combinations
of these punctuation characters that have a special meaning, we will
learn more about that and how we can define our own operators later in the book.</p>
</div>
<div class="paragraph">
<p>In Nim, these keywords are also used as operators:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>and, or, not, xor, shl, shr, div, mod, in, notin, is, isnot, of, as, from.</pre>
</div>
</div>
<div class="paragraph">
<p>Operators have different priorities, e.g. <span class="op">*</span> and <span class="op">/</span> have a higher
priority than <span class="op">&#43;</span> and <span class="op">-</span>. In most cases, the priority is just as we would
expect, maybe with a few exceptions. If we are unsure, we can group terms with
brackets, or consult the compiler manual for details.</p>
</div>
<div class="paragraph">
<p>Since version 1.6 Nim also allows to define and use a few Unicode operators, but these
are still considered experimental. For details, you should consult the compiler manual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_order_of_execution">Order of Execution</h3>
<div class="paragraph">
<p>Global program code or code in called <span class="proc">procs</span> is generally executed from top to the
bottom and from left to the right, as long as control structures do not enforce a different order.
To demonstrate this, we use here a set of four different <span class="proc">procs</span>, which contain an echo() statement each, and
return a numeric expression. Well, we have not yet formally introduced procedures, so if you should
feel too uncomfortable with the code below, just skip this section for now and come back when you have read the
section about <span class="proc">procs</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc a(i: int): int =
  echo "a"
  i * 2

proc b(i: int): int =
  echo "b"
  i * i

proc c(i: int): int =
  echo "c"
  i * i * i

proc d(i: int): int =
  echo "d"
  i + 1

echo a(1); echo b(1)
echo b(2) + d(c(3)) # (2 * 2) + ((3*3*3) + 1)
echo "--"
echo a(1) &lt; 0 and b(1) &gt; 0
echo a(1) &gt; 0 or b(1) &gt; 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should be no real surprise, that the first three echo() statements produce this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a
2
b
1
b
c
d
32</pre>
</div>
</div>
<div class="paragraph">
<p>For the term <span class="code">d(c(3))</span> it is obvious that the inner expression c(3) has
to be evaluated first, before that result can be used to call <span class="proc">proc</span> <span class="func">d()</span>.</p>
</div>
<div class="paragraph">
<p>The last two lines demonstrate the so called short-cut-evaluation for expressions
with the boolean <span class="op">and</span> or <span class="op">or</span> operators. As the expression <span class="code">a() and b()</span> is always <span class="lit">false</span>
when <span class="func">a()</span> is <span class="lit">false</span>, in this case <span class="func">b()</span> has not to be evaluated at all. In a similar way, as
the expression <span class="code">a() or b()</span> is always <span class="lit">true</span> when <span class="func">a()</span> is <span class="lit">true</span>, for that case <span class="func">b()</span> has not to be evaluated at all.
So in the last two lines of above code <span class="func">b()</span> is never called at all, and the output is just</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a
false
a
true</pre>
</div>
</div>
<div class="paragraph">
<p>Note that in Nim as in most other programming languages the assignment operator <span class="op">=</span> behaves
different compared to ordinary operators like <span class="op">&#43;</span> or <span class="op">*</span>, as in assignments like <span class="code">let a = b &#43; c()</span>
obviously the right side has to be evaluated before the result can be actually assigned to variable <span class="var">a</span>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_control_structures">Control Structures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Larger computer programs generally consists not only of code that is executed linearly, but contain
code for conditional or repeated execution.</p>
</div>
<div class="paragraph">
<p>The most important control structures of Nim are the <span class="key">if</span> statement for conditional
execution, the related <span class="key">case</span> statement and the <span class="key">while</span> and <span class="key">for</span> loops for repetitions.
All these statements controls the actual program execution at program runtime. Syntactically very similar to the <span class="key">if</span>
statement is Nim&#8217;s <span class="key">when</span> statement, which is already evaluated at compile time, and can be
used to adapt our program code for various operating system or to compile our code with special
options, e.g. for debugging or testing purposes.</p>
</div>
<div class="paragraph">
<p>All these control structures can be nested in arbitrary ways, so we can have in one <span class="key">if</span> branch
other <span class="key">if</span> conditions or <span class="key">while</span> loops, and in <span class="key">while</span> loops again other control structures
including other loops.</p>
</div>
<div class="sect2">
<h3 id="_if_statement_and_if_expression">If Statement and If Expression</h3>
<div class="paragraph">
<p>The <span class="key">if</span> statement with multiple optional <span class="key">elif</span> branches and an optional <span class="key">else</span> branch evaluates a sequence of
boolean conditions at program runtime. As soon as one condition evaluates as true the corresponding statement
block is executed, and after that the program execution continues after the whole <span class="key">if</span>
construct. That is, at most one branch is executed. If none of the conditions after
the <span class="key">if</span> or <span class="key">elif</span> keywords evaluates to <span class="lit">true</span>, then the <span class="key">else</span> branch is executed if it
exists. A complete <span class="key">if</span> statement consists of one <span class="key">if</span> condition, an arbitrary number of <span class="key">elif</span>
conditions and one optional <span class="key">else</span> part:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">if condition1:
  statement1a
  statement1b
  ...
elif condition2:
  statement2a
  statement2b
  ...
elif condition3:
  statement3a
  statement3b
  ...
elif ...:
  ...
else:
  statementa
  statementb
  ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most simple form of an if statement is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">if condition:
  statement</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">if age &gt; 17:
  echo "you may drink and smoke, but better avoid it!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the branches are indented by spaces, we use two spaces generally, but
other numbers work as well. And note that it is <span class="key">elif</span>, not elsif like in
Ruby, and that there is a colon after the condition. Instead of a single statement, we
can use multiple in each branch, all on its own line and all indented in the same way.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>No, the terminating colon is not really necessary for the compiler, the compiler
could determine the end of the condition without it, as the following statement is
indented. But it looks better with colon, the colon makes it for humans easier to
understand the structure of the complete if statement. So the compiler expects the
colons and complains otherwise currently.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>When there is no <span class="key">elif</span> and no <span class="key">else</span> part, then we can also write the conditional
code direct after the colon, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">if age &gt; 17: echo "you may drink and smoke, but better avoid it!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>With an <span class="key">elif</span> and an <span class="key">else</span> branch, the example from above may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var age: int = 7
if age == 1:
  echo "you are really too young to drive"
elif age &lt; 6:
  echo "you may drive a kids car"
elif age &gt; 17 and age &lt; 75:
  echo "you can drive a car"
else:
  echo "drive carefully"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we perform the age tests in ascending order&#8201;&#8212;&#8201;it would not make much sense
to first test for a condition <span class="code">age &lt; 6</span>, and later to test for <span class="code">age &lt; 4</span>, as the <span class="key">if</span> statement
is evaluated from top to bottom, and as soon as one condition is evaluated as <span class="lit">true</span>, that branch
is executed and then the program execution continues after the whole <span class="key">if</span> construct.
So a later test <span class="code">age &lt; 4</span> would be useless, when that condition is already covered by a prior test <span class="code">age &lt; 6</span>.</p>
</div>
<div class="paragraph">
<p>As the various conditions of the if statement are processed from top to bottom until one condition
evaluates to true, it can be a good idea to put the most likely conditions first for optional performance, as
then the unlikely conditions have not to be evaluated in most cases. Another strategy for larger if/elif
constructs is to put the most simple and fast tests to the top when possible.</p>
</div>
<div class="paragraph">
<p>We can also have if/else expressions which returns a value like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var speed: float = if time &gt; 0: delta / time else: 0.0 # prevent div by zero error</code></pre>
</div>
</div>
<div class="paragraph">
<p>In C for a similar construct, the ternary ? operator is used.</p>
</div>
<div class="paragraph">
<p>In languages like C or Ruby the assignment operator "=" is an expression which returns
the assigned value, so in C we can write code like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">while (char c = getChar()) { process(c)}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In Nim the assignment operator is not an expression with a result, but we can group
multiple statements in round brackets separated by semicolon, and when the last
statement in the bracket is an expression, then the whole bracket has the same value.
So we can use conditional terms like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">while (let c = getChar(); c != '\0'):
  process(c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we declare a variable in this way using the <span class="key">var</span> or <span class="key">let</span> keyword, then that variable
is only visible in the bracket expression itself and in the following indented block.</p>
</div>
<div class="paragraph">
<p>Note that if-expressions must always return a well-defined value, so they must
always contain an <span class="key">else</span> branch. A plain <span class="key">if</span>, without an <span class="key">else</span>, or an if/elif without an <span class="key">else</span> does not
work. And as Nim is a statically typed language and all variables have a strictly well-defined
type, the if-expression must return the same type for all branches!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a: int
var b: bool
a = if b: 1 elif a &gt; 0: 7 else: 0 # OK
a = if b: 1 elif a &gt; 0: 7 # invalid
a = if b: 1 # invalid
a = if b: 1 else: 0.0 # invalid, different types!</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_when_statement">The When Statement</h3>
<div class="paragraph">
<p>The <span class="key">when</span> statement is syntactically very similar to the <span class="key">if</span> statement,
but while all the boolean conditions are evaluated during the program run time for the
<span class="key">if</span> statement, for the <span class="key">when</span> construct all the when/elif/else conditions have to be
constant expressions and are already evaluated at compile time.
In ordinary program code, the <span class="key">when</span> statement is not used that often, but it is
useful when we write bindings to C libraries and low level code.
Common use cases for the <span class="key">when</span> statement are the <span class="lit">isMainModule</span> condition test and the
test for defined symbols, like <span class="code">defined(windows)</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">when not defined(gcDestructors):
  echo "You may try to compile your code with option --gc:arc"
when isMainModule:
  doAllTheTests()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value <span class="lit">isMainModule</span> is only true for a source code file, when that file is compiled
directly as main module, that is when it is not indirectly compiled because it is imported by other modules.
This way we can include easily test code to our library modules&#8201;&#8212;&#8201;that test code is ignored when
the module is used as library, but active when we compile the module direct for testing.</p>
</div>
<div class="paragraph">
<p>A <span class="code">when defined()</span> construct can be used to test for predefined or our own custom options, e.g. we may
give the optional option <span class="-term">-d:gintroDebug</span> to the compiler and test in the code of that module
for this option, like <span class="code">when defined(gintroDebug):</span>.</p>
</div>
<div class="paragraph">
<p>One difference of the <span class="key">when</span> to the <span class="key">if</span> statement is, that the "then" branches do not open a new scope, so
variables which we define there are still visible after the construct has been processed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">when sizeof(int) == 2:
  var intSize = 2
  echo "running on a 16 bit system!"
elif sizeof(int) == 4:
  var intSize = 4
  echo "running on a 32 bit system!"
elif sizeof(int) == 8:
  var intSize = 8
  echo "running on a 64 bit system!"
else:
  echo "cannot happen!"

echo intSize # variable is visible here!</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another peculiarity of the <span class="key">when</span> statement is, that it can be used inside object definitions&#8201;&#8212;&#8201;we will
show an example for that in a later section of the book when we introduce the <span class="key">object</span>  data type.
In the same way as the <span class="key">if</span> construct, <span class="key">when</span> can also be used as an expression.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_case_statement">The Case Statement</h3>
<div class="paragraph">
<p>The case statement is not used that often, but it can be useful when we have many
similar conditions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">case inputChar
of 'x': deleteWord()
of 'v': pastWord()
of 'q', 'e': quitProgram()
else: echo "unknown keycode"</code></pre>
</div>
</div>
<div class="paragraph">
<p>To enable optimizations, the case construct has some restrictions compared to a more
flexible if/elif statement:</p>
</div>
<div class="paragraph">
<p>The variable after the <span class="term">case</span> keyword must have a so-called ordinal type like
int, char or string, while float would not work. And the values after each
<span class="term">of</span> keyword must be constant, that is a single constant value, multiple
constant values or a constant range like <span class="term">'a' .. 'd'</span> for the 4 first lower
case letters. Of course, these constants must have a type compatible to the type of
the variable after the case keyword. A case statement must cover all possible cases,
so most of the time an else branch is necessary.</p>
</div>
<div class="paragraph">
<p>For Nim version 1.6 the case statement can contain also optional elif branches
with arbitrary boolean conditions. This was not the case in the wirthian languages
Pascal, Modula and Oberon, and makes Nim&#8217;s case construct now very similar
to the ordinary if/elif/else.</p>
</div>
<div class="paragraph">
<p>Unless the similar switch statement in C the case statement needs no break after each
branch. If a condition after an <span class="term">of</span> keyword is true, then the corresponding
statement or statement sequence is executed, and after that, program execution
continues after the whole case construct.</p>
</div>
<div class="paragraph">
<p>The case construct can also be used as an expression like in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var j: int
var i: int =
  case j
    of 0 .. 3: 1
    of 4, 5: 2
    of 9: 7
    else: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, an else is necessary to cover all cases. And as you see, we can also indent the
block after the case keyword if we want.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_while_loop">The While Loop</h3>
<div class="paragraph">
<p>The <span class="op">while</span> loop is used when we want to do conditional repetitions, that is,
if we want to check a condition and want to execute a block of statements only as
long, as the condition is <span class="lit">true</span>. If the condition is <span class="lit">false</span> in advance, or becomes <span class="false">false</span>
after some repetitions, then the program execution proceeds after the indented loop body block.</p>
</div>
<div class="paragraph">
<p>A basic <span class="key">while</span> loop has this shape:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>while condition:
  statement1
  statementN
firstStatementAfterTheWhileLoop</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var repetitions = 3
while repetitions &gt; 0:
  echo "Nim is easy!"
  repetitions = repetitions - 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>That loop would print the message three times. Like the condition in the <span class="key">if</span> clause,
the condition is terminated with a colon. Note that the condition must change during
execution of the loop, otherwise, when the condition is <span class="lit">true</span> for the first iteration,
it would remain <span class="lit">true</span> and the loop would never terminate. We decrease the loop counter
<span class="var">repetitions</span> in the loop, so at some point the condition will become <span class="lit">false</span>, and the
loop will terminate and program execution will continue with the first statement
after the loop body. Note how we decrement the loop counter: The right site of the
assignment operator is evaluated, after that is done, the new value is assigned to
the counter.</p>
</div>
<div class="paragraph">
<p>There exists two rarely used variants of a while loop: the loop body can contain a
<span class="key">break</span> or a <span class="key">continue</span> statement, which each consists only of this
single keyword. A <span class="key">break</span> in the body stops execution of the loop immediately and
continues execution after the loop body. And a <span class="key">continue</span> statement in the body skips
the following statements in the body and starts at the top again, the <span class="key">while</span> condition
is evaluated again.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var input = ""
while input != "quit":
  input = readLine(stdin)
  if input == "":
    continue
  if input == "exit":
    break</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code used the <span class="op">==</span> and the <span class="op">!=</span> operators. The <span class="op">==</span> operator does a
test for equality, and <span class="op">!=</span> test for inequality. Both operator work for most data types
like integer, floats, characters and strings. The literal value of an empty string is
written <span class="lit">""</span>. In line 2 we test if the variable named <span class="var">input</span> has not the value <span class="lit">"quit"</span>,
and in line 4 we test if that variable is empty, that it contains no text at all.</p>
</div>
<div class="paragraph">
<p>Using of <span class="key">break</span> and <span class="key">continue</span> destroys the expected flow in loops, it can make
understanding loops harder. So we generally avoid their use, but sometimes <span class="key">break</span> or
<span class="key">continue</span> are really helpful. For example, when an unexpected error occurs, maybe by
invalid user input.</p>
</div>
<div class="paragraph">
<p>There in no repeat loop as in Pascal in Nim, which does the first check at the end of
the loop when it was executed already for the first time. Repeat loops are not used
that much in Pascal, and they are some sort of dangerous, because they check the
condition after the first execution of the body, so potentially the body is executed with
invalid data for the first iteration. Later, we will see how we can use Nim macros to
extend Nim by a repeat loop that can be used as it would be part of Nim core
functionality.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_block_statement">The Block Statement</h3>
<div class="paragraph">
<p>The block statement can be used to create a new indented block, which
creates a new scope, in the same way as a <span class="code">when true:</span> statement would do:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>block: # create a new scope
  var i = 7
echo i # would not compile, as variable i is undefined</pre>
</div>
</div>
<div class="paragraph">
<p>Blocks can be useful to structure large code segments, when there are no better ways, as
splitting the code in multiple <span class="proc">procs</span>, available. For testing purposes, blocks can be useful
too, to keep the symbol in a local scope. But actually most useful are blocks, when the blocks
get attached names, and we use the break statement in a <span class="key">while</span> or <span class="key">for</span> loop to <span class="key">break</span> out
of a nested loop:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>let names = ["Nim", "Julia", "?", "Rust"]
block check:
  for n in names:
    for c in n:
      if c notin {'a' .. 'z', 'A' .. 'Z' }:
        echo "invalid character in name"
        break check
echo "we continue"</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="code">break check</span> statement would immediately leave the nested loops and
continue with the first statement after the block, which is the last line
in the code segment above. Using <span class="key">break</span> in such a way is not very nice, as
it may make it harder to understand the code structure, but sometimes
it can be very useful.</p>
</div>
</div>
<div class="sect2">
<h3 id="_for_loops_and_iterators">For Loops and Iterators</h3>
<div class="paragraph">
<p>These are very useful and important in Nim and other programming languages. <span class="op">For</span> loops are most
often used to iterate over containers or collections. We have not discussed the
important <span class="type">array</span> and <span class="type">seq</span> containers yet, but we know already the <span class="type">string</span> container.</p>
</div>
<div class="paragraph">
<p>A <span class="type">string</span> contains characters, the characters are numbered starting with <span class="lit">0</span>, and we can
access single characters of a <span class="type">string</span> with the subscript operator <span class="op">[]</span>, which
gets the position of the desired character as argument. So we could print the single
characters of a <span class="type">string</span>, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  s = "Nim is not always that easy?"
pos = 0
while s[pos] != '?':
  echo "--&gt;", s[pos]
  inc(pos)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is obvious that the <span class="var">pos</span> variable is some sort of annoying here&#8201;&#8212;&#8201;we want to
process all the characters in the <span class="type">string</span> in sequence, so why would we have to use a
position variable to do that. And this way is susceptible to errors, maybe we forget
increasing the <span class="var">pos</span> variable in the loop body. So most modern languages provide us
with iterators for this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  s = "Nim is not always that easy?"
for ch in items(s):
  echo "--&gt;", ch</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is obviously shorter. The <span class="key">for</span> construct may appear a bit strange, and it is
indeed, but it is a common way to write iterators, it is used in Python too. Ruby
uses something like s.each{|ch| &#8230;&#8203;} instead.</p>
</div>
<div class="paragraph">
<p><span class="key">For</span> loops in Nim iterates over containers or collections, and pics each element in
sequence in this process. The variable after the <span class="key">for</span> keyword is used to access or to
reference the single elements. That variable has automatically the right type, which
is the type of the elements in the container, and get in each iteration the value of
the next element in the container, starting by the first element in the container and
stopping when there is no element left. <span class="func">Items()</span> is here the actual iterator,
which allows us to access the individual characters in sequence. It exists the
convention in Nim that an <span class="func">items()</span> iterator is automatically called in a <span class="key">for</span> loop
construct when no iterator name is explicitly given, so we could also write shorter
<span class="code">for ch in s:</span> in this use case.</p>
</div>
<div class="paragraph">
<p>You may recognize that the output of the above <span class="key">for</span> loop is not identical to the
output of the previous <span class="key">while</span> loop. The <span class="key">while</span> loop stops when the last character,
that is <span class="lit">'?'</span>, is reached, while the <span class="key">for</span> loop processes this last character still. That
is intended for the <span class="key">for</span> loop, its general purpose is to process all the elements in
containers or collections.</p>
</div>
<div class="paragraph">
<p>The above <span class="key">for</span> loop does a read access to the string, that is, we get basically a copy
of each character, and we can not modify the actual <span class="type">string</span> in this way. When we want
to modify the <span class="type">string</span>, there is a variant available.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  s = "Nim is not always that easy?"
for ch in mitems(s):
  if ch == '?':
    ch = '!'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we use <span class="func">mitems()</span> instead of the plain <span class="func">items()</span>, the leading "m" stands for mutable.
In the loop body, we can assign different values to the actual content.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_objects">Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have worked with basic data types like numbers, characters and strings already.
Often it makes sense to join some variables of these basic data types to more complex
entities. Assume you want to build an online store to sell computers, and you want to
build a database for them. The database should contain the most important data of
each device type, like type of CPU, RAM and SSD size, power consumption,
manufacturer, quantity available, and actual selling price.</p>
</div>
<div class="paragraph">
<p>We can create a custom object data type with fields containing the desired data for
this purpose:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Computer = object
    manufacturer: string
    cpu: string
    powerConsumption: float
    ram: int # GB
    ssd: int # GB
    quantity: int
    price: float</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have to use the <span class="key">type</span> keyword to tell the compiler that we want to define
a new custom type. Writing the <span class="key">type</span> keyword on its own line begins a type section
where we can declare one or more custom data types. All type declarations in a type
section must be indented. In the next line we write our type name, an equal sign and
the keyword <span class="key">object</span>. That indicates that we want to declare a new object type
named Computer. Here Computer is a type name, in Nim we use the convention that user
defined type names start with a capital letter. In the following indented block we
specify the desired fields, each line contains the name of a field, and a colon
followed by the needed data type. That is similar like a plain variable declaration.</p>
</div>
<div class="paragraph">
<p>Objects in Nim are similar to structs in C. Unlike classes in Java Nim objects
contain only the fields, sometimes also called member variables, but no procedures,
functions or methods, and no initializers or destructors as in C++. In Nim we keep
the data objects, and the procedures, functions, methods and also optional
initializers and destructors that work with that data objects separated.</p>
</div>
<div class="paragraph">
<p>Now that we have defined our own new object type, we can declare variables of that
type and store content in its fields.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  computer: Computer

computer.manufacturer = "bananas"
computer.cpu = "x7"
computer.powerConsumption = 17
computer.ram = 32
computer.ssd = 1024
computer.quantity = 3
computer.price = 499.99</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course in real applications we would fill the fields not in this way, but we would
maybe read the data from a file, from a terminal or maybe from a graphical user
interface.</p>
</div>
<div class="paragraph">
<p>It may look a bit ugly that we have to write <span class="var">computer.</span> before each field
when we access the fields. Indeed, in recent Nim versions that is not necessary, you
may use the <span class="code">with</span> construct now instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/with
var
  computer: Computer
with computer:
	manufacturer = "bananas"
	cpu = "x7"
	powerConsumption = 17
	ram = 32
	ssd = 1024
	quantity = 3
	price = 499.99</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use the fields like ordinary variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">computer.quantity = computer.quantity - 1 # we sold one piece
echo computer.quantity</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you already know, the right side of the assignment operator is evaluated first,
then the result is stored in the variable on the left side. But we can also just
write <span class="code">computer.quantity -= 1</span> or <span class="code">dec(computer.quantity)</span>.</p>
</div>
<div class="paragraph">
<p>Generally a computer store would offer many different types of computers, so it would
make sense to store all the different devices in a container like a sequence, called
short <span class="type">seq</span> in Nim.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_arrays_and_sequences">Arrays and Sequences</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sequences and arrays are homogeneous containers, they can contain multiple other
elements of the same data type, while a plain variable like a <span class="type">float</span> or an <span class="type">int</span> only
contains a single value. In some way, we could regard <span class="key">objects</span> also as containers,
because objects contain multiple fields. The same holds for <span class="type">tuples</span>&#8201;&#8212;&#8201;tuples are a
very simple, restricted form of objects and also contain fields. But more typical
container data types are the built-in arrays and sequences, or for example hash
tables, which are provided by the Nim standard library. Arrays, sequences and hash
tables can contain multiple elements, but all elements must have the same data type,
which we call the base type.<sup class="footnote">[<a id="_footnoteref_22" class="footnote" href="#_footnotedef_22" title="View footnote.">22</a>]</sup> The data type of the base type is not restricted, it can be even
again array or sequence types, so we can build multidimensional matrices in this way.
Arrays have a fixed, predefined size, they can not grow or shrink during runtime of
our program. Sequences and hash tables can grow and shrink.</p>
</div>
<div class="paragraph">
<p>Arrays and sequences appear very similar, a sequence appears even more powerful
because it can change its size, that is the number of elements that it contains, at
runtime, while an array has a fixed size. So why do we have arrays at all? The reason
is mostly efficiency and performance. An array is a plain block of memory in the RAM
of the computer, which can be accessed very fast and needs not much care by the
runtime system. Sequences take much more effort, especially when we add elements and
the sequence has to grow. When we create sequences, we can specify how many elements
should fit in it at least, and the runtime system reserves a block of RAM of the
appropriate size. But when our estimation was too small, and we want to append or
insert even more elements, then the runtime system may have to allocate a larger
block of memory first, copy the already existing elements to the new location, and
then release the old, now unnecessary memory block. And this is a relative slow
operation. The reason why this process can be necessary is, that the initially
allocated memory block may not increase in size because the neighborhood in the RAM
is already occupied by other data. Now let us see what we can do with arrays and
sequences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  a: array[8, int]
  v = 1
for el in mitems(a):
  el = v
  inc(v)
for el in mitems(a)
  el = el * el
for square in a:
  echo square</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the second line of the code above, we declare a variable named <span class="var">a</span> of <span class="type">array</span> type&#8201;&#8212;&#8201;we want to use an array with exactly <span class="lit">8</span> elements, and each element should have the
data type <span class="type">int</span>. To declare a variable of <span class="type">array</span> data type we use the <span class="key">array</span> keyword
followed in square brackets by the number of the elements, and separated by a comma,
the data type of the elements. We can also specify the range of the indices
explicitly by specifying a range like array[0 .. 7, int] or array[-4 .. 3, int]. The
first specification is identical to the one in the above example program, and the second
one would allow us to access array elements with index positions from <span class="lit">-4</span> up to
<span class="lit">3</span>.<sup class="footnote">[<a id="_footnoteref_23" class="footnote" href="#_footnotedef_23" title="View footnote.">23</a>]</sup> or [int, 8].
It may help to remember that for plain variables the data type comes last also like
in var i: int.]</p>
</div>
<div class="paragraph">
<p>The first <span class="key">for</span> loop of the above program fills our <span class="type">array</span>&#8201;&#8212;&#8201;that is, for each of the <span class="lit">8</span>
storage places in the array we fill in some well-defined data. We use the
<span class="func">mitems()</span> iterator here, because we want to modify the content of our <span class="type">array</span>&#8201;&#8212;&#8201;we fill in numbers <span class="lit">1 .. 8</span>. In the next <span class="key">for</span> loop, we square each storage location,
and finally we print the content. In the last <span class="key">for</span> loop we do not modify the content,
so a plain <span class="func">items()</span> instead of <span class="func">mitems()</span> would work, but we already learned that we
have not to write the plain <span class="func">items()</span> at all in this case.</p>
</div>
<div class="paragraph">
<p>Sequences work very similar like arrays, but they can grow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  s: seq[int]
  v = 0
while v &lt; 8:
  inc(v)
  add(s, v)
for el in mitems(s)
  el = el * el
for square in s:
  echo square</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start with an empty <span class="type">seq</span> here, and use the <span class="func">add()</span> procedure to append
elements. After that we can iterate over the <span class="type">seq</span> as we did for the <span class="type">array</span>.</p>
</div>
<div class="paragraph">
<p>In the same way as we access single characters of a <span class="type">string</span> with the subscript
operator <span class="op">[]</span>, we can use that operator to access single elements of an <span class="type">array</span> or a <span class="type">seq</span>, like in a[myPos]. The
slice operator is available for arrays and sequences too and can be used to extract
sub-ranges or to replace multiple elements. As arrays have a fixed length, the slice
operator can only replace elements in arrays, but not remove or insert ranges. The
first element position is generally <span class="lit">0</span> for arrays and sequences. Arrays can even be
defined in a way that the index position starts with an arbitrary value, but that is
not used that often. Whenever you use the subscript or slice operator you have to
ensure that you access only valid positions, that is, positions that really exists.
<span class="var">a[8]</span> or <span class="var">s[8]</span> would be invalid in our above example&#8201;&#8212;&#8201;the array has only places
numbered <span class="lit">0 .. 7</span>, and for the <span class="type">seq</span> we have added <span class="lit">8</span> values which now occupy positions <span class="lit">0
.. 7</span> also, position <span class="lit">8</span> in the <span class="key">seq</span> is still undefined. We would get a runtime error if
we would try to access position <span class="lit">8</span> or above, as well, when we would try to access negative
positions. You might think that an assignment for a <span class="type">seq</span> like <span class="code">s[s.length] = 9</span> is the
same as <span class="code">s.add(9)</span>, but only the <span class="func">add()</span> operation works in this case.</p>
</div>
<div class="paragraph">
<p>Note that in some languages like <span class="ndef">Julia</span> arrays start at position <span class="lit">1</span>.<sup class="footnote">[<a id="_footnoteref_24" class="footnote" href="#_footnotedef_24" title="View footnote.">24</a>]</sup>
Nim arrays can have
an arbitrary integral start position, including negative start positions, but start
position as well as the highest subscript position are determined in the program source
code and can not change at runtime. We say that arrays have fixed compile-time
bounds. Sequences start always at position <span class="lit">0</span>, we can specify an initial size, and we can
always add more elements at runtime.</p>
</div>
<div class="paragraph">
<p>Arrays and sequences allow fast access to its elements: All the elements are stored
in a continues memory block in RAM, and the start location of that memory block is
well known. As all the elements have the same byte size, it is an easy operation to
find the memory location of each element. The compiler uses the start location of the
<span class="type">array</span> or <span class="type">seq</span>, and adds the product of subscript index and element byte size. The
result is the memory location of the desired element, which was selected by the index
used in the subscript operator. When the array should not start at position <span class="lit">0</span>, then
the compiler would have to adjust the index, by subtraction of the well known start
index. This operation takes not much time, but still arrays starting at position <span class="lit">0</span>
may be a bit faster. We said that the compiler has to do a multiplication of index position and
element size&#8201;&#8212;&#8201;that is an integer multiplication, which is very fast. When the
element size is a power of two, then the compiler can even optimize the
multiplication by using a simple shift operation, which may be even faster, depending
on your CPU.</p>
</div>
<div class="paragraph">
<p>It should be not surprising that the internal structure of sequences are a bit more
involved than arrays. Arrays are indeed nothing more than a block of memory,
generally allocated on the stack for local data or allocated in the BSS segment for
global data. Don&#8217;t worry when you have not yet an idea what the stack, the heap and a
BSS segment is, we will learn that soon. The Nim <span class="type">seq</span> data type has a variable size,
so it is clear that it needs not only a storage location for its elements, but also a
counter to store how many elements it currently contains, and another counter how
many it could contain at most. The element counter must be updated when we add or
delete elements, and when the counter tells that there is currently no more space
available for more elements, then a new block of memory must be allocated, and the
existing elements must be copied from the old location into the newly allocated
memory region, before the old memory region can be released.<sup class="footnote">[<a id="_footnoteref_25" class="footnote" href="#_footnotedef_25" title="View footnote.">25</a>]</sup> Due to this additional
effort appending elements to a <span class="type">seq</span> by using the <span class="func">add()</span> procedure is not extremely
fast. You may wonder why we have not to save a size information for arrays. Well
arrays have fixed size, so it is obvious that we never have to adjust something like
a size counter, simple because size would never change. But would we have to save the
desired initial size of the array? Well, in some way yes. But it is a constant value.
During the compile process the compiler can catch some errors already for us&#8201;&#8212;&#8201;when
we have an array as above with size 8, then the compiler would be able already at
compile time to recognize some invalid access to array elements&#8201;&#8212;&#8201;a[9] would be a
compile time error for sure. But at runtime, when we execute our program, access to
not existing index position may occur, for example by constructs like <span class="code">var i = 9; a[i]
= 1</span> when the array is declared as <span class="code">var a: array[8, int]</span>. For catching that type of
error, the compiler has to store the fixed array size somewhere and to check against
that value when an array access by using the subscript operator with a non-constant
argument occurs, as the <span class="var">a[i]</span> above. One related remark: Accessing array elements is
as fast as ordinary variable access when we use a constant value as index, that is a
constant literal or a named constant. The reason for this is, that when the index is
a constant, then the compiler just knows the exact position of that array element in
memory, just as it knows the address of plain variables, so there is no need for
address calculations at runtime. Actually, to access an array element with a given constant index
position, the compiler only has to add a constant value to the current stack pointer, as
arrays are stored on the stack. To access a constant position in a <span class="type">seq</span>, the compiler would
have to add a constant to the base address of the memory block that contains the <span class="type">seq</span> data.</p>
</div>
<div class="paragraph">
<p>We said that appending elements to sequences is not extremely fast&#8201;&#8212;&#8201;indeed, it is a few
times slower than access to an <span class="type">array</span> element by its index using the subscript
operator. So when we know that our <span class="type">seq</span> will have to contain at least an initial
amount of elements, then it can be useful for maximum performance, that we allocate
the <span class="type">seq</span> from the beginning for this size and then fill in the content by use of the
subscript operator instead that we append all the elements one by one. Here is one
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s: seq[int] = newSeq[int](8)
var i: int
while i &lt; 8:
  s[i] = i * i
  inc(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the <span class="func">newSeq()</span> procedure to initialize the sequence for us, the content of the square
brackets tells the <span class="func">newSeq()</span> procedure that we want a sequence with base type <span class="type">int</span>, and
the number <span class="lit">8</span> as argument tells it that the newly created sequence should have <span class="lit">8</span> elements
with default value (0). This procedure is a so-called generic procedure, it needs
additional information, which is the data type that the elements should have. Don&#8217;t
confuse the square bracket in the <span class="func">newSeq[int]()</span> call with the subscript operator <span class="var">a[i]</span>
which we have used for <span class="type">array</span> access, both are completely unrelated. Note that the
initialization of the <span class="type">seq</span> above does not restrict its use in any way, we can still
use it like an uninitialized seq, that is we can use the add() operator to add more
elements, we can insert or delete elements and all that.</p>
</div>
<div class="paragraph">
<p>Deleting elements from an array or from a sequence can be very slow.<sup class="footnote">[<a id="_footnoteref_26" class="footnote" href="#_footnotedef_26" title="View footnote.">26</a>]</sup>
It is slow
when we use the naive approach and move all the elements located after the element that should be removed
one position forward. This would obtain the order in the container, so sometimes this
is the only solution, but of course moving all the entries is expensive for large containers.
Nim&#8217;s standard library provides the <span class="func">delete()</span> function for this order maintaining delete
operation. A much faster way to delete an entry in a <span class="type">seq</span> or <span class="type">array</span> is to remove the last entry
and replace the one that should be deleted with that last entry. This operation moves the last entry
to the front, so order of elements in not maintained. Nim&#8217;s standard library provides the <span class="func">del()</span> function
for this faster, but order changing delete operation. Of course, whenever the order is not important,
we should use <span class="func">del()</span>. The <span class="func">delete()</span> and <span class="func">del()</span> functions are actually only available for sequences, as
arrays have a fixed size&#8201;&#8212;&#8201;but in principle we could do similar operations with arrays as well, we have just to store
the actual used size somewhere.
<sup class="footnote">[<a id="_footnoteref_27" class="footnote" href="#_footnotedef_27" title="View footnote.">27</a>]</sup></p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>In the section about strings we said that strings have value semantic, that is that
an assignment like <span class="code">str1 = str2</span> creates a copy of <span class="var">str2</span> and that after that assignment
<span class="var">str1</span> and <span class="var">str2</span> are fully independent entities&#8201;&#8212;&#8201;modifying one does not change the
content of the other one. Array and sequences behave in the same way, both have value
semantic too. Indeed, arrays are true value types in Nim, as they live on the stack in
the same way as plain variables like integers, floats or characters. Sequences have
a dynamic data buffer which is allocated on the heap, so it would be possible that an
assignment like <span class="code">seq1 = seq2</span> would not copy the data buffer but reuse the old one. In
that case both sequences would be not independent, <span class="var">seq2</span> would be an alias for <span class="var">seq1</span>.
This is called reference semantic, some languages like Ruby behave in this way. But
in Nim arrays, strings and sequences have value semantic, an assignment creates an
independent copy. We will learn more details about reference semantic and the use of
the stack or heap to store data soon when we discuss references to objects.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_some_details">Some details</h3>
<div class="paragraph">
<p>Let us investigate at the end of this section some internal details about arrays and
sequences. Beginners not yet familiar with the concept of pointers should better skip
this subsection, and maybe come back later. We could consult the Nim language manual
or the compiler source code to learn more details about arrays and sequences. Or we
can write some code to test properties and behavior. Let us start investigating an
array:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var a: array[4, uint64]
  echo("Size of array a = ", sizeof(a))
  a[0] = 7
  echo("Value of a[0] = ", a[0])
  echo("Adress of array a   = ", cast[int](addr a))
  echo("Adress of cell a[0] = ", cast[int](addr a[0]))

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run this program, we get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Size of array a = 32
Value of a[0] = 7
Adress of array a   = 140729286557632
Adress of cell a[0] = 140729286557632</pre>
</div>
</div>
<div class="paragraph">
<p>The size of the whole array is 32, as we have 4 elements, each 8 byte in size. And the
address of the array itself as well as the address of its first element is identical.
Remember that the actual address values will be different for each run of our
program, and they may be totally different on different computers, as it is some
random choice of the OS which free memory area is used to run our program. This
result is expected as the array is a plain block of memory stored on the stack. And
indeed the array has copy semantic, when we create a copy called <span class="var">a2</span> and later modify
<span class="var">a</span>, then the content of <span class="var">a2</span> is unchanged. That was not really surprising, so let us
investigate a sequence:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var dummy: int
  var s: seq[int64]
  echo sizeof(seq)
  echo sizeof(s)
  s.add(7)
  echo s[0]
  echo cast[int](addr dummy)
  echo cast[int](addr s)
  echo cast[int](addr s[0])

  var s2 = s
  s[0] = 3
  echo s2[0]

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run above code, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>8
8
7
140732171249104
140732171249112
140463681433696
7</pre>
</div>
</div>
<div class="paragraph">
<p>The first two lines of the output may confuse us, as a size of only 8 bytes may
indicate a plain pointer value on a 64-bit system. Indeed, the sequence is not a large
object that contains size and capacity fields, but only a tiny object that contains a
single pointer to the data storage of that sequence. We know that it is not a plain
pointer or ref by the fact that we can not assign nil or test for nil for sequences.
(But an object which contains only a pointer is basically identically to a plain
pointer, as Nim objects have no overhead as long as we do not use inheritance and
when no padding to word size is needed for tiny fields like int8.) Capacity and
length are stored also in the memory block that is allocated for the elements, as long
as the sequence is not empty. So empty sequences don&#8217;t waste much memory when we have
a lot of them, i.e. arrays or sequences of sequences (matrices). We use the dummy
int variable in the code above as we know that plain ints are stored on the stack,
and when we compare the addresses of our dummy variable and our sequence, then we see
that the addresses indicate close neighborhood, so the <span class="type">seq</span> object is also stored on
the stack. But the address of <span class="var">s[0]</span> is very different, indicating that the data buffer
is stored in a different memory region, which is the heap. If we would continuously
add elements to the <span class="type">seq</span>, then the address <span class="var">s[0]</span> would change at some point, while the
address of <span class="var">s</span> would always remain unchanged. That is because the capacity of the data
buffer would become exhausted at some point and a new data buffer with a different
address would be used. Finally, we see again that the sequence has also copy semantic,
as the content of the copy <span class="var">s2</span> remains unchanged when we modify the initial sequence
<span class="var">s</span>. We could try to discover some more details of the internals of Nim&#8217;s sequences,
i.e. we could try to detect where the capacity and size is stored. But that are
internal details which should not really interest us and which may change with new
compiler version or different compilers.</p>
</div>
<div class="paragraph">
<p>But OK, you may still not believe what we said, so let us go one layer deeper. We
strongly assume that a <span class="type">seq</span> needs a length and a capacity field. And we assume that
its data type should be <span class="type">int</span>. We said that both fields should be adjacent to the
buffer of the seq elements, that means at the start or at the end. Obviously we can
not access the end as long as we do not know the capacity, so capacity field should
be at the start, and then length field also. We may find out which one is which by
observing the content when seq grows. So let us write some code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var
    s: seq[int64] = newSeqOfCap[int64](4)
    s2: seq[int64]
    p: ptr int

  var h = cast[ptr int](addr s2) # prove that an uninitialized seq is indeed a pointer with nil (0) value
  echo cast[int](h) # address on stack
  echo h[] # value (0)
  echo ""

  for i in 0 .. 8:
    s.add(i)
    echo cast[int](addr s[0])
    p = cast[ptr int](cast[int](addr s[0]) - 8) # capacity
    echo p[]
    p = cast[ptr int](cast[int](addr s[0]) - 16) # length
    echo p[]

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output when we run the program is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>140725732630192
0

140251431497824
4
1
140251431497824
4
2
140251431497824
4
3
140251431497824
4
4
140251431506016
8
5
140251431506016
8
6
140251431506016
8
7
140251431506016
8
8
140251431510112
16
9</pre>
</div>
</div>
<div class="paragraph">
<p>Don&#8217;t worry when you do not understand the program and the output yet. You will
better understand it when you have read the sections about references, pointers and
memory management. The first two output lines show us that an uninitialized <span class="type">seq</span> is
just a pointer pointing to <span class="lit">nil</span>. And the remaining output lines show us the address of
the first <span class="type">seq</span> element, the capacity and the length of the <span class="type">seq</span> whenever we add an
element. We started with a <span class="type">seq</span> with initial capacity of <span class="lit">4</span>, so address and capacity
is constant while we add the first 4 elements. Then the capacity of the allocated
buffer is exhausted. A new buffer with different address and doubled capacity is
allocated, the already contained elements are silently copied to the start of the new
buffer and so on.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_slices">Slices</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Nim slices are objects of type <span class="type">Slice</span> that contain a lower <span class="ndef">a</span> and an
upper bound <span class="ndef">b</span>. The <span class="mod">system</span> module defines also the <span class="type">HSlice</span> object called
heterogeneous slice for which the lover and upper bound can have different data types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  HSlice*[T, U] = object   ## "Heterogeneous" slice type.
    a*: T                  ## The lower bound (inclusive).
    b*: U                  ## The upper bound (inclusive).
  Slice*[T] = HSlice[T, T] ## An alias for `HSlice[T, T]`.</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the <span class="type">Slice</span> and <span class="type">Slice</span> objects are not a built-in type, their Names
start with capital letters. Slices are not used that often directly, but mostly indirectly with
the range operator, e.g. to access sub-ranges of strings and other containers.</p>
</div>
<div class="paragraph">
<p>One example for its direct use from the
<span class="mod">system</span> module is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc contains*[U, V, W](s: HSlice[U, V], value: W): bool {.noSideEffect, inline.} =
  result = s.a &lt;= value and value &lt;= s.b</code></pre>
</div>
</div>
<div class="paragraph">
<p>Slices are used by functions of the standard library
or by user defined functions to access sub-ranges of strings, arrays and sequences.
Applied to these container data types, slices look syntactically like sub-ranges:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  m = "Nim programming is difficult."
m[19 .. 28] = "not easy."
echo m
echo "Indeed " &amp; m[0 .. 18] &amp; "is much fun!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>In line three we use the slice to replace the sub-string "is difficult." which starts
at position 19 with another string. Note that the replacement can be a longer or a
shorter string, that is, the slice supports not only overwriting characters, but also
inserting or deleting operations. In the last line, we use the slice to access a
sub-string and create a new string with it. As we learned earlier in the strings
section already, we can use the <span class="op">^</span> operator to access elements counted from the
end of the container, so we could have written line three also as <span class="code">m[19 .. ^1]
= "not easy."</span>.</p>
</div>
<div class="paragraph">
<p>Slices can be used in a similar way for arrays, strings and sequences. But we have to
remember that slices are only objects with a lower and an upper bound, so there must
be always a procedure that accepts the container and the slice as arguments to do the
real work.</p>
</div>
<div class="paragraph">
<p>When we care for utmost performance, then we have to be a bit carefully with slices,
as slices can generate copies. Consider this example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = object
    i: int

proc main =
  var
    s = newSeq[O](1000000)
  for i in 0 .. (1000000 - 1):
    s[i] = O(i: i)

  var sum = 0
  for x in s[1 .. ^1]:
    sum += x.i</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we use the slice operator to exclude the first element from our summing
operation. Unfortunately, in current Nim v1.6 use of the slice operation in this way
creates a copy of our sequence, which increases the run-time and memory consumption.
We may try to use the new toOpenArray() expression and try a construct like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">  for x in items(s.toOpenArray(1, s.high)):</code></pre>
</div>
</div>
<div class="paragraph">
<p>but that does currently not compile.</p>
</div>
<div class="paragraph">
<p>One option is currently that we create a custom iterator like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">iterator span*[T](a: openArray[T]; j, k: Natural): T {.inline.} =
  assert k &lt; a.len
  var i: int = j
  while i &lt;= k:
    yield a[i]
    inc(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and use</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">for x in s.span(1, s.high):</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or we may do the summing in a procedure and pass that <span class="proc">proc</span> an openArray created with
toOpenArray() like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc sum(x: openArray[O]): int =
  for el in x:
    inc(result, el.i)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo sum(s.toOpenArray(1, s.high))</code></pre>
</div>
</div>
<div class="paragraph">
<p>But this is work in progress, so the situation may improve, see</p>
</div>
<div class="paragraph">
<p>+ <a href="https://forum.nim-lang.org/t/4823" class="bare">https://forum.nim-lang.org/t/4823</a></p>
</div>
<div class="paragraph">
<p>+ <a href="https://forum.nim-lang.org/t/4582#28715" class="bare">https://forum.nim-lang.org/t/4582#28715</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_value_objects_and_references">Value Objects and References</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We have already used different types of variables&#8201;&#8212;&#8201;integers, floats, or the custom
Computer object, and some more. We said that variables are named memory regions,
where the content of our variables is stored. We call this type of variables also
value objects.</p>
</div>
<div class="paragraph">
<p>Value objects always implies copies when we do an assignment</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i, j: int
i = 7
j = i
i = 3
echo i, j</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we have 3 assignments, first we assign the integer literal <span class="lit">7</span> to variable <span class="var">i</span>, then
we assign the content of variable <span class="var">i</span> to variable <span class="var">j</span>, and finally we overwrite the old
content of variable <span class="var">i</span> with the new literal value <span class="lit">3</span>. The output of the <span class="func">echo()</span> statement
should be <span class="term">3</span> and <span class="term">7</span>, because in line 3 we copy the content of variable <span class="var">i</span>, which is
currently the value <span class="lit">7</span>, into variable <span class="var">j</span>. The new assignment in line 4 in no way
touched the content of variable <span class="var">j</span>.</p>
</div>
<div class="paragraph">
<p>Maybe that is not too surprising, but when we would have references instead of plain
variables, then the situation would be different, as we will see soon.</p>
</div>
<div class="paragraph">
<p>Whenever possible, we should use this simple form of variables, as they are fast and
easy to use.</p>
</div>
<div class="paragraph">
<p>But there exist situations where we need some sort of indirection, and then
references and pointers come into play. For example, when the data entities depend in
some form on each other, the elements may build linked lists, trees or other
structures. The entities may have some neighborhood relation, also called some one-to-many
relation.</p>
</div>
<div class="paragraph">
<p>Indeed, value objects and references occur in real life also:</p>
</div>
<div class="paragraph">
<p>Imagine you have baked a cake for your family, and you know that your friendly
neighbor loves cakes too. As you have still a lot of all necessary ingredients and
because the oven is still hot, you make one more identical cake to give it later to
your neighbor. We can think of the cake as a value type, and your second cake can be
considered as a copy. When you give the copy to your neighbor, then you have still
your own, and when you or the neighbor eats the cake, then the other one still exist.</p>
</div>
<div class="paragraph">
<p>Now imagine that you know a good car repair shop. You can give the telephone number
or location of that car repair shop to your neighbor, so he can use that shop too. So
you gave him a reference to the shop, but you gave him not a copy. You can also give
some of your other friends each a reference to that shop, which is nearly no effort
for you. While backing a cake for all of them would be some effort.</p>
</div>
<div class="paragraph">
<p>You can regard names of persons as some sort of reference too. Imagine you have a
list with the names of all the people you intend to invite to your birthday party,
and another list with names of people who owe you money. Some names may be on both
list, this is it refers to the same person.</p>
</div>
<div class="paragraph">
<p>In computers the dynamic storage, called RAM, consists of consecutive, numbered
storage locations, called words. Each individual word has its address, which is a
number typically starting at zero and extending to a value which is defined by the
amount of memory available in your computer. These addresses can be used to access
the storage locations, that is, to store a value at that address, or to read the
content again. Reading generally does not modify the content, you can read it many
times and will always get the same value. When you write another value to that
storage location, then reads will give you that new value.</p>
</div>
<div class="paragraph">
<p>Basically for all the data that you use in your program you need in some form its
address in the RAM, without the address you can not access it. But what is with all
the plain, value object variables we have used before, we have never used addresses?
That is true&#8201;&#8212;&#8201;we used only names to access our variables, and the compiler mapped
our chosen name to the actual address of the variables in memory whenever we accessed
the variable. For most simple cases, this is the best way to access variables. Now let
us assume we have such value object type of variable declared in our program, can we
access it without using its name? When we have declared it, it should reside
somewhere in the RAM when the program is executed. Well, when we do really not want
to access it by variable name, then there is still one chance: We can search in the
whole RAM for the desired content. In practice, we would never do that, as it is
stupid and would take very long, but we could do. But how can we detect our variable?
How can we be sure that it is indeed ours? Generally we can not. Even when we are
sure that the variable must reside somewhere in the RAM, typically the variable is
marked in no way, of course. Even when we would know the value which is stored in that
variable, we would only know what bit pattern it should have, so for most words of
the RAM with a different bit pattern we could say for sure that it can not be our
variable, but whenever we find the expected bit pattern than it can be just a
coincidence, there can be many more words in RAM with that content. In some way it is
as you would search a person, and you know that that person lives in a long road with
numbered houses. If you only know that the person wears brown shoes, but you know not
the number of the house nor the name of the person and no other unique property of
that person, then you have not much luck.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_references_and_pointers">References and Pointers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction_to_pointers">Introduction to Pointers</h3>
<div class="paragraph">
<p>In Nim references are some form of smart or managed pointers, we will learn more
about references later. The plain pointer data type is nothing more than a memory
address, it is similar to a (unsigned) integer number. We say that a pointer points
to an entity when the pointer contains the memory address of that entity.</p>
</div>
<div class="paragraph">
<p>Beside the <span class="type">pointer</span> data type, which is only some RAM address, we have also the <span class="type">ptr</span>
entity. <span class="type">Ptr</span> is not a datatype for its own, it is always used in conjunction with
another data type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
 p: pointer
 ip: ptr int</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the variable <span class="var">p</span> is of type <span class="type">pointer</span>, we could use it to point to some arbitrary
memory address. The variable <span class="var">ip</span> is of type <span class="code">ptr int</span>, which indicates that it
should only point to memory addresses where a variable with data type <span class="type">int</span> resides. So
a <span class="type">ptr</span> is a pointer that is bound to a specific data type. Generally we speak only
about pointers, if we are referring to an untyped <span class="type">pointer</span> or a typed <span class="type">ptr</span> is generally
clear from the context.</p>
</div>
<div class="paragraph">
<p>When we only declare pointers but do not assign a value, then the pointers have the
value <span class="lit">nil</span>, what indicates that they are regarded to point to nothing.
Exactly speaking, a pointer can never point anything in the same way as an integer
variable can not contain no number. As an integer variable always contains a bit
pattern, a pointer also always contains a bit pattern. But we are free to define a
special pattern as <span class="lit">nil</span>, and whenever a pointer has this special value, then we know
that it does not really point to something useful. In C instead of <span class="lit">nil</span>, NULL was
chosen for the same purpose. In practice <span class="lit">nil</span> and NULL are typically mapped to <span class="lit">0</span>, that
is, a word with all bits cleared. But that is more or less an arbitrary decision.</p>
</div>
<div class="paragraph">
<p>So how can we give our pointers above a useful value?</p>
</div>
<div class="paragraph">
<p>One possibility would be to use Nim&#8217;s <span class="func">addr()</span> function, which gives us the memory
address of each ordinary variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
 number: int = 7
 p: pointer
 ip: ptr int
echo cast[int](p)
echo cast[int](ip)
p = addr(number)
ip = addr(number)
echo cast[int](p)
echo cast[int](ip)</code></pre>
</div>
</div>
<div class="paragraph">
<p>First we declare an ordinary integer variable called <span class="var">number</span> which will reside
somewhere in memory when we execute the program, and then we use the <span class="func">addr()</span> function
to assign the address of that variable to <span class="var">p</span> and <span class="var">ip</span>. The <span class="func">addr()</span> function is a low
level function provided by the compiler, it can be used to determine the memory
address of variables and some other entities known to the
compiler.<sup class="footnote">[<a id="_footnoteref_28" class="footnote" href="#_footnotedef_28" title="View footnote.">28</a>]</sup> We used the <span class="func">echo()</span> procedure to show us the numeric
decimal value of the addresses in the terminal. As it typically makes not too much
sense to print addresses, <span class="func">echo()</span> would refuse to print it, so we have used the
construct <span class="code">cast[int](someValue)</span> to tell that <span class="func">echo()</span> should regard our pointers as
plain integer and print it. That operation is called casting, we mostly should
avoid it, as it destroys type safety, but for learning purposes it is OK to use it.
We will learn more about casts and related type conversion later.</p>
</div>
<div class="paragraph">
<p>The first two <span class="func">echo</span> statements should print the decimal value <span class="lit">0</span>, as the pointers have
the initial default value <span class="lit">nil</span>.</p>
</div>
<div class="paragraph">
<p>The <span class="func">echo()s</span> in the last two lines should print a value different from <span class="lit">0</span>, as we have
assigned the valid address of an ordinary variable that resides somewhere in the RAM
when the program is executed. Both outputs should be identical, as we have assigned
for both pointers <span class="func">addr(number)</span> each.</p>
</div>
<div class="paragraph">
<p>Maybe a funny fact is, that when you run the program multiple times, the output of the
last two <span class="func">echo()</span> statements print different values. But that is not really surprising&#8201;&#8212;&#8201;whenever you launch the program, then for our variable <span class="var">number</span>, a storage location
in RAM is reserved. And that location can differ for each new program execution. For
your next holiday in the same hotel, you may get a different room also.</p>
</div>
<div class="paragraph">
<p>So when we have the pointer <span class="var">ip</span> pointing to a valid address, can we recover the
content of that memory region? Sure, we use the dereference operator <span class="op">[]</span> for that
purpose. Whenever we have a typed pointer <span class="var">x</span> we can use <span class="var">x[]</span> to get the content of the
memory location where the pointer is pointing to. Note that the operator <span class="op">[]</span> is not
really related to the subscript operator <span class="op">[pos]</span> which we used earlier for <span class="type">array</span>, <span class="type">seq</span>
and <span class="type">string</span> access. Nim uses ASCII characters for its operators, and that set is not
very large. And maybe it would even be confusing when we would have a different
symbol for each operator. We can consider <span class="op">[]</span> as some form of content access operator&#8201;&#8212;&#8201;<span class="var">mystring[pos]</span> gives us the character at that position, and <span class="var">ip[]</span> gives us the
content of the memory location where <span class="var">ip</span> points to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
 number: int = 7
 ip: ptr int
echo cast[int](ip)
ip = addr(number)
echo cast[int](ip)
echo ip[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>What do you expect as output for the last <span class="func">echo()</span> statement? Note that for the last <span class="func">echo()</span>
statement we do not need a cast, as <span class="var">ip[]</span> has a well-defined type: <span class="var">ip</span> has type <span class="type">ptr
int</span>, so <span class="var">ip[]</span> is of well-defined type <span class="type">int</span> and <span class="func">echo()</span> can print the content.</p>
</div>
<div class="paragraph">
<p>Now let us investigate how we can use pointers to modify the content of variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
 number: int = 7
 ip: ptr int
ip = addr(number)
echo ip[]
ip[] = 3
echo ip[]
echo number</code></pre>
</div>
</div>
<div class="paragraph">
<p>What do you expect for the output of the last <span class="func">echo()</span> statement? Well, remember, <span class="var">ip</span>
points to the location where variable <span class="var">number</span> is stored in RAM. So echo <span class="var">ip[]</span> gave us
the content of <span class="var">number</span>. Now <span class="code">ip[] = 3</span> is an assignment, the right site of the
assignment operator is the literal number <span class="lit">3</span>, which is a value type. Earlier we said
that for value types an assignment is a copy operation, the right site of the
assignment operator is copied into the variable on the left site. Now <span class="var">ip[]</span> stands
exactly for the same content as the name <span class="var">number</span>, and so assigning to <span class="var">ip[]</span> is the same
as assigning to <span class="var">number</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pointer_arithmetic">Pointer Arithmetic</h3>
<div class="paragraph">
<p>In low level programming languages, pointer arithmetic can be useful. For example, old
C code often iterates with pointer arithmetic over arrays by use of constructs like
<span class="code">sum &#43;= *(myIntPtr++)</span>. This was done to maximize performance. Modern C
compiler generally understands statements like <span class="code">sum &#43;= el[i]; i++</span> well and
generates very good assembly instructions for it. So pointer arithmetic is not
necessary in C that often today.</p>
</div>
<div class="paragraph">
<p>Nim does not provide math operations for pointers directly, but we can always cast
pointers to integers and do arbitrary math. And of course we could define our own
operators for that purpose, but typically we should avoid that, as it is dangerous,
error-prone and generally not necessary. As an example, let us sum up some array
elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var
    a: array[8, int] = [0, 1, 2, 3, 4, 5, 6, 7]
    sum = 0
  var p: ptr int = addr(a[0])
  for i in a.low .. a.high:
    echo p[]
    sum += p[]
    echo cast[int](p)
    var h = cast[int](p); h += sizeof(a[0]); p = cast[ptr int](h)
    #cast[var int](p) += sizeof(a[0]) # this compiles but does not work currently

  echo sum
  echo typeof(sizeof(a[0]))

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we do pointer arithmetic or similar math to calculate the address of variables
in the computer memory, then memory addresses are used like integer numbers, and so
it makes some sense that Nim&#8217;s integers have the same byte size as pointers.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kaushalmodi/ptr_math" class="bare">https://github.com/kaushalmodi/ptr_math</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_allocating_objects">Allocating Objects</h3>
<div class="paragraph">
<p>In the previous section, we learned the basics about pointers. We used the <span class="func">addr()</span>
operator to initialize the pointer by assigning the address of an already existing
object. This is in practice not that often done, and it can be a bit dangerous, as it
is not always guaranteed that the variable on which we applied <span class="func">addr()</span> will exist as
long as our pointer exist. So the pointer may point later to a memory location that
is already freed or used by a totally different object already. So the use of <span class="func">addr()</span>
is more reserved for advanced programmers who know well what they do, and most of the
time <span class="func">addr()</span> is not necessary at all or is only necessary for really low level code,
maybe when interfacing with external libraries written in C. Instead of using <span class="func">addr()</span>
to assigning to pointers a valid address, often procedures like <span class="func">alloc()</span> or <span class="func">create()</span>
are used to reserve a block of memory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var ip: ptr int
ip = create(int)
ip[] = 13
echo ip[] * 3
var ip2: ptr int
ip2 = ip
echo ip2[] * 3
dealloc(ip)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the procedure <span class="func">create()</span> is used to reserve a block of memory, the <span class="type">int</span> parameter
ensures that the block has the size of an integer value. After <span class="var">ip</span> has a valid value,
we can store a value in that memory location and read it again. Note that multiple
pointers can point to the same memory location: We declared one more <span class="type">int ptr</span> called
<span class="var">ip2</span>. But for that pointer, we do not allocate a new block, but we assign the old block
that we allocated for <span class="var">ip</span> to <span class="var">ip2</span>. Now both pointers points to the same object, the <span class="type">int</span>
value <span class="lit">13</span>. We may call <span class="var">ip2</span> an alias, as it is a different way to access the same
object.</p>
</div>
<div class="paragraph">
<p>When we use <span class="func">alloc()</span> or <span class="func">create()</span> to allocate memory blocks, then we have to deallocate
them when we need them not anymore. Otherwise, that memory blocks couldn&#8217;t be reused.
If we would continuously allocate memory blocks and never deallocate, that is, free
them, then at some point in time all memory would be occupied&#8201;&#8212;&#8201;not only for our own
program, but for all programs running currently on the same computer. We had to
terminate our program&#8201;&#8212;&#8201;when a program is terminated then all resources get freed
automatically by the OS.</p>
</div>
<div class="paragraph">
<p>The use of procedure pairs like <span class="func">alloc()</span> and <span class="func">dealloc()</span> is common practice in low level
programming languages like C, but it is inconvenient and dangerous: We can forget to
call <span class="func">dealloc()</span> and waste resources, or we may even deallocate memory blocks, but still
use it by our pointers. The later would at some point of time crash our program, as
we would use memory blocks which are already released and may be used for other
variables&#8201;&#8212;&#8201;from our own program or from other programs. Note that in the source
code above there is only one single <span class="func">dealloc()</span> call. The reason for that is, that we
only allocated one single memory block in one single <span class="func">create()</span> call, <span class="var">ip2</span> is only one
more pointer that points to that block. If we had used an additional
<span class="func">dealloc(ip2)</span> call, then that would be a so-called double free error.</p>
</div>
<div class="paragraph">
<p>As you see, using pointers is inconvenient and dangerous. But still there are
situations where plain value type variables do not suffice. The solution of many
higher level programming languages to this problem is a <span class="ndef">Garbage-Collector</span> (GC). The
GC does the dangerous and inconvenient task of deallocating unused memory blocks for
us automatically.</p>
</div>
<div class="paragraph">
<p>To distinct the GC managed "pointers" cleanly from the manually managed ones, we call
them in Nim <span class="ndef">references</span>, in some other languages they are called traced
pointers. References are always typed like <span class="type">ptr</span>, there is no equivalent to the untyped
<span class="type">pointer</span> type for references.</p>
</div>
<div class="paragraph">
<p>For References, we have still to do the allocation our self, then we can use the
references, and when we are not using them anymore, then the GC frees the
corresponding memory block. A typical scenario is that we use references in a
procedure or in an otherwise limited block of code: We declare the reference in that
code block, allocated and use it, and when the code block is left the GC frees the
allocated memory for us. You may think that the fact that we still have to allocate
the memory for our references our self is still a concern, as we may forget that
step. Well it is not that dangerous, when we forget the allocation step, we would use
a reference with value <span class="lit">nil</span>, which would immediate result in a runtime error. So we
would see the problem immediately. Other pointer errors, like missing de-allocation
or use after free, are not that obvious and more dangerous.</p>
</div>
<div class="paragraph">
<p>With references, we can rewrite our previous example code in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var ip: ref int
new(ip)
ip[] = 13
echo ip[] * 3
var ip2: ref int
ip2 = ip
echo ip2[] * 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have replaced <span class="type">ptr</span> by <span class="type">ref</span>, and instead of <span class="func">alloc()</span> or <span class="func">create()</span> we are using the
<span class="func">new()</span> <span class="proc">proc</span> which gets the uninitialized <span class="key">ref</span> as a parameter and allocates a managed
memory block for it, that is after the <span class="func">new()</span> call <span class="var">ip</span> has a well-defined value
referring to a managed memory block that can store an integer value. Again, we can
use one more <span class="key">ref</span> and assign that <span class="key">ref</span> the value of the other, so now both references
the same memory block. The advantage here is that we don&#8217;t have to care about
freeing that block, the GC will do that when appropriate.</p>
</div>
<div class="paragraph">
<p>To verify that in the example code above, both references really reference the same
object in memory, we could add two more lines of code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">ip2[] = 7
echo ip[]
echo ip2[]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we are using the reference <span class="var">ip2</span> to assign to the memory block the literal value
<span class="lit">7</span>. After that assignment, both echo statements would display that new content.</p>
</div>
<div class="paragraph">
<p>Using references and pointers to store basic data types like integers is not done
that often, in most cases we work with larger objects, and we create some relations
between the objects. We will try that in the next section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_references_to_objects">References to Objects</h3>
<div class="paragraph">
<p>You should still wonder for what references are really useful&#8201;&#8212;&#8201;they seem to be only
a more complicated version of plain value type variables.</p>
</div>
<div class="paragraph">
<p>Now let us assume we want to create a list of things or persons, maybe a list of our
previously used Computer data type, or perhaps a list of persons we will invite to our
next party. We will create the party list for now, as the Computer data type we used
before has already many fields, and filling all the fields would be some effort, so
let us use a new <span class="type">Friend</span> data type which should store only the friend&#8217;s name for the
beginning&#8201;&#8212;&#8201;we may add more fields later when necessary. So we may have</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Friend = object
    name: string</code></pre>
</div>
</div>
<div class="paragraph">
<p>With that declaration, we could declare a few friends variables like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">  var harry, clint, eastwood: Friend</code></pre>
</div>
</div>
<div class="paragraph">
<p>But that is not what we want, we would need a list with all of our friends that we
would like to invite to our party, we would want to add friends to the list, and
potentially we would want to delete friends also. You may think we could use Nim&#8217;s sequence
data type for that, and you are right. But let us assume we could not use that
predefined Nim data type for some reason. Then we could create a list of linked
references to Person.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Friend = ref object
    name: string
    next: Friend</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now our <span class="type">Friend</span> data type is a reference to an <span class="key">object</span> , and the <span class="key">object</span>  itself has an
additional <span class="var">next</span> field which is again of type <span class="type">Friend</span>.</p>
</div>
<div class="paragraph">
<p>That is some sort of recursion. If that should appear as too strange, then imagine
you have some numbered paper cards, each with two fields: One field name, one field
next: In the name field you can fill in a name of a friend, in the next field you
fill in the number of the next card. The last card in the chain gets no entry in the
next field.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>In languages like Nim or C <span class="ndef">lists</span>, also called <span class="ndef">linked lists</span>, are
dynamically created data structures consisting of elements (called nodes), where each
node has a field which is a references or pointer to its successor or predecessor.
When the nodes have only a successor field, then we call the list a <span class="ndef">single
linked list</span>, and when it also has a predecessor field, then we call it a
<span class="ndef">double linked list</span>. Contrary to arrays and Nim&#8217;s sequences lists do not
allow access to arbitrary elements, we can only traverse the list starting from its
first element for single linked lists, or also from its last elements for double
linked lists. The first element of a list is also called its <span class="ndef">head</span>, and the
last element is called its <span class="ndef">tail</span>. Often the head and the tail elements are
just plain nodes, but the head can be also an extended node object with additional
fields carrying information for the whole list, maybe an additional string field for
the list name. In this section, we use the simplest form of a list, which is a single-linked
list where the head is just an ordinary node. If the head has the value nil,
then the list is empty.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Now we create a small Nim program which reads in names of our friends from the
terminal, creates a list of all friends, and finally prints the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Friend = ref object
    name: string
    next: Friend

var
  f: Friend # the head of our list
  n: string # name or "quit" to terminate the input process

while true:
  write(stdout, "Name of friend: ")
  n = readline(stdin)
  if n == "" or n == "quit":
    break
  var node: Friend <i class="conum" data-value="1"></i><b>(1)</b>
  new(node)
  node.name = n
  node.next = f
  f = node

while f != nil:
  echo f.name
  f = f.next</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The actual name for this temporary
variable is arbitrary, we could have used <span class="var">el</span> for element, maybe.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This example code seems to be not that easy. But it is not really difficult, and when
you have understood it, you can call yourself a Nim programmer already. Perhaps you
should think about the code above for a few minutes before reading the explanations
below.</p>
</div>
<div class="paragraph">
<p>First, let us summarize what our program should do: It should read in some names of
our friends which we would like to invite to our next party. Of course, when entering
the names, we would need a way to tell that we are done. In our program we can do
that in two ways, we can enter an empty name by just pressing the return key, or we
can enter the text "quit" to stop the loop. Unfortunately, that means that we can
never invite a friend with that name to our parties. When we have terminated the
input loop, then the next loop prints all the entries to the terminal.</p>
</div>
<div class="paragraph">
<p>Let us start with the type and variable declarations: We use a user defined type
named <span class="type">Friend</span> which is a reference to an <span class="key">object</span> , that object type has a field <span class="var">name</span> of
type <span class="type">string</span>, and a field <span class="var">next</span> which is again a reference to the same data type.</p>
</div>
<div class="paragraph">
<p>We are using two variables, one called <span class="var">n</span> of type <span class="type">string</span> to read in a name or the quit
command from terminal, and a variable called <span class="var">f</span> of type <span class="type">Friend</span>. The variable <span class="var">f</span> seems
to match only to one single friend, but as the type of <span class="var">f</span> has a <span class="var">next</span> field it can be a
whole list of friends, with <span class="var">f</span> being the start or head of that list.</p>
</div>
<div class="paragraph">
<p>In the code above, we are using a special <span class="key">while</span> loop&#8201;&#8212;&#8201;special because the construct
<span class="code">while true:</span> and because the loop contains a <span class="key">break</span> statement. Earlier, we said
that we should avoid the <span class="key">break</span> statement in loops, because it interrupts the control
flow and can make it more difficult to understand and prove the flow. But in this
case that form makes some sense: For the first loop we have to first read in a name
from the terminal, and then we can decide what to do, so we can not really evaluate a
condition after the <span class="key">while</span> statement at the top. So we use the simple constant
condition <span class="lit">true</span>, which would never terminate the loop. We need a <span class="key">break</span> inside the loop
body to terminate the loop.</p>
</div>
<div class="paragraph">
<p>Let us investigate the second loop first as it is really easy: In the <span class="key">while</span> condition
we check if current value of <span class="var">f</span> is <span class="lit">nil</span>, that is, if there are no more entries in our
list. For that case, we terminate the loop, as we are done. If <span class="var">f</span> has not the value
<span class="lit">nil</span>, then <span class="var">f</span> points to a valid content, that is, there is at least a valid name, which
we access by the field access operator and print it with <span class="code">echo f.name</span>. Note that in
Nim the field access operator <span class="op">.</span> works in the same way for value objects types
as well as for <span class="key">ref</span> objects types. For <span class="key">ref</span> objects types we could also write <span class="var">f[].name</span>
instead of plain <span class="var">f.name</span>, that is we first apply <span class="op">[]</span> to <span class="var">f</span> to get the content, and then
use the <span class="op">.</span> operator to access the <span class="var">name</span> field. In some other languages like C we would have to use
a special operator -&gt; to access fields of pointer or reference types.</p>
</div>
<div class="paragraph">
<p>The most interesting statement in the output loop is <span class="code">f = f.next</span>. We assign the
content of <span class="var">f.next</span> to <span class="var">f</span> and proceed with that new content. The content could be a
valid reference to one more <span class="type">Friend</span> object, or it could be <span class="lit">nil</span>, indicating that our
loop should terminate.</p>
</div>
<div class="paragraph">
<p>The input loop is also not that complicated: To make the process of adding more
friends to the list easy, we always add the new names at the beginning. First, we ask
the user to enter a name. We use <span class="func">write(stdout)</span> for this, as <span class="func">echo()</span> always generates a
newline, but we want to read in the name on the same line. If the name is empty or
has the special value "quit" then we terminate the input loop. In the loop we are
using a temporary variable called <span class="var">node</span> of type <span class="type">Friend</span>, we allocate a memory block for
it with <span class="func">new()</span>.<sup class="footnote">[<a id="_footnoteref_29" class="footnote" href="#_footnotedef_29" title="View footnote.">29</a>]</sup> Then we assign the read in friend&#8217;s name <span class="var">n</span> to the <span class="var">name</span> field. The last two
statements of the loop body are a bit demanding: First we assign to <span class="var">node.next</span> the
value of <span class="var">f</span>. Now, <span class="var">node</span> is basically the start of our list, and its <span class="var">next</span> field refers to
the first element of the current list. Fine, but we said that the node variable is
only a temporary variable, we do not intend to use it longer as necessary. But
currently <span class="var">node</span> is so useful, it is the head of our list. On the other hand, the
former list start <span class="var">f</span> is now useless, current <span class="var">f</span> is identical with <span class="var">node.next</span>. So the
trick is, we just assign to <span class="var">f</span> the value of <span class="var">node</span>. Now <span class="var">f</span> is the complete list, and we
do not need <span class="var">node</span> any-more. The <span class="var">node</span> variable can be used in the next loop iteration
again, but we have to allocate a new memory block for the <span class="var">node</span> reference, as the
previous memory block is still in use, it contains the name which we just entered and
also a reference to the next object in the list.</p>
</div>
<div class="paragraph">
<p>Note that we add the new elements at the top of the list in this way. We have done it
that way because it is very easy in this way. For adding at the end of the list, we
would have to use one more reference variable which allows us always access to the
current end of the list, or we would have to traverse the list from head to tail
whenever we would like to add elements at the tail.</p>
</div>
<div class="paragraph">
<p>For one more exercise, let us consider deleting entries in our list. Basically that
operation is very easy, we would just skip one entry. Lets add this code to the
program above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">while f != nil:
  write(stdin, "Name to delete: ")
  n = readline(stdin)
  if n == "" or n == "quit":
    break
  if f.name == n:
    f = f.next
  else:
    while f.next != nil:
      if f.next.name == n:
        f.next = f.next.next
        break
      f = f.next</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we are using again an outer <span class="key">while</span> loop to read in the names which we want to
delete. That loop uses the condition <span class="code">while f != nil:</span> because when the list is empty
we should stop, of course.</p>
</div>
<div class="paragraph">
<p>In the loop body we have an <span class="key">if</span> statement, and in the <span class="key">else</span> branch of the <span class="key">if</span> statement
we have one more loop. The reason why we need the <span class="key">if</span> statement is, that the case
that our name to delete is the first in the list is some sort of special. Let us
investigate the inner loop first. That loop assumes that there are at least 2
elements in the list, <span class="var">f</span> and <span class="var">f.next</span>. We compare the name of the next entry with <span class="var">n</span>. If
they match, then we would have to skip the next entry. We can do that by the statement
<span class="code">f.next = f.next.next</span>. That is, we replace the reference from the current element <span class="var">f</span> to
the next list entry, that is <span class="var">f.next</span>, by the next entry of the next element, which is
<span class="var">(n.next).next</span>. We do not have to write the parenthesis. The <span class="var">n.next.next</span> entry can be
<span class="lit">nil</span>, in that case, it is the end of the list. If we found a matching name, then we
terminate the inner loop with a <span class="key">break</span> statement, and we are done. Otherwise, we assign
to <span class="var">f</span> the value of <span class="var">f.next</span> and continue the loop execution. Now to the special case
that the name to delete is the first in the list. We need the first <span class="key">if</span> branch for
that&#8201;&#8212;&#8201;if already the first element matches the name to delete, then we just skip the
first element by setting the head of the list to the next entry, which may or may not
be <span class="lit">nil</span>.</p>
</div>
<div class="paragraph">
<p>This is one way to solve the task, for operations on lists there exist in most cases
various solutions, some optimized for easy or short code, some for performance. You
may copy the code segment above to the end of the former code, and maybe add one more
copy of our printing loop at the end again. Then you should have a program that reads
in a list, prints the contents, then ask for names to delete, and finally prints the
resulting list. Perhaps you can improve the code, or maybe you can detect special
corner cases where it may fail. What is for example when some of your friends have
the same name? May the program fail in that case? Or you may add more fields to your
<span class="type">Friend</span> data type. Possibly a textual field with content male or female, and you can
report the ratio of male to female. And potentially remove males from the list when we
have more males than females?</p>
</div>
<div class="paragraph">
<p>For references to objects, the assignment operator <span class="op">=</span> copies the references, but
not the object. In the same way, the operator <span class="op">==</span> for equality test compares the
references, but not the content of the objects to which the references point. If you
want to compare the content of the objects, you can apply the dereference operator
<span class="op">[]</span> on both references:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  RO = ref object
    i: int

var
  ro1 = RO(i: 1)
  ro2 = RO(i: 1)
  ro3 = ro1

echo ro1 == ro2 # false
echo ro1[] == ro2[] # true
echo ro1 == ro3 # true</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_procedures_and_functions">Procedures and Functions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Procedures and functions, called <span class="key">proc</span> and <span class="key">func</span> in Nim, are the most common way to
structure, or break larger programs into smaller, dedicated tasks which are to be performed.</p>
</div>
<div class="paragraph">
<p>The terms procedure
and function were used in Pascal and the other languages of Wirth already, while C
uses the term function only, and Fortran generally uses the term subroutine instead.
And finally, Python and Ruby are using the really strange terms <span class="func">def</span> and <span class="func">fun</span> for it.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s procedures are basically similar, but much more advanced than its equally named cousins
in the wirthian languages, or the plain functions in the C language: Nim&#8217;s procedures support generics and overloading, named parameters and default values,
the special parameter types varargs and openArray,
various ways to return a result and finally multiple calling conventions including the
method and command calling conventions.</p>
</div>
<div class="sect2">
<h3 id="_introduction">Introduction</h3>
<div class="paragraph">
<p>We call or invoke a <span class="proc">proc</span> by just writing its name followed by a parameter list
enclosed in parentheses. The parameter list can be empty. When we call a <span class="proc">proc</span>, then
the program execution continues with that procedure, and when the execution of the
procedure terminates, then the next statement after that <span class="proc">proc</span> call is executed.
Sometimes we say that we jump into a procedure and jump back when that procedure
terminates.</p>
</div>
<div class="paragraph">
<p>In Nim functions are a special form of procedures that return a result and do not
modify the current state of the program. Modifying a global variable or performing an input/output
operation would be examples for modifying the state. We have already used some
predefined procedures like <span class="func">echo()</span> for output operations, <span class="func">add()</span> for appending single
characters to strings, and <span class="func">readLine()</span> for reading in textual user input. And we
talked about math functions like <span class="func">sin()</span>, <span class="func">cos()</span>, <span class="func">pow()</span>&#8201;&#8212;&#8201;these are functions as they
accept one or two arguments and return a result but do not change a state&#8201;&#8212;&#8201;calling
them again with the same arguments would always give the same result. <span class="func">ReadLine()</span> is
only a <span class="proc">proc</span>, not a function, as the result may be different for each call, and as we
pass a file variable as argument, which may change its state for each call, maybe
because the file end is reached. A function is only a special subtype of a
procedure, the <span class="key">func</span> keyword indicates to the reader of the code and to the compiler
some special properties, that is that a result is returned and that global state is
not changed. Whenever the <span class="key">func</span> keyword is used a <span class="proc">proc</span> would do as well, and in this
text we mostly speak about procedures, even when a function would do.</p>
</div>
<div class="paragraph">
<p>Let us start with a very simple function called <span class="func">sqr()</span> for square.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func sqr(i: int): int =
  i * i</code></pre>
</div>
</div>
<div class="paragraph">
<p>A procedure declaration consists of the keyword <span class="proc">proc</span>, a user selected name, an
optional parameter list enclosed in parentheses and an optional colon followed by the result
data type. For a function declaration we use the keyword func instead of <span class="proc">proc</span>, and
as functions does always return a result, we have always to specify the result
data type.</p>
</div>
<div class="paragraph">
<p>Note that this is only a declaration so far&#8201;&#8212;&#8201;the compiler could recognize the
construct, its parameters and its result type. Sometimes we call this construct a
procedure-header.</p>
</div>
<div class="paragraph">
<p>Typically we do not only declare a function, but we define it, that is, we add an equal
sign to the procedure header and add an indented procedure body that contains the
code that is performed for each invocation.</p>
</div>
<div class="paragraph">
<p>Pure <span class="proc">proc</span> declarations can be necessary in rare situations, maybe when two procedures
call each other. In this case, the procedure defined first would call the other
procedure, which is not already defined, so the compiler may complain about an unknown
procedure. We could solve that problem by first declaring the second procedure, so
that the compiler would know about its existence. We would then define that second
procedure later, that is closer to the end of the program file.</p>
</div>
<div class="paragraph">
<p>The <span class="func">sqr()</span> <span class="proc">proc</span> above accepts an integer argument and returns its square of the same data
type. We would call that <span class="proc">proc</span> like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var j: int
j = 7
echo sqr(j)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Earlier in this book, we said that the compiler processes our source code from top to
bottom, and that the final program is executed from top to bottom too. The first
statement is indeed true, for that reason it can be necessary to declare a function
at the top, and define it below, as we can not call a <span class="proc">proc</span> before it is declared or
defined.</p>
</div>
<div class="paragraph">
<p>For the program execution, we have to know that <span class="proc">procs</span> are only executed when we call
them. That is, when we write a <span class="proc">proc</span> at the top of our source code, then that <span class="proc">proc</span> is
processed by the compiler, but it is not executed during program runtime before we
call it. Actually, as the Nim compiler supports "death code removal", code of
procedures that we never call would not make it in to our final executable at all.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The procedure body builds a new scope. We can declare entities like variables,
constants, types or other procedures and functions in that scope. These entities are only visible in
the procedure body, but not outside of the <span class="proc">proc</span>. Will will learn more about scopes and
visibility soon.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Parameter lists of procedures consist of one or more lists of parameter names, separated with commas, followed by a colon and
the data type of the parameters. The sub-lists with same data type are separated by semicolons:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p(i, j, k: int; x, y: float; s: string)</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the wirthian languages would require semicolons to separate
the parameter blocks, in Nim we could also use plain commas for that.
For the data types of <span class="proc">proc</span> parameters all of Nim&#8217;s data types are allowed, including
structured types, ref, pointer and container types, and we can pass literal values, named constants or variables.</p>
</div>
<div class="paragraph">
<p>When we call such a <span class="proc">proc</span> with multiple arguments, we have to specify the arguments
in the order as they are listed in the <span class="proc">proc</span> header, separated with commas, and the arguments must have compatible data types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i: int = 7; x: float = 3.1415
p(i, 13, 19, x, 2.0, "We call proc p() with a lot of parameters")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here compatible data types means, that for the <span class="var">i</span>, <span class="var">j</span>, and <span class="var">k</span> parameters which are specified as <span class="type">int</span> type
in the <span class="proc">proc</span> definition, variables of smaller <span class="type">int</span> types like <span class="type">int16</span> would work. For the two parameters
of <span class="type">float</span> type, we would have to pass floating point variables or a <span class="type">float</span> literal. As a special case an <span class="type">int</span> literal
would work also, as the compiler knows the desired data type and automatically converts the <span class="type">int</span> literal into a <span class="type">float</span>
for us, as long as that is possible without loss of precision. We could pass <span class="lit">2</span> instead of <span class="lit">2.0</span>, but
passing a very long <span class="type">int</span> literal with more than 16 digits may fail at compile time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p(i, j, k: int; x, y: float; s: string) =
  echo s

var
  n: int16
  m: int # int64 would not compile
  z: float32
p(n, n, m, 1234567890, z, "")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually <span class="type">float32</span> types and <span class="type">int</span> literals up to ten digits seems to work for <span class="type">float</span> parameters, but even on 64
bit systems the <span class="type">int64</span> data type is not allowed for <span class="type">int</span> parameters. As you see from the example above, it is
possible to pass the same variable multiple times as a parameter, and empty string literals are of course allowed too.</p>
</div>
<div class="paragraph">
<p>Nim does also support default values for <span class="proc">proc</span> parameters and named parameters, that is that we can leave parameters unspecified
and use the default value, or
use the actual parameter names like in a variable
assignment when we call a <span class="proc">proc</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p(i: int; x: float; s: string = "") = echo i.float * x, s
p(x = 2.0, i = 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we used named parameters when calling the <span class="proc">proc</span> <span class="func">p()</span>, this way we can freely order the parameters, and as parameter <span class="var">s</span> has a default value, we
can let it unspecified and just use the default value.</p>
</div>
<div class="paragraph">
<p>Functions always return a result, and procedures can return a result, but they don&#8217;t have to.
In the C language function results can just be ignored, but in Nim whenever there is a result, then we have to
use it at the call site, that is we have to assign the returned value to a variable, or we have to use it in an expression.
Nim enforces this, as generally the returned value is important, the returned value may be the actual
result as in a <span class="func">sin()</span> call, or it may give us additional information, like the number of read characters
when we do text processing or maybe an error indication, like end of file. For the rare conditions when we
really intend to ignore the result of a function call, we can call that function as <span class="code">discard myProcWithResult(a, b,&#8230;&#8203;)</span>.
Another solution is to apply the {.discardable.} pragma to the function definition, we will learn more about pragmas later.
When a procedure should not return a result, then we can use the <span class="type">void</span> return type or just leave the return type out&#8201;&#8212;&#8201;the latter is recommended, <span class="type">void</span> types are used only rarely in Nim. When the <span class="proc">proc</span> has no parameters at all, then we can even leave out
the empty parameter list in the <span class="proc">proc</span> definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p1() =
  echo "Hello and goodbye"

proc p2 =
  echo "Hello and goodbye"

proc p3: void =
  echo "Hello and goodbye"</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_calling_procedures">Calling Procedures</h4>
<div class="paragraph">
<p>When we call a procedure or a function, that is when we intend to execute it, then we have
always to specify a parameter list enclosed in brackets, but the parameter list can be empty:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i = myFunc(7)
var j = myF()
var p = myF # not a function call, but assignment of the proc to variable p</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the last line in the above code is not a call of <span class="func">myF()</span>, but an assignment of that function to
the variable <span class="var">p</span>. Will will discuss this use case soon.</p>
</div>
<div class="paragraph">
<p>We have already learned, that we can also use the method call syntax, like 7.myFunc instead of myFunc(7),
and we can use the command invocation syntax like in <span class="code">echo "Hello"</span> and that we should avoid putting a space
between the <span class="proc">proc</span> name and the opening bracket as that would be interpreted as a call with a tuple argument.
When the function or <span class="proc">proc</span> expects multiple arguments, then we separate the arguments with commas, and
we put generally a space after each comma:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p(i, j: int) = i + j
echo p(1, 2) # ordinary proc call
echo 1.p(2) # method call syntax
echo p 1, 2 # command invocation syntax
echo p (1, 2) # argument looks like a tuple, so this would not compile</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the <span class="proc">proc</span> definition above, we wrote the body statement directly after the equal sign&#8201;&#8212;&#8201;that
is possible, and sometimes used for very short <span class="proc">procs</span>. And indeed, here <span class="func">p()</span> is a function.</p>
</div>
<div class="paragraph">
<p>In the examples above we have passed plain integers as parameters to procedures, but
of course <span class="proc">proc</span> parameters can have any type, we can pass strings, array, objects and all that.
The way we pass the parameters to the <span class="proc">procs</span> is sometimes called "pass by value", an old term
introduced for the Pascal language, used to indicate that the passed parameter seems to be copied
to the <span class="proc">proc</span>, the <span class="proc">proc</span> is not able to modify the original instance. In the next section, we will
learn about the <span class="key">var</span> parameter type, which is used when we want to allow the <span class="proc">proc</span> to modify the
original instance. In the wirthian languages the procedure parameters actually get copied, so
inside the <span class="proc">proc</span> we could modify it, but we modified only the copy, the original instance remained unchanged.
In Nim, it is a bit different. When we pass parameters by value to a <span class="proc">proc</span>, we can not modify it at all
in the <span class="proc">proc</span> body. When we require a mutable copy, we have to generate that copy ourself in the <span class="proc">proc</span> body.
This allows some optimizations: Nim needs not really to copy the proc parameters, as they are immutable, Nim can just
work with pointers to the original instances internally. Actually there are rumors, that for parameters
smaller than <span class="code">3 * sizeof(float)</span> Nim copies the instances, but for larger instances Nim works internally
with pointers to the original value. But this is an implementation detail&#8201;&#8212;&#8201;data copied to the <span class="proc">procs</span>
stack allow the fastest access, but on the other hand the initial copy process can be expensive, so it is a compromise.</p>
</div>
</div>
<div class="sect3">
<h4 id="_procedure_parameters_of_var_type">Procedure Parameters of Var Type</h4>
<div class="paragraph">
<p>Our <span class="func">sqr()</span> function above accepts only one parameter, and that parameter is a value
type, which indicates that we can not modify it in the procedure body. That fact is
useful to know for the caller of a <span class="proc">proc</span>, as one can be sure that the passed parameter
is not modified and is available unchanged after the <span class="proc">proc</span> call.<sup class="footnote">[<a id="_footnoteref_30" class="footnote" href="#_footnotedef_30" title="View footnote.">30</a>]</sup>
But of course there
are situations where we may want that a passed parameter is modified. Let us assume that
we want to "frame" a passed string, for example we want to pass in the string "Hello"
and want to change it to "* Hello *". Further, let us assume that we may sometimes
want to use other characters instead of the asterisk, maybe a <span class="lit">&#43;</span> sign.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc frame(s: var string; c: char = '*') =
  var cs = newString(2)
  cs[0] = c
  cs[1] = ' '
  insert(s, cs)
  add(s, ' ')
  add(s, c)

# we can call that proc like
var message = "Hello World"
frame(message)
echo message</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Note: In the wirthian languages we actually put the var keywords for <span class="proc">proc</span> parameters in front of the
parameter name, that is we would have to write <span class="code">proc frame(var s: string; c: char = '*') =</span> for the
procedure header.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The frame <span class="proc">proc</span> above accepts two parameters and returns no result. The first
parameter has the type <span class="type">string</span>, it is not a value parameter but a <span class="key">var</span> parameter, which
is indicated by the <span class="key">var</span> keyword between the colon and the type of the parameter. Note
that we use here again the keyword <span class="key">var</span> that we used earlier to declare variables. The
main reason that we use again the same keyword is that we do not want to use a new
one&#8201;&#8212;&#8201;<span class="key">var</span> <span class="proc">proc</span> parameters are different from <span class="key">var</span> declarations. Parameters of <span class="key">var</span> type can
be modified in the procedure body, and that modification is visible after the <span class="proc">proc</span>
call.<sup class="footnote">[<a id="_footnoteref_31" class="footnote" href="#_footnotedef_31" title="View footnote.">31</a>]</sup> The second <span class="proc">proc</span>
parameter is a plain value type, it is a character which has the default value '*'.
To specify a default value for a parameter, we write an equal sign after the parameter type followed by the
actual default value, like we would do it in an assignment. Indeed, as in an assignment, we can even leave out the
colon with the data type in this case, at least for the case that the compiler can infer the correct data type from the assigned default value.
Default values are useful for parameters that have in most cases the same value, but
can be different sometimes. The advantage is, that when calling that <span class="proc">proc</span> we can just
leave that parameter out. For default values we have to be a bit careful, only value
parameter can have default values, and when we call a <span class="proc">proc</span> with many parameters with
default values it may be not always clear which parameter we pass and for which
parameter we want a default value.</p>
</div>
<div class="paragraph">
<p>To generate the frame around the passed in <span class="type">string</span>, we have to insert two characters at
the front of the <span class="type">string</span>, and to append two more characters. Inserting in strings is not a
very cheap operation, as it involves moving all following characters. So we try not
to insert two single characters, but we first create a short <span class="type">string</span> consisting of the
passed <span class="var">c</span> character and a white-space character, and then insert that two character
<span class="type">string</span> at the front of the passed string. We use the standard procedure <span class="func">newString()</span>
with parameter <span class="lit">2</span> to create a new <span class="type">string</span> of length <span class="lit">2</span> with undefined content, and then
fill in the content by using the subscript operator. We could have used the <span class="func">add()</span>
proc to add that two characters to an empty <span class="type">string</span>, but that is a bit slower. Then we
use the standard procedure <span class="func">insert()</span> to insert our two character <span class="type">string</span> at the front
of our passed string. Finally, we add a white-space and the <span class="var">c</span> character to the passed
string. The passed string is now modified, it is 4 characters longer. That
modification is noticeable for the caller of that <span class="proc">proc</span>, that is, <span class="func">echo()</span> will print the
modified version.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Passing mutable arguments to procedures by use of the <span class="key">var</span> keyword was sometimes
called "pass by reference" in the old wirthian languages like Pascal. This leads to confusion
for some people, unfortunately. Of course, <span class="proc">proc</span> <span class="key">var</span> parameters are not really related to Nim&#8217;s
<span class="key">ref</span> type. Well, using Nim&#8217;s <span class="key">ref</span> data types would also allow modifying <span class="proc">proc</span> arguments,
in the same way as using pointers would do it. But we never use <span class="key">ref</span> types in Nim just to be able
to modify passed data in <span class="proc">procs</span>, and also not to avoid a possible expensive copy operation
for value types. We could create a <span class="key">ref</span> instance with <span class="code">var intRef: ref int = new int</span>, pass that <span class="var">intRef</span>
to a <span class="proc">proc</span> and so allow modifying the actual value where the <span class="var">intRef</span> points to from inside the <span class="proc">proc</span>.
But that would be silly, as the <span class="key">var</span> parameter is available for that. In Nim, we use reference
types, when we really need then, e.g. when we really need reference semantics, or when we have to create highly dynamic, many to one data types,
like tree structures.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>When we call a <span class="proc">proc</span> or function with multiple arguments, then we have to pass the
arguments in the same order as they are specified in the <span class="proc">proc</span> declaration.</p>
</div>
<div class="paragraph">
<p>Our <span class="func">frame()</span> <span class="proc">proc</span> above modifies the passed <span class="type">string</span>. We could have instead decided that
the <span class="proc">proc</span> should not modify the <span class="type">string</span>, but should return a new <span class="type">string</span> consisting of
the frame and the passed <span class="type">string</span> in the center. Generally when creating <span class="proc">procs</span> we have
to decide what is more useful&#8201;&#8212;&#8201;modifying a passed value or returning a modified
copy. And sometimes we have to regard efficiency too. Returning newly created large
data types like strings may be expensive. A <span class="type">string</span> is not a trivial structure, as it
contains the dynamic buffer for the <span class="type">string</span> content, which has to be allocated. On the
other hand, for the passed <span class="key">var</span> <span class="type">string</span> we inserted characters, which involves moving
characters and is also not a really cheap operation, and maybe when we insert a lot,
the string buffer must be even enlarged, which is again expensive. So for this use
case, it is not really clear what approach is better&#8201;&#8212;&#8201;we used the <span class="key">var</span> parameter
mainly to introduce <span class="key">var</span> parameters. OK, let us investigate how a function that
returns a modified string may look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func framed(s: string; c: char = '*'): string =
  var res = newStringOfCap(s.len + 4)
  add(res, c)
  add(res, ' ')
  add(res, s)
  add(res, ' ')
  add(res, c)
  return res

# we can call that proc like
echo framed("Hello World")
echo framed("Hello World", '#')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Above code is one possible solution. We can use the keyword <span class="key">func</span> instead of <span class="key">proc</span> here
as we only return a result but modify no states. We pass the initial <span class="type">string</span> and the
character for the frame both as plain value parameters and return a newly created
framed <span class="type">string</span>. In the function body, we start with an optimized version of the
procedure <span class="func">newString()</span> from the <span class="mod">system</span> module, called <span class="func">newStringOfCap()</span>. Like
<span class="func">newString()</span> that procedure creates an empty <span class="type">string</span> variable, but it ensures that the
data buffer of the new string has exactly the specified size. That is an
optimization, which makes sense in our use case, as we know that our newly created
<span class="type">string</span> will have <span class="lit">4</span> characters more than the passed <span class="type">string</span>. So we can avoid that the
result <span class="type">string</span> has to be enlarged while we add characters or the initial <span class="type">string</span>, and
we ensure at the same time that no space is wasted&#8201;&#8212;&#8201;the data buffer size of the new
<span class="type">string</span> will be a perfect fit for the desired result. The rest of the function body
is not really interesting, we just <span class="func">add()</span> what is needed and return the result. Well,
earlier we said that <span class="func">add()</span> is not extremely fast. So when you have to frame millions
of strings each day you may consider avoiding <span class="func">add()</span>, and you know already enough
about Nim to do it. Just try it. You may start with a <span class="func">string</span> of right size
containing undefined content created by <span class="func">newString(s.len &#43; 4)</span> and then you may copy in
the required data in a loop character for character. Or you may use the slice
operator to insert the passed <span class="type">string</span> into the new <span class="type">string</span>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Click to see a possible solution</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func framed(s: string; c: char = '*'): string =
  var res = newString(s.len + 4)
  res[0] = c
  res[1] = ' '
  res[2 .. s.high + 2] = s # we may insert the string by using the slice operator or
  # for p in 0 .. s.high: # we can use a for loop and
  #   res[p + 2] = s[p] # the subscript operator
  res[^2] = ' '
  res[^1] = c
  return res</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>The situation that we may need a procedure that works on a <span class="key">var</span> parameter in one case
and returns a modified copy in another case is not that rare. So for example, Nim&#8217;s
standard library contains a procedure called <span class="func">sort()</span> which can sort container data
types in place, and a procedure called <span class="func">sorted()</span> which returns a sorted copy. This
code duplication is not really that nice. Of course, <span class="func">sorted()</span> is the more universal
solution, as we can always replace <span class="func">sort(data)</span> with <span class="code">data = sorted(data)</span>. But the
latter creates a temporary copy, which may not be optimal for performance. Since Nim
version 1.2 a <span class="func">dup()</span> macro is available from <span class="mod">sugar</span> module which creates copies of
variables and then applies one or multiple in place <span class="proc">procs</span> on the copy. So the <span class="proc">procs</span>
<span class="func">sorted()</span> or our <span class="proc">proc</span> <span class="func">framed()</span> would be unnecessary. We can use <span class="func">dup()</span> as in this
example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from sugar import dup

proc frame(s: var string; c: char = '*') =
  var cs = newString(2)
  cs[0] = c
  cs[1] = ' '
  insert(s, cs)
  add(s, ' ')
  add(s, c)

echo "Hello World".dup(frame)
echo "Hello World".dup(frame, frame)
echo "Hello World".dup(frame('#'))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we apply <span class="func">frame()</span> two times in the line before the last one&#8201;&#8212;&#8201;in the same
way, we could apply a sequence of different <span class="proc">procs</span>. The result of the above program is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>* Hello World *
* * Hello World * *
# Hello World #</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_returning_from_a_procedure_and_the_implicit_result_variable">Returning from a Procedure and the implicit Result variable</h4>
<div class="paragraph">
<p>The execution of a procedure terminates when the last statement of the procedure body
has been processed. We can also terminate a procedure earlier when we specify a
<span class="key">return</span> statement somewhere.</p>
</div>
<div class="paragraph">
<p>Functions and procedures which return a result can also terminate with the last
expression of the procedure body, or earlier with a return expression like
<span class="code">return i * i</span>. Functions and procedures with a result declare automatically a mutable
<span class="var">result</span> variable for us, which is of the function&#8217;s return type and which we may use or just ignore. So for our previous <span class="func">sqr()</span>
function, we have various ways to write it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func sqr1(i: int): int =
  i * i

func sqr2(i: int): int =
  result = i * i

func sqr3(i: int): int =
  return i * i</code></pre>
</div>
</div>
<div class="paragraph">
<p>For short and simple procedures, the first form is often used. For longer procedures,
where the result is constructed in multiple steps, like some <span class="type">string</span> operations, using
the <span class="var">result</span> variable makes sense. And finally, when there exist multiple points where
we may jump back using <span class="key">return</span> statements may make sense. One use case is an early
error check, maybe we want to <span class="code">return -1</span> as some form of error indication when we
write a procedure that should calculate the square root of an integer value. (Well in
Nim we have other and sometimes better ways to catch errors, we will learn about that
later.)</p>
</div>
<div class="paragraph">
<p>Generally, we should avoid writing something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func sqr(i: int): int =
  result = i
  i * i</code></pre>
</div>
</div>
<div class="paragraph">
<p>as it may be unclear in this case if the expression <span class="code">i * i</span> is returned or the <span class="key">result</span>
variable with value <span class="var">i</span>. For Nim v1.6 we will get a warning or an error message in such
a case.</p>
</div>
<div class="paragraph">
<p>For the performance of our code, it may have a tiny benefit to only use the
result variable and fully avoiding return statements, as in this case for
a function call like <span class="code">var i = sqr(j)</span> the result variable may be just an alias for the
actual result i here, so that the compiler can optimize the code and avoid temporary copies.
But that are rumors, and may depend on the actual compiler version.</p>
</div>
</div>
<div class="sect3">
<h4 id="_var_return_type">Var Return Type</h4>
<div class="paragraph">
<p>A procedure, converter, or iterator may return a <span class="key">var</span> type, which can be modified by the caller.
The Nim compiler manual provides this basic example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var g = 0
proc writeAccessToG(): var int =
  result = g
writeAccessToG() = 6
assert g == 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way we can call a <span class="proc">proc</span> and immediately assign a new value to the result.
In the above example, this works, as the result is an alias for the global variable <span class="var">g</span>.</p>
</div>
<div class="paragraph">
<p>Actually used are <span class="ndef">var return types</span> for iterators like <span class="func">mitems()</span> or <span class="func">mpairs()</span>,
which allows modifying the yielded results. For details and restrictions
of the <span class="ndef">var return type</span>, you should consult the Nim compiler manual:</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/manual.html#procedures-var-return-type" class="bare">https://nim-lang.org/docs/manual.html#procedures-var-return-type</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_proc_name_overloading">Proc name overloading</h4>
<div class="paragraph">
<p>Note that we used the <span class="proc">proc</span> names <span class="var">sqr1</span>, <span class="var">sqr2</span> and <span class="var">sqr3</span> above. Using the same name with
the same argument types multiple times would result in a redefinition error, as the
compiler could not know what <span class="proc">proc</span> body should be executed when that <span class="proc">proc</span> name is
called.</p>
</div>
<div class="paragraph">
<p>But Nim supports so-called <span class="proc">proc</span> overloading, that is we can use the same name when
the parameter list is different, as the compiler can select from the parameters in
the <span class="proc">proc</span> call which <span class="proc">proc</span> has to be called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func sqr(i: real): real =
  i * i</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have only changed the parameter and result data type. Now there is no conflict
with the <span class="proc">proc</span> with the same name which we defined for integers. Note that Nim use only
the parameter list for overload resolution, but not the result type of a <span class="proc">proc</span> or
function. The reason for that is, that Nim supports type inference, and that would not
work when we would have two <span class="proc">procs</span> with the same name each accepting an <span class="type">int</span> parameter but
one returning an <span class="type">int</span> and one returning a <span class="float">float</span> number.</p>
</div>
<div class="paragraph">
<p>Nim does also support named arguments in <span class="proc">proc</span> calls, that is, we could invoke the <span class="proc">proc</span>
above with sqr(i = 2.0). Named arguments can be useful when <span class="proc">procs</span> or functions have
many arguments, maybe some with default values, and we do not remember the order of
parameters or when we want to specify only a few.</p>
</div>
</div>
<div class="sect3">
<h4 id="_objects_and_ref_objects_as_procedure_parameters">Objects and Ref Objects as Procedure Parameters</h4>
<div class="paragraph">
<p>In the previous section, we learned that we have to pass <span class="key">var</span> parameters when the
procedure should be able to mutate the variable permanently. This is also valid when
the parameters are objects. When a procedure should modify fields of an object
parameter, then we have to pass that object as a <span class="key">var</span> parameter. In the following
example, <span class="proc">proc</span> <span class="var">t1</span> gives a compiler error because that procedure tries to modify a field
of an <span class="key">object</span> while the <span class="key">object</span> instance is not passed as a <span class="key">var</span> parameter. If we
remove <span class="proc">proc</span> <span class="var">t1</span>, then we can compile and run the example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type O = object
  i: int

proc t1(o: O) =
  o.i = 7 # Error: 'o.i' cannot be assigned to

proc t2(o: var O) =
  o.i = 13

proc main =
  var x = O(i: 3)
  echo x.repr
  t2(x)
  echo x.repr

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[i = 3]
[i = 13]</pre>
</div>
</div>
<div class="paragraph">
<p>Proc <span class="var">t2</span> gets a <span class="key">var</span> parameter and can modify fields of the passed <span class="key">object</span>. Here we
used the expression <span class="code">echo x.repr</span> to print the whole object. Strings and sequences are
value objects in Nim, so you have to pass them as <span class="key">var</span> parameters when you want to
change their length or when you want to modify elements. This code would give you
compile errors, unless you add the <span class="key">var</span> keyword to make the <span class="proc">proc</span> parameters mutable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc t1(s: string) =
  s.setLen(7)
  s[0] = 'x'

proc t2(s: seq[int]) =
  s.setLen(7)
  s[0] = 13</code></pre>
</div>
</div>
<div class="paragraph">
<p>This was not really surprising. But what when we use a reference to an <span class="key">object</span> and
pass that to procedures as value and as <span class="key">var</span> parameter? In the code below, <span class="proc">proc</span> <span class="var">t1</span>
gets a variable of type <span class="key">ref object</span> and the procedure can modify fields of the passed
instance. That can be indeed surprising. In this case, passing the <span class="key">ref object</span> without
use of the <span class="key">var</span> keyword means only that we can not mutate the <span class="key">ref</span> value itself in the
procedure, but we are allowed to modify the fields of the object. For <span class="proc">proc</span> <span class="var">t2</span>, we
pass a <span class="key">var</span> parameter. As always, we can modify a <span class="key">var</span> parameter in the procedure, so we
can assign it a newly created instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type O = ref object
  i: int

proc t1(o: O) =
  o.i = 7

proc t2(o: var O) =
  o = O(i : 11)

proc main =
  var x = O(i : 3)
  echo x.repr
  t1(x)
  echo x.repr
  t2(x)
  echo x.repr

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run above code, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>ref 0x7f054a904050 --&gt; [i = 3]

ref 0x7f054a904050 --&gt; [i = 7]

ref 0x7f054a904070 --&gt; [i = 11]</pre>
</div>
</div>
<div class="paragraph">
<p>For a <span class="key">ref object</span>, the <span class="func">repr()</span> function gives us the address of the <span class="key">object</span> instance in
memory and the contents of its fields. The first two <span class="func">echo()</span> statements shows the same
address, indicating that <span class="proc">proc</span> <span class="var">t1</span> has modified only a field of our instance, the
instance itself (its address in memory) was not changed. But <span class="proc">proc</span> <span class="var">t2</span> has created a
new instance and assigned that value to the variable <span class="var">x</span> in the <span class="var">main()</span> procedure. We
notice this as the address of variable <span class="var">x</span> has changed. The old instance variable with
address <span class="lit">0x7f054a904050</span> is now unused and will be freed by the Nim memory management.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_special_argument_types_openarray_and_varargs">Special Argument Types: OpenArray and Varargs</h3>
<div class="paragraph">
<p>The <span class="type">openArray</span> and <span class="type">varargs</span> data types can be used only in parameter lists. <span class="type">OpenArray</span>
is a type which allows to pass arrays and sequences to the procedure or function.
Allowing that makes sense, as arrays as well as sequences store their content in a block of
memory, which can be processed uniformly. Although arrays generally do not have to
start with index number <span class="lit">0</span>, when passed as <span class="type">openArray</span> the first element is mapped to
index <span class="lit">0</span>, and the index of the last element is available by using the <span class="func">high()</span> function
on the passed array parameter. Whenever we write a procedure that accepts an array or
a sequence, we should consider using the <span class="type">openArray</span> parameter type to allow passing in
both data types. <span class="type">Strings</span> can be passed also to <span class="proc">procs</span> accepting <span class="type">openArrays</span> with <span class="type">char</span>
base type. Note that a <span class="proc">proc</span> with <span class="type">openArray</span> parameter type can not change the length
of a passed <span class="type">seq</span>, as for the <span class="type">openArray</span> parameter type sequences are handled like
arrays. So in the code below, <span class="proc">proc</span> <span class="var">t1</span> generates a compiler error while <span class="var">t2</span> compiles
and works fine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc t1(x: var openarray[int]) =
  x.setLen(7)

proc t2(x: var seq[int]) =
  x.setLen(7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="type">varargs</span> parameter type is similar to the <span class="type">openArray</span> type, but it additional allows
passing an arbitrary number of single arguments. The compiler automatically collects
the single arguments into an array for us, so in the <span class="proc">proc</span> body we can use it like an
array, e.g. iterating over it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc print(s: varargs[string]) =
  for el in s:
    stdout.write(el)
    stdout.write(", ")
  stdout.write('\n')

print("Hello", "World") # compiler builds the array for us
print(["Hello", "World"]) # we generate the array our self</code></pre>
</div>
</div>
<div class="paragraph">
<p>There exists a variant of the <span class="type">varargs</span> argument type that performs a type conversion
automatically by applying a <span class="proc">proc</span> on all arguments. For example, <span class="code">varargs[string, <code>$</code>]</span>
would apply the stringify operation on the passed arguments automatically. That is
what <span class="func">echo()</span> does.</p>
</div>
<div class="paragraph">
<p><span class="type">Varargs</span> arguments may be only allowed for the last argument in a parameter list.</p>
</div>
<div class="paragraph">
<p>Finally, we may wonder if it makes sense to specify a parameter of type <span class="type">var varargs</span>.
If we try to pass a constant string this will obviously not work, and if the compiler
generates an <span class="type">array</span> for us, it does also not work, the automatically generated <span class="type">array</span>
seems to behave like a constant <span class="type">array</span>. But may we pass an <span class="type">array</span> variable? Let us try:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc print(s: var varargs[string]) =
  s[0] = "Goodbye"
  for el in s:
    stdout.write(el)
    stdout.write(", ")
  stdout.write('\n')

var msg = ["Hello", "World"]
print(msg)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Surprisingly that does not compile, while it works when we replace <span class="type">varargs</span> with
<span class="type">openArray</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_procedures_bound_to_a_data_type">Procedures bound to a Data Type</h3>
<div class="paragraph">
<p>In some other programming languages like Python or Ruby, we can define class methods
or static methods which are bound to a class or type and can be called as
MyType.myProc. In Nim, we can do something similar by use of the <span class="key">typedesc</span> <span class="proc">proc</span>
parameter type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
    Factory = object
        name: string

proc start(t: typedesc[Factory]) =
    echo "Factory.start"

Factory.start</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we used the method call syntax instead of <span class="func">start(Factory)</span>. We will learn more
about the <span class="key">typedesc</span> data type later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_scoping_visibility_and_locality">Scoping , Visibility and Locality</h3>
<div class="paragraph">
<p>Scoping, visibility and locality is an important concept in computer programming to
keep the source code clean. Imagine that a variable which we declare at some point in
our program would be visible everywhere. That would even for medium size programs
generate a lot of confusion&#8201;&#8212;&#8201;whenever we would need a variable, we would have to
carefully check which names are already in use. And for performance it would be bad
also, as all variables declared somewhere would reside permanently in memory.</p>
</div>
<div class="paragraph">
<p>So most programming languages including Nim support the concept of locality&#8201;&#8212;&#8201;names
declared inside a procedure body or inside another form of block are only visible
there and can only be used there. We say that they are only visible in that scope.
For Nim we can say that whenever Nim&#8217;s syntax requires a new level of indentation,
that is a new statement block, then all symbols declared in that block are only
visible in that block and in sub-blocks of this block, but not outside that block.
Nim has another important concept of visibility, which is called modules and allows
separation of our code in logically separated text files with well-defined visibility
rules, we will discuss modules later.</p>
</div>
<div class="paragraph">
<p>Visibility is really a simple concept, let us regard this useless example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var e: float = 2.7

proc p1 =
  var x: float = 3.1415
  if x &gt; 1.0:
    var y = 2.0 * x
    echo y # OK
  echo x # OK
  echo y # compile error, y is not visible
  echo e # OK, e is declared globally, so it is visible everywhere

echo e # OK
echo x # ?
echo y # ?</code></pre>
</div>
</div>
<div class="paragraph">
<p>In line one we declare a so-called global variable, that one is visible after
declaration, that is below the line where it is declared, in the entire program. The
variables declared in the <span class="proc">proc</span> <span class="var">p1</span> are called local variables, they are not visible
outside that <span class="proc">proc</span> <span class="var">p1</span>. The variable <span class="var">x</span> is declared at the start of the <span class="proc">proc</span> body and
is visible in the whole <span class="proc">proc</span> everywhere, while variable <span class="var">y</span> is declared in the <span class="key">if</span> block
and is visible only there. So it should be clear if the last two echo statements for
<span class="var">x</span> and <span class="var">y</span> compile fine? Remember that symbols that we define inside a new scope
may shadow symbols that were visible outside the actual block, e.g. by defining a variable
named <span class="var">e</span> of arbitrary type in the <span class="proc">proc</span> <span class="var">p1</span> from above would shadow the global variable <span class="var">e</span>, that is the global variable <span class="var">e</span>
would become invisible until execution of <span class="proc">proc</span> <span class="var">p1</span> terminates. We discussed shadowing
already in the introducing section <a href="#Blocks">Scopes, Visibility, Locality and Shadowing</a>.</p>
</div>
<div class="paragraph">
<p>Related to visibility of variables is their lifetime, that is the duration of how long
they exist and how long they can store a value. Global variables exist for the entire
program runtime&#8201;&#8212;&#8201;when you have assigned a value to it that value can be used
everywhere as long as the program runs, and as long as you do not assign a different
value of course. Global variables are generally stored in a special memory region
that is called the BSS region.</p>
</div>
<div class="paragraph">
<p>Variables of value type defined locally inside a procedure or function do exist only
for the execution time of that <span class="proc">proc</span>, that is, they are created when the <span class="proc">proc</span> is
invoked and vanish when the <span class="proc">proc</span> terminates, that is when execution continues with
the statement following on the <span class="proc">proc</span> call.</p>
</div>
<div class="paragraph">
<p>Local variables declared in a <span class="proc">proc</span> reside in a special memory region of the RAM, which
is called the stack. The stack is nothing more than an arbitrary part of the hole RAM
that is used in some clever fashion: The memory words in it are used in consecutive
order. A so-called stack pointer is used to indicate the address of the first free
area in that stack. So when a <span class="proc">proc</span> is called, which may have <span class="var">n</span> bytes of local
variables, then the compiler can use the area where the stack pointer points to for
that variables, and when the <span class="proc">proc</span> is called then the stack pointer is increased by
that size. So the stack pointer points again to the next free area of the stack, and
another <span class="proc">proc</span> can be called in the same way from within the current <span class="proc">proc</span>. Whenever a
proc terminates, the stack pointer is set back to the value which it had when the
proc starts execution. This method of memory management is simple and fast, but it
does only work when the total amount of memory that the local variables in a <span class="proc">proc</span>
needs is known at compile time, so that the compiler can adjust the stack pointer
accordingly. It does not work for dynamically sized data types like strings or
sequences.</p>
</div>
<div class="paragraph">
<p>Note that pointers and references are value types itself, we can regard pointers and
references as a plain integer variable interpreted in a special way&#8201;&#8212;&#8201;as a memory
location. But the memory blocks to which the pointers and references may point and
that are allocated by <span class="func">alloc()</span> or <span class="func">new()</span> is different: That memory blocks are not
allocated on the stack, but in the ordinary RAM which we call heap to separate it
from the stack.</p>
</div>
<div class="paragraph">
<p>So why can the stack not be used for memory blocks which <span class="func">alloc()</span> or <span class="func">new()</span> provides
for us: An important fact for the use of the stack to store variables is that the
total size which is needed by a <span class="proc">proc</span> for all the static variables must be a compile-time
constant. The stack pointer is adjusted by that amount when the <span class="proc">proc</span> starts, and
all the local variables are accessed with a fixed offset to that stack pointer then.
When we use <span class="func">alloc()</span> or <span class="func">new()</span> in a <span class="proc">proc</span>, then we may call that multiple times like we
did in our previous list example, and for <span class="func">alloc()</span> an additional fact is that the byte
size that <span class="func">alloc()</span> should reserve can be a runtime value. So the total amount of RAM
that <span class="func">alloc()</span> or <span class="func">new()</span> would allocate is a runtime value, and we can not use the stack
for it. Instead, <span class="func">alloc()</span> and <span class="func">new()</span> allocates a block of memory in a more dynamic
fashion, which is basically that they ask the OS for a free block of right size
somewhere in the available RAM. That block is later given back to the OS for reuse by
functions like <span class="func">dealloc()</span> or automatically by the GC.</p>
</div>
<div class="paragraph">
<p>Let us at the end of this section investigate some special cases:</p>
</div>
<div class="paragraph">
<p>While in languages like C we have always a well-defined <span class="func">main()</span> function and all
program code is contained in this function or in other functions which are called
from this main function, in Nim we have also global code as in scripting languages
Ruby or Python:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i: int
while i &lt; 100:
  var j: int
  j = i * i
  echo j
  inc(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should be clear that the global variable <span class="var">i</span> resides in the BSS segment. But what is
with the variable <span class="var">j</span> declared in the body of the <span class="key">while</span> statement? It is clear that
that variable is only visible inside the body of the <span class="key">while</span> statement. But does <span class="var">j</span>
reside on the stack? There seems to be no <span class="proc">proc</span> involved, so there may be no stack? The
variable <span class="var">j</span> may reside in the BSS segment too? That is not really clear and may be
different for different Nim compilers, maybe. But why should we care for that detail
at all? Well, it may be important for performance. Local <span class="proc">proc</span> variables allocated on
the stack are generally optimal for performance, and they are optimized by the
compiler very well. We will learn more about the reasons for that later when we
discuss the data cache. For now, we should only remember that it may be a good idea to
avoid global code and put all code in <span class="proc">procs</span>. We may have an arbitrary named <span class="func">main()</span>
proc then and call that from global scope only. At least for the current Nim v1.6
that seems to be a good idea, potentially later versions or other implementations will
automatically move all global code into a hidden <span class="proc">proc</span> for us.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For optimal performance, put all your code in procedures or functions and avoid
global code and when possible global variables.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let us discuss the above while loop again, but this time in the body of a <span class="proc">proc</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p =
  var i: int
  while i &lt; 100:
    let j: int = i * i
    echo j
    inc(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we carefully investigate that <span class="proc">proc</span> within the while loop, we may wonder about two
points. First, we said earlier that we can and should use the <span class="key">let</span> keyword instead of
<span class="key">var</span> when there is only one assignment to a variable, so the variable can be regarded
as immutable. But the loop is executed 100 times, so how can we say there is only a
single assignment to variable <span class="var">j</span>? The trick is, that <span class="var">j</span> is locally to the <span class="key">while</span> loop,
and that <span class="var">j</span> is virtually newly created and initialized to <span class="lit">0</span> for each iteration. So let
is OK and the compiler does not complain.</p>
</div>
<div class="paragraph">
<p>We can test that fact with this simple program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var i: int
  while i &lt; 10:
    var a: int
    a = a + 1
    echo a
    inc(i)
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output is <span class="lit">1</span> for each loop iteration, as variable <span class="var">a</span> is virtually newly created for
each loop iteration.</p>
</div>
<div class="paragraph">
<p>We said virtually newly created, because we can not be sure how the compiler may
handle it internally. Is storage for variable <span class="var">a</span> already allocated when the <span class="proc">proc</span> is
invoked, that is, in the same way as storage for the loop counter variable <span class="var">i</span> is
allocated on the stack when the <span class="proc">proc</span> is called. Or is storage for variable <span class="var">a</span> reserved
for each loop iteration by increasing the stack pointer at the start of the loop and
resetting it at the end of the loop. We can not be sure without reading the compiler
source code, but finally we should not care, as it does not really matter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_generics">Generics</h3>
<div class="paragraph">
<p>In the previous section, we defined a <span class="func">sqr()</span> <span class="proc">proc</span> for <span class="type">ints</span> and one for <span class="type">float</span> numbers.
Both <span class="proc">procs</span> look nearly identical, only the data types differ. For that case, we can
use so-called generic procedures.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func sqr[T](v: T): T =
  var p: T
  p = v * v
  return p

echo sqr(2)
echo sqr(3.1415)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We put a square bracket after the function name which includes a symbolic name, and
that name is then used instead of concrete types in the <span class="proc">proc</span> header or in the <span class="proc">proc</span>
body.</p>
</div>
<div class="paragraph">
<p>We can now call that <span class="proc">proc</span> with parameters of different types, including <span class="type">int</span> and <span class="type">float</span>
types. You may wonder why that works&#8201;&#8212;&#8201;Nim is a statically typed language, so how
can the parameter of function <span class="func">sqr()</span> as well accept an integer as a floating point number? Is
there a hidden type conversion involved? No, the trick is that whenever we call that
generic <span class="proc">proc</span> with a different type, then a new <span class="proc">proc</span> or function is instantiated. As
we called the generic <span class="func">sqr()</span> <span class="proc">proc</span> with an <span class="type">int</span> and a <span class="type">float</span> parameter, during compile
time the compiler creates machine code for two separate functions, one which is called
when an <span class="int">int</span> is passed as parameter, and one which is called when a <span class="type">float</span> is passed.
If we called that <span class="proc">proc</span> name again with an <span class="type">int</span> or <span class="type">float</span> parameter, then one of the
two existing <span class="proc">procs</span> would be used. But for a different, still unused data type like
<span class="type">float32</span>, again a new <span class="proc">proc</span> would be instantiated. In this way, generics <span class="proc">procs</span> can lead
to some code bloat. Note that calling the generic function with a data type like a
character or a <span class="type">string</span> would fail, as that types do not support multiplication with
itself.</p>
</div>
<div class="paragraph">
<p>A slightly different notation is available by so called <span class="op">or</span> types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func sqr(v: int or float): auto =
  var p: typeof(v)
  p = v * v
  return p

echo sqr(2)
echo sqr(3.1415)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we have limited the parameter types to the <span class="type">int</span> type or the <span class="type">float</span> type. We could
have defined also a custom type first, like <span class="code">type MyNum = int or float</span>, and use that
type for the type of our <span class="func">sqr()</span> <span class="proc">proc</span>. These <span class="code">or types</span> are also called
<span class="code">type classes</span>. Instead of keyword <span class="key">or</span> the <span class="key">|</span> character can be
used for defining type classes. Again, the compiler would instantiate two separate
functions for the both data types. As we had not the symbolic type T available here,
we have used the keyword <span class="key">auto</span> as return type, and for the type of variable <span class="var">p</span> we used
the macro <span class="func">typeof()</span>. The type <span class="key">auto</span> for the return type works as long as the function
returns a well-defined type. Note that we can not decide at runtime what a type the
function should return, so a construct like <span class="code">if cond: return 2 else: return 3.1415</span>
would not work, at least not when the values are variables of different type. For the
literal value, it may work, as the compiler may be smart and guess that we want to
return the <span class="type">float</span> literal <span class="lit">2.0</span>.</p>
</div>
<div class="paragraph">
<p>A bit of care is needed when we define <span class="proc">procs</span> for mutable <span class="code">or types</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># proc t(s: var seq[uint8] | var seq[char]) =
proc t(s: var (seq[uint8] | seq[char])) =</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we try to define a <span class="proc">proc</span> called <span class="var">t</span> which should accept a mutable <span class="var">seq[uint8]</span> or a
mutable <span class="var">seq[char]</span> as parameter. While the first line compiles fine, the <span class="var">seq[char]</span>
would be immutable. The correct notation is shown in the second line. This behavior
was labeled "won&#8217;t fix" in GitHub issue tracker, so we have to remember this case,
see <a href="https://github.com/nim-lang/Nim/issues/15063#issue-665553657" class="bare">https://github.com/nim-lang/Nim/issues/15063#issue-665553657</a>.</p>
</div>
<div class="paragraph">
<p>Let us assume that you want to define a <span class="proc">proc</span> that accepts two numbers of type <span class="type">int</span> or
<span class="type">float</span> and that returns a <span class="type">float</span>. You may write it in one of these ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc sqrsum(x, y: int | float): float =
  (x * x).float + (y * y).float

proc sqrsum2[T](x, y: T): float =
  (x * x).float + (y * y).float

proc sqrsum3[T1, T2](x: T1; y: T2): float =
  (x * x).float + (y * y).float

var i: int = 2
var x:float = 3.0

echo sqrsum(i, x)
#echo sqrsum2(i, x)
echo sqrsum2(x, 2)
#echo sqrsum2(2, x)
echo sqrsum3(i, x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The commented out lines would give you a compiler error. The reason for this is that
the <span class="proc">proc</span> <span class="var">sqrsum2[T]</span> defines a generic <span class="proc">proc</span>, but the compiler enforces that both
parameters have the same type. The expression <span class="func">sqrsum2(x, 2)</span> compiles fine,
as due to the first parameter <span class="var">x</span> the compiler instantiates a <span class="proc">proc</span> for a <span class="type">float</span>
parameter type, and then converts the second parameter, which is an integer literal,
to <span class="type">float</span> automatically. This automatic conversion is only done for literal numbers,
not for variables. The expression <span class="func">sqrsum2(2, x)</span> does not compile, as due to
the first parameter, which is an integer literal, a <span class="proc">proc</span> for integer parameters is
instantiated, and the second <span class="var">x</span> parameter of <span class="type">float</span> type is not compatible with the
instantiated <span class="proc">proc</span>.</p>
</div>
<div class="paragraph">
<p>Generics can become a bit complicated, as we may use multiple different generic types
for different <span class="proc">proc</span> parameters. And we can use generics also for object types, we may
for example create lists like we did for our names list that work not only for
<span class="type">strings</span>, but that can work with other data types like numbers or sequences in a very
similar way. We may explain that in more detail later.</p>
</div>
</div>
<div class="sect2">
<h3 id="_example_for_the_use_of_generics">Example for the use of Generics</h3>
<div class="paragraph">
<p>Generics are used a lot in Nim&#8217;s standard library. Most container types like sequences or tables
accept generic types, and generic procedures like <span class="func">sort()</span> are provided which can easily sort
arbitrary data types and objects. We have only to provide a <span class="func">cmp()</span> <span class="proc">proc</span> for our user defined
data types, which <span class="func">sort()</span> can call to compare the values during the sorting process.</p>
</div>
<div class="paragraph">
<p>We will demonstrate the use of generics for library modules with a few tiny examples: Assume
we create a library which should be able to store and process arbitrary data types. The stored values
may have well-defined relations, which enables ordering or much more complicated spatial
relations. Triangulation of spatial data points or grouping the data in structures like
<span class="type">RTrees</span> for fast point location, as well as geometric processing with algorithm like
finding the convex hull are some examples. To make our example simple and compact, we define
a generic container type which can store only two values of arbitrary data type. The container allows sorting
the elements by size. The following code example defines a generic container called <span class="type">MyGenericContainer</span>,
a <span class="proc">proc</span> to <span class="func">add()</span> data objects into the container instance and a <span class="func">sortBySize()</span> <span class="proc">proc</span> to sort the two elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  MyGenericContainer[T] = object
    storage: array[2, T]

proc add[T](c: var MyGenericContainer[T]; x, y: T) =
  c.storage[0] = x
  c.storage[1] = y

# sort by direct field access
proc sortBySize[T](c: var MyGenericContainer[T]) =
  if c.storage[0].size &gt; c.storage[1].size:
    swap(c.storage[0], c.storage[1])

# a simple stringify proc for our container data type
proc `$`[T](c: MyGenericContainer[T]): string =
  `$`(c.storage[0]) &amp; ", " &amp; `$`(c.storage[1])

type
  TestObj1 = object
    name: string
    size: int

proc main =
  var c: MyGenericContainer[TestObj1]
  var a = TestObj1(name: "Alice", size: 162)
  var b = TestObj1(name: "Bob", size: 184)

  add(c, b, a)
  echo c
  c.sortBySize
  echo c

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">sortBySize()</span> <span class="proc">proc</span> of the above examples accesses the size field of our data objects directly, so we can
use the container for arbitrary data types as long as the data types have a size field and as long as
a <span class="op">&gt;</span> <span class="proc">proc</span> is defined for the data type of the size field. In the above example, we have defined a <span class="op">$</span> procedure
to convert instances of our container to a <span class="type">string</span>, which allows us to call the <span class="func">echo()</span> function on it.
The output of our program looks like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(name: "Bob", size: 184), (name: "Alice", size: 162)
(name: "Alice", size: 162), (name: "Bob", size: 184)</pre>
</div>
</div>
<div class="paragraph">
<p>We can avoid the restriction of a matching field name when we provide getter and setter procedures
which the library <span class="proc">procs</span> can use to access the important fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  MyGenericContainer[T] = object
    storage: array[2, T]

proc add[T](c: var MyGenericContainer[T]; x, y: T) =
  c.storage[0] = x
  c.storage[1] = y

proc sortBySize[T](c: var MyGenericContainer[T]) =
  if c.storage[0].size &gt; c.storage[1].size:
    swap(c.storage[0], c.storage[1])

proc `$`[T](c: MyGenericContainer[T]): string =
  `$`(c.storage[0]) &amp; ", " &amp; `$`(c.storage[1])

type
  TestObj1 = object # arbitrary field names
    name: string
    length: int

# this getter proc enables sorting
proc size(t: TestObj1): int =
  t.length

proc main =
  var c: MyGenericContainer[TestObj1]
  var a = TestObj1(name: "Alice", length: 162)
  var b = TestObj1(name: "Bob", length: 184)

  add(c, b, a)
  echo c
  c.sortBySize
  echo c

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, our <span class="type">TestObj1</span> data type has no field with a name matching for the
<span class="func">sortBySize()</span> <span class="proc">proc</span>, but we define a <span class="func">size()</span> <span class="proc">proc</span> for our data type which that library function
can use. This solution is more flexible, and when we add the inline pragma to the used <span class="func">size()</span> <span class="proc">proc</span>
or when we compile with link time optimization (LTO) enabled, then the overhead should be negligible.
The two examples above are located in a single file each, but of course for practical use
we would use separate modules for the library and the application part as in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">#module t3.nim
type
  MyGenericContainer*[T] = object
    storage: array[2, T]

proc add*[T](c: var MyGenericContainer[T]; x, y: T) =
  c.storage[0] = x
  c.storage[1] = y

proc sortBySize*[T](c: var MyGenericContainer[T]) =
  if c.storage[0].size &gt; c.storage[1].size:
    swap(c.storage[0], c.storage[1])

proc `$`*[T](c: MyGenericContainer[T]): string =
  `$`(c.storage[0]) &amp; ", " &amp; `$`(c.storage[1])</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import t3

type
  TestObj1 = object # arbitrary field names
    name: string
    length: int

proc size(t: TestObj1): int =
  t.length

proc main =
  var c: MyGenericContainer[TestObj1]
  var a = TestObj1(name: "Alice", length: 162)
  var b = TestObj1(name: "Bob", length: 184)

  add(c, b, a)
  echo c
  c.sortBySize
  echo c

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example with direct field access would look for different modules like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># module t4.nim
type
  MyGenericContainer*[T] = object
    storage: array[2, T]

proc add*[T](c: var MyGenericContainer[T]; x, y: T) =
  c.storage[0] = x
  c.storage[1] = y

proc sortBySize*[T](c: var MyGenericContainer[T]) =
  if c.storage[0].size &gt; c.storage[1].size:
    swap(c.storage[0], c.storage[1])

proc `$`*[T](c: MyGenericContainer[T]): string =
  `$`(c.storage[0]) &amp; ", " &amp; `$`(c.storage[1])</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import t4

type
  TestObj1 = object
    name: string
    size: int

proc main =
  var c: MyGenericContainer[TestObj1]
  var a = TestObj1(name: "Alice", size: 162)
  var b = TestObj1(name: "Bob", size: 184)

  add(c, b, a)
  echo c
  c.sortBySize
  echo c

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may wonder why we do not have to export the <span class="var">size</span> field of our <span class="type">TestObj1</span> (or maybe the object itself also) as
it is used from code defined in a different module. The reason why we do not need export markers is that
the <span class="func">sortBySize()</span> is defined in the library module, but as it is a generic procedure, it is
instantiated and executed in the application module. For the same reason, we had not to export the
<span class="func">size()</span> getter procedure before.</p>
</div>
<div class="paragraph">
<p>Finally, one more way to use generic library modules is by passing procedure variables
to the library functions. The passed in procedures may provide access to
properties or attributes of the stored objects, or they may offer relations between the
objects. The latter is often used for sorting purposes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># module tx.nim
type
  MyGenericContainer*[T] = object
    storage: array[2, T]

proc add*[T](c: var MyGenericContainer[T]; x, y: T) =
  c.storage[0] = x
  c.storage[1] = y

proc sortBy*[T](c: var MyGenericContainer[T]; smaller: proc(a, b: T): bool) =
  if smaller(c.storage[1], c.storage[0]):
    swap(c.storage[0], c.storage[1])

proc `$`*[T](c: MyGenericContainer[T]): string =
  `$`(c.storage[0]) &amp; ", " &amp; `$`(c.storage[1])</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tx

type
  TestObj1 = object
    name: string
    size: int

proc smaller(a, b: TestObj1): bool =
  a.size &lt; b.size

proc main =
  var c: MyGenericContainer[TestObj1]
  var a = TestObj1(name: "Alice", size: 162)
  var b = TestObj1(name: "Bob", size: 184)

  add(c, b, a)
  echo c
  c.sortBy(smaller)
  echo c

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we have modified the <span class="func">sort()</span> <span class="proc">proc</span> of our library module in a way that it takes
an additional procedure parameter. In this case, we use a procedure signature that takes two object instances
and returns a boolean value indicating if the first parameter is smaller than the second.
In our application module, we define a matching procedure and pass that one to the <span class="func">sortBy()</span>
procedure. Again we get the desired sorted output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(name: "Bob", size: 184), (name: "Alice", size: 162)
(name: "Alice", size: 162), (name: "Bob", size: 184)</pre>
</div>
</div>
<div class="paragraph">
<p>This last method is used often in Nim&#8217;s standard library, e.g. for sorting
sequences with custom objects. Unfortunately, this way can introduce some performance
regression, as the procedure variable has to be passed to the called <span class="proc">proc</span> and so
inlining of that passed <span class="proc">proc</span> is not possible for the compiler. <sup class="footnote">[<a id="_footnoteref_32" class="footnote" href="#_footnotedef_32" title="View footnote.">32</a>]</sup></p>
</div>
</div>
<div class="sect2">
<h3 id="_method_call_syntax">Method Call Syntax</h3>
<div class="paragraph">
<p>A useful coding style introduced by OPP languages is the method call syntax, which
was initially used in OOP programming style for objects, and later applied by
languages like Ruby to all data types. Ruby in some way regards all data as objects.</p>
</div>
<div class="paragraph">
<p>Method call syntax means, that for example for a variable <span class="var">s</span> of data type <span class="type">string</span> we do
write <span class="func">s.add(c)</span> instead of <span class="func">add(s, c)</span>. Or for an integer variable <span class="var">i</span> we may write <span class="func">i.abs</span>
instead of <span class="func">abs(i)</span>. That is, we put the first parameter of the <span class="proc">proc</span> parameter list in
front of the <span class="proc">proc</span> name, and separate that parameter from the <span class="proc">proc</span> name by a period.
The compiler regards both notation as equivalent. The advantage of the method call
syntax is that we may save a character and that it is more clear with what "object"
we are working, as it stands in front of the expression.</p>
</div>
<div class="paragraph">
<p>Most OOP languages allows that notation only for a class, for example the string
class may declare all possible operations that can be done with strings, and the
method call syntax is used for that operations. One problem is, that it can be
difficult to add more operations which can be used in that style, as often all that
operations are defined in the class scope. Ruby fixed that restriction by allowing so
called reopen of classes, that is, user can later add more operations.</p>
</div>
<div class="paragraph">
<p>Nim simple allows that notation generally, as did the D language, but D used the term
<span class="ndef">Uniform Function Call Syntax</span> (UFCS) for it.</p>
</div>
</div>
<div class="sect2">
<h3 id="_procedure_variables">Procedure Variables</h3>
<div class="paragraph">
<p>Procedures and functions are not always fully static entities. We can assign
procedures and functions to variables, and we can pass whole procedures or functions
as parameters to other procedures or functions. And functions can even generate and
return new functions. Let us investigate how procedure variables work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  p: proc(i: int): int

proc p1(i: int): int =
  i + i

proc p2(i: int): int =
  i * i

p = p1
echo p(7)
p = p2
echo p(7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the two <span class="func">echo</span> statements should be <span class="lit">14</span> and <span class="lit">49</span>&#8201;&#8212;&#8201;we called in both cases
the same <span class="proc">proc</span> variable with the same parameter, but the <span class="proc">proc</span> variable <span class="var">p</span> was in the
first call an alias for <span class="var">p1</span>, and in the second call an alias for <span class="var">p2</span>. Note, when we
assign a <span class="proc">proc</span> to a <span class="proc">proc</span> variable we do only write the name of that <span class="proc">proc</span>, there is no
<span class="func">()</span> involved. That is because we assign that <span class="proc">proc</span> to the <span class="proc">proc</span> variable, but we do not
call the <span class="proc">proc</span> in this case. Of course, when we assign a <span class="proc">proc</span> to a <span class="proc">proc</span> variable then
the <span class="proc">proc</span> signatures have to match, that is the parameter list and the result have to
be compatible.</p>
</div>
<div class="paragraph">
<p>Now we use a function as a <span class="proc">proc</span> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  EchoProc = proc (x: float)

proc t(ep: EchoProc; x: float) =
  echo "The value is"
  ep(x)

proc ep1(x: float) =
  echo "==&gt; ", x

proc ep2(x: float) =
  echo x

t(ep1, 3.1415)
t(ep2, 3.1415)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A common use case for a function as a <span class="proc">proc</span> parameter is sorting. We can use the same
sort procedure for different data types when we provide a <span class="func">cmp()</span> <span class="proc">proc</span> that can compare
that data type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from algorithm import sort

proc cmp(a, b: int): int =
  if a &lt; b:
    -1
  elif a == b:
    0
  else:
    1

proc main =
  var a = [2, 3, 1]
  a.sort(cmp)
  for i in a:
    echo i

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">sort()</span> procedure is provided by the <span class="mod">algorithm</span> module. The <span class="func">sort()</span> <span class="proc">proc</span> accepts an
array or a sequence, and a <span class="func">cmp()</span> <span class="proc">proc</span> that gets two parameters of the same type as the
elements in the passed array, and that returns -1, 0, or 1 as the result of the
comparison. We could easily sort other data types like strings or our custom objects
by an arbitrary key, as long as we can provide a matching <span class="func">cmp()</span> <span class="proc">proc</span>. For the <span class="func">cmp()</span>
proc it is important that it returns a well-defined result based on the input, and
when both parameters are equal it should really return <span class="lit">0</span>. If you exchanged the
return values <span class="lit">1</span> and <span class="lit">-1</span> in the <span class="func">cmp()</span> <span class="proc">proc</span> above, you would invert the sort order.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nested_procedures_and_closures">Nested Procedures and Closures</h3>
<div class="paragraph">
<p>While in C all functions must be defined in top level scope and nesting of functions
is not allowed, in Nim procedures can contain other procedures. A special case occurs
when the sub-procedures do access variables of the outer scope. In this case, the
sub-procedure is called a closure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc digitScanner(s: string) =

  var pos = 0
  proc nextDigit: char =
    while pos &lt; s.len and s[pos] notin {'0' .. '9'}:
      inc(pos)
    if pos == s.len:
      return '\x0'
    result = s[pos]
    inc(pos)

  var c: char
  while true:
    c = nextDigit()
    if c == '\x0':
      break
    stdout.write(c)
  stdout.write('\n')

digitScanner("ad5f2eo73q9st")</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run this program, the output should be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>52739</pre>
</div>
</div>
<div class="paragraph">
<p>This program is not that easy, but when you think about it a bit, you should be able
to understand it. The task is to extract from a string all the digits and to ignore
the other characters.</p>
</div>
<div class="paragraph">
<p>To get the digits, we use a local procedure that uses the <span class="var">pos</span> variable of the
enclosing procedure, and also access the parameter <span class="var">s</span> of the enclosing procedure. The
closure <span class="func">nextDigit()</span> checks if the position in the <span class="type">string</span> is still valid, that is, if
it is still smaller than the length of the <span class="type">string</span>, and also checks if the current
character is a digit. The first check uses the standard procedure <span class="func">len()</span> which return
the length of a passed <span class="type">string</span> parameter, that is, how many characters the <span class="type">string</span>
contains. We have used the method call syntax here instead of using the ordinary <span class="proc">proc</span>
call <span class="func">len(s)</span>. The next check test if the current character is not a decimal digit. For
that test we could use a series of compares like <span class="code">if c == '0' or c == '1' or &#8230;&#8203; or c
== '9'.</span> But to make such tests easier and faster, Nim offers one more data type, the
<span class="type">set</span> type. And the <span class="op">notin</span> operator tests if a value is not contained in a <span class="type">set</span> constant.
An important point for the expression after the <span class="key">while</span> statement is, that it is
processed from left to right. That fact is here critical, because we have first to
check if <span class="var">pos</span> is still a valid position, before we can use the subscript operator <span class="op">[]</span>
to access the current character and test if it is not contained in the <span class="type">set</span>. If the
check for the valid position would not come first, then we may access an invalid
position in the string, and we would get a runtime range error.</p>
</div>
<div class="paragraph">
<p>While the position is still valid, but the current character is not a digit, we
increase the position. The <span class="key">while</span> loop can end by two conditions: Either the current
character is a digit, or we have reached the end of the <span class="type">string</span>, and we have to stop.
For the last case we use a special stop mark, we return a special character which we
have entered in escape notation as <span class="lit">'\x0'</span>. That is a very special character, that is
used in C to mark the end of strings. It is the first character in the ASCII table
and has the decimal value <span class="lit">0</span>. We said earlier that characters are encoded in 8 bit
and correspond to the unsigned integer numbers <span class="lit">0</span> up to <span class="lit">255</span>. <span class="lit">'\x0'</span> is just a special
notation for the first character which corresponds to integer value <span class="lit">0</span>. Well, when the
end of the <span class="type">string</span> is reached, then we return that character. Otherwise, we return the
current character. Remember, from the while condition we know that the <span class="type">string</span> end is
reached, or the current character is a digit. As we tested for the <span class="type">string</span> end before, we can
only have the case that the current character is a digit now. But can we return that
character immediately now? If we would, <span class="var">s[pos]</span> would be a digit, and we would get
exactly the same character for the next <span class="proc">proc</span> call! So we have to move to the next
character by increasing <span class="var">pos</span> before we return that character. For this, the
pre-declared <span class="var">result</span> variable is useful. We assign the current character to the <span class="var">result</span>
variable, and then increase <span class="var">pos</span>. As the last statement in our <span class="proc">proc</span> is not an
expression but a plain <span class="func">inc()</span> statement, the content of the <span class="var">result</span> variable is
returned. The other <span class="key">while</span> loop in the outer procedure is very simple, we just call
the closure in the body of the <span class="key">while</span> loop and terminate the loop when we get the
special <span class="lit">Null</span> character.</p>
</div>
<div class="paragraph">
<p>And finally, an example where one <span class="proc">proc</span> returns another procedure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc addN(n: int): auto = (proc(x: int): int = x + n)

let add2 = addN(2)
echo add2(7)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of <span class="func">echo()</span> would be <span class="lit">9</span> in this case. This construct is sometimes named
currying.</p>
</div>
</div>
<div class="sect2">
<h3 id="_anonymous_procedures">Anonymous Procedures</h3>
<div class="paragraph">
<p>In the section <a href="#_module_sequtils">Module sequtils</a> in part III of the book we will introduce a few functions
which are often used in the functional programming style like <span class="func">map()</span> or <span class="func">filter()</span>.
These functions get procedures as arguments that determine how container data types
are converted. We can pass a regular named procedure as second argument to <span class="proc">procs</span> like
<span class="func">map()</span> and <span class="func">filter</span>, or in simple cases we can just pass an anonymous <span class="proc">proc</span> or use the <span class="op">&#8658;</span>
operator provided by the <span class="mod">sugar</span> module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils, sugar

proc primeFilter(x: int): bool =
  x in {3, 5, 7, 13}

var s = (0 .. 9).toSeq # @[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

echo s.filter(primeFilter) # @[3, 5, 7]
echo s.filter(proc(x: int): bool = (x and 1) == 0) # @[0, 2, 4, 6, 8]

echo s.map(proc(x: int): int = x * x) # always @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
echo s.map(x =&gt; x * x) # from sugar module</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we use the <span class="func">toSeq()</span> template to create our initial sequence with numbers <span class="lit">0</span> up to <span class="lit">9</span>&#8201;&#8212;&#8201;just to have not to type all the number in, we will explain templates soon.
Then we apply the <span class="func">filter()</span> <span class="proc">proc</span> to that sequence. The <span class="func">filter()</span> <span class="proc">proc</span> expects as second argument a function
with an argument of the seq&#8217;s base type, returning a boolean value. We can pass the named
function <span class="func">primeFilter()</span>, or we can just pass an anonymous <span class="proc">proc</span> explicitly.</p>
</div>
<div class="paragraph">
<p>In the last two lines of our example, we use the <span class="func">map()</span> function to convert the data of our sequence.
<span class="func">Map()</span> expects as second argument a <span class="proc">proc</span> with a parameter of the seq&#8217;s base type, returning a result of the same type.
In the line before the last one, we specify an anonymous <span class="proc">proc</span> as parameter, while in the last
line we use the <span class="op">&#8658;</span> operator from the <span class="mod">sugar</span> module to just specify the actual conversion.</p>
</div>
</div>
<div class="sect2">
<h3 id="_compile_time_proc_execution">Compile time proc execution</h3>
<div class="paragraph">
<p>When a function is called only with constant arguments, then the compiler can execute it
already at compile time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">func genSep(l: int): string =
  debugecho "Generating separator string"
  for i in 1 .. l:
    result.add('=')

const Sep = genSep(80) # function is executed at compile time

echo Sep</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we used a function called <span class="func">genSep()</span> to create a <span class="type">string</span> constant at compile time.
When we compile the above program, we get the message "Generating separator string". As that
proc is not executed at program runtime, it is not included in the final executable program.
Here we had to use the <span class="func">debugEcho()</span> <span class="proc">proc</span> instead of the ordinary <span class="func">echo()</span>, because
<span class="func">echo()</span> is not really a pure function, and the compiler would complain when we use
<span class="func">echo()</span> in a pure function. <span class="func">DebugEcho()</span> is not really pure as well, but the compiler ignores that
fact, which is OK for debugging purposes. We could even make <span class="func">gesSep()</span> a plain <span class="proc">proc</span> and then use
<span class="func">echo()</span>, the compiler would not complain. But it would complain, if, for instance we would access
global variables from inside the <span class="func">genSep()</span> <span class="proc">proc</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_inlining_procedures">Inlining Procedures</h3>
<div class="paragraph">
<p>Calling procedures and functions is always some overhead&#8201;&#8212;&#8201;<span class="proc">proc</span> parameters may have to put on the stack or loaded into CPU registers, some CPU or FPU registers may have to
be saved, the stack pointer and the program counter have to be updated, and finally the instruction cache
has to be filled with new instructions.</p>
</div>
<div class="paragraph">
<p>So for tiny <span class="proc">procs</span> actually calling the <span class="proc">proc</span> may take more time than processing the actual code inside the
proc. To avoid this additional effort, procedures and functionss can be inlined. The compiler may do this automatically for us, but we
can support it by applying the {.inline.} prama to tiny <span class="proc">procs</span>.<sup class="footnote">[<a id="_footnoteref_33" class="footnote" href="#_footnotedef_33" title="View footnote.">33</a>]</sup>
For inlined <span class="proc">procs</span> the code
is just inserted directly at the call site. This may increase the total executable size, when the <span class="proc">proc</span> is used often.
So we should use the inline pragma with some care. Another option is to just compile the whole program
with link time optimization passing the option -d:lto to the compiler, that way the C backend
can automatically inline all <span class="proc">proc</span> code, even <span class="proc">procs</span> from imported modules. One more option is to use
templates instead of tiny <span class="proc">procs</span>&#8201;&#8212;&#8201;templates always do a plain code substitution, so templates may behave
very similar to inline <span class="proc">procs</span>. We will discuss templates later. The following example show how we can apply
the inline pragma to procedures and functionss:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc max(a, b: int): int {.inline.} =
  if a &lt; b: b else: a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that functions from shared libraries can not be in lined, so calling external C functions, directly or indirectly,
may be slower than expected.</p>
</div>
</div>
<div class="sect2">
<h3 id="_recursion">Recursion</h3>
<div class="paragraph">
<p>Procedures and functions can call them self in a repetitive manner, which is called recursion.
Obviously there must exist some condition that finally stops the recursion, without the
proc would call itself again and again, for each call some data would have to be stored on the stack, at least the
proc return address, so finally the stack would overflow, and the program would crash.
Generally, recursion should be used only for cases where it really helps to simplify the algorithm.
In part V of the book, in the section about various sorting algorithm, we will discover some useful
applications for recursion. In most cases, a plain iterative algorithm is faster than a recursive one,
because all the overhead with many <span class="proc">proc</span> calls is avoided for plain iterative solutions. But sometimes
recursive algorithm are easier to understand, or programming an iterative solution may be really complicated.</p>
</div>
<div class="paragraph">
<p>As one of the most simple algorithm, we will present here the recursive fac() function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc fac(i: int): int =
  if i &lt; 2:
    1
  else:
    i * fac(i - 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That function should terminate, as we only call itself again with a decreased argument.
Of course, using recursion here is not really smart, it should be easy for you to convert
the <span class="proc">proc</span> into an iterative solution without recursion. Note that recursive <span class="proc">procs</span> can never be inlined!</p>
</div>
</div>
<div class="sect2">
<h3 id="_converters">Converters</h3>
<div class="paragraph">
<p>Nim&#8217;s converters are a special variant of functions that are called automatically by
the compiler when argument types do not match.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">converter myIntToBool(i: int): bool =
  if i == 0:
    false
  else:
    true

proc processBool(b: bool) =
  if b:
    echo "true"
  else:
    echo "false"

var i = 7
processBool(i)
if i:
  echo "true"
else:
  echo "false"</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the above converter we can pass an integer to a <span class="proc">proc</span> that expects a boolean parameter,
and we can even use an integer as a logical expression in an <span class="key">if</span> condition in the same
way as it is done in C language. Converters do work only in a direct way, that is
automatic chaining is not supported: If we have one converter from character to integer
and one from <span class="type">int</span> to boolean, that does not mean that we can pass a character to a
proc that expects a boolean. We would have to declare one more converter that
directly converts character to boolean.</p>
</div>
<div class="paragraph">
<p>Whenever we do consider using converters we should think twice&#8201;&#8212;&#8201;converters may be
confusing, may have some strange effects and may increase compile time.</p>
</div>
<div class="paragraph">
<p>Maybe you wondered why we wrote above converter in such a verbose way? Well it was
done intentionally, but you are right of course, we can write it just as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">converter myIntToBool(i: int): bool =
  i != 0</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_object_orientated_programming_and_inheritance">Object-Orientated Programming and Inheritance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Object-Orientated Programming and Inheritance became very popular in the early
nineties of the last century. Java is a prominent representative of that programming
paradigm, but most languages created in the nineties of the last century support it,
like C++, Ruby and Python.</p>
</div>
<div class="paragraph">
<p>The idea of OOP is that objects and procedures working on that objects are grouped to
classes, and that classes can be extended with additional data fields and with
additional procedures. In OOP, procedures and function are often called methods and
data fields are called members. Sometimes the members are completely hidden and are
accessed only by so-called getter and setter methods. That is called encapsulation.
Encapsulation allows hiding implementation details, so that that details may change
when necessary, without that the change of internal details become visible to users
of that class, so that the users can use the class without noticing the change.
Getters and setters also help hiding internal details, and they ensure that the class
is always in a consistent and valid state.</p>
</div>
<div class="paragraph">
<p>An important property of OOP is dynamic dispatch: When we create various subclasses
of a common parent class, and we have defined methods for all the subclasses, then
we can have collections of instances of different subclasses, and the compiler can
automatically ensure that always the matching method for each instance is called.</p>
</div>
<div class="paragraph">
<p>A classical example is a drawing program, where we have different geometrical shapes
like rectangle, circle and many more. All the geometrical objects are stored is some
form of list, and when we want to draw all of them on the screen then we have to call
only an unspecific draw() method, and the compiler ensures that for each shape the
matching draw method is called. In Nim, that may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Shape = ref object of RootRef

  Rectangle = ref object of Shape
    x, y, width, height: float

  Circle = ref object of Shape
    x, y, radius: float

  LineSegment = ref object of Shape
    x1, y1, x2, y2: float

method draw(s: Shape) {.base.} =
  # override this base method
  quit "to override!"

method draw(r: Rectangle) =
  echo "drawing a rectangle"

method draw(r: Circle) =
  echo "drawing a circle"

method draw(r: LineSegment) =
  echo "drawing a line segment"

proc main =
  var l: seq[Shape]
  l.add(Rectangle(x: 0, y: 0, width: 100, height: 50))
  l.add(Circle(x: 60, y: 20, radius: 50))
  l.add(LineSegment(x1: 20, y1: 20, x2: 50, y2: 50))

  for el in l:
    draw(el)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of that program is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>drawing a rectangle
drawing a circle
drawing a line segment</pre>
</div>
</div>
<div class="paragraph">
<p>So we can have a sequence of the base type, add various subtypes and then iterate
over the list to draw all the various subtypes. Of course, in the same way we could
do many more task like moving, rotating or storing all the objects in one call. The
compiler does the right dynamic dispatching for us, we have just to provide all
necessary methods. The need of the base method seems to be a bit strange, some other
OOP languages do not need that. The base method is marked by a {.base.} pragma, we
will discuss the purpose of pragmas later. In the example we have used only one level
of sub-classing, but of course we can use many levels, for example we can again
subclass the Circle by a FilledCircle with a color field.</p>
</div>
<div class="paragraph">
<p>The OOP coding style can be very convenient for some tasks, one important use case
could be graphical user interfaces where the graphical elements like labels, buttons,
frames built in natural way a hierarchical structure. Another typical use case are
drawing applications with code similar to our basic example.</p>
</div>
<div class="paragraph">
<p>Note that the OOP style only works with ref objects, but not with value objects. The
obvious reason is that we can have collections of different subtypes stored in
arrays or sequences only for ref objects, as in arrays and sequences all element types
have to have equal size. For references, that is the case, as references are basically
pointers. But different value types would have different size. Linked lists would be
no better solution, as again we can not build lists with value objects.</p>
</div>
<div class="paragraph">
<p>For maximum performance OOP code with ref objects is generally not optimal, as the
dispatching itself needs some time, and as the ref objects are not contained in a
single block of memory, but are distributed in the whole RAM, which is not cache
friendly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_builtin_data_types">Other Builtin Data Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_tuple_types">Tuple Types</h3>
<div class="paragraph">
<p>Tuples are heterogeneous container types similar to
the struct type in C. As Nim&#8217;s <span class="key">object</span> type creates no overhead
as long as we use no inheritance and so also directly corresponds to the C
struct type, tuples are very similar to Nim&#8217;s objects.
The biggest advantage of tuples is, that we can create anonymous
tuples, and that Nim supports the automatic unpacking of <span class="type">tuple</span> variables
into ordinary unstructured variables.</p>
</div>
<div class="paragraph">
<p>Compared to objects, tuples do support no inheritance at all, all the <span class="type">tuple</span> fields
are always visible, and different <span class="type">tuple</span> types are regarded as identical, when
all the field names and field data types match. Remember that two different object
types are always distinct in Nim, even when the actual type definition looks identical.</p>
</div>
<div class="paragraph">
<p>We can define tuple types in the same way as we define objects, or we can
use the <span class="code">tuple[]</span> constructor. Additional, we can define anonymous tuples just
by enclosing its field types in round brackets. The fields of <span class="type">tuple</span> types
can be accessed by field names as we do it for objects, or we can access
the fields with constant indices starting at zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Move = tuple # the object definition syntax
    from: int
    to: int
    check: bool

type Move = tuple[from: int, to: int, check: bool] # equivalent tuple constructor syntax

proc findBestNextMove(): (dest: int; check: bool) =
  ...

let (dst, check) = findBestNextMove()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code example above we show two equivalent ways to define a tuple type,
but actually we
do not use that type at all but return an anonymous <span class="type">tuple</span> from our <span class="proc">proc</span>, that is a
pair of an <span class="type">int</span> and a <span class="type">bool</span>.</p>
</div>
<div class="paragraph">
<p>Using automatic <span class="type">tuple</span> unpacking
and type inference, our <span class="var">dst</span> and <span class="var">check</span> variables gets the data types <span class="type">int</span> and <span class="type">bool</span>.</p>
</div>
<div class="paragraph">
<p>Tuples are also useful when a function has to return a value and also an error state,
or if it may not be able to return something at all in a special case. For reference types
we could return <span class="lit">nil</span> then, but for results of value type like <span class="type">int</span> or <span class="type">float</span> we may not have a well-defined
error indicating constant, so we can return a <span class="type">tuple</span> with an additional <span class="type">bool</span> indicating success or error.
But of course we could use exceptions instead, or we could use Nim&#8217;s option type instead. We
will learn more about that later.</p>
</div>
<div class="paragraph">
<p>Here are two examples which uses a <span class="type">tuple</span> as a <span class="proc">proc</span> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc p1(x: tuple[i: int, j: int]): int =
  x.i + x.j

echo p1((7, 7))

proc p2(x: (int, int)): int =
  x[0] + x[1]

echo p2((7, 7))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proc <span class="func">p1()</span> creates a tuple type using the <span class="type">tuple</span> constructor syntax with named fields, so
in the <span class="proc">proc</span> body we can access the fields by its names, while <span class="proc">proc</span> <span class="func">p2()</span> uses an
anonymous tuple, and so has to access the fields by constant indices. Both <span class="proc">procs</span> are called with
an anonymous <span class="type">tuple</span> parameter.</p>
</div>
</div>
<div class="sect2">
<h3 id="_object_variants">Object Variants</h3>
<div class="paragraph">
<p>Nim&#8217;s object variants, sometimes also called sum types or abstract data types (ADT),
are an advanced and type save variant of the union type known from C. The basic idea
is that we may use value types that may store similar, but not identical data.
Untyped languages like Ruby or Python allow that of course, and we can do it in Nim
with ref types and inheritance too, as we showed in a previous section with our <span class="type">Shape</span>
base type and various geometric shapes. We could store that ref types in arrays or
sequences or linked list and use dynamic dispatch for processing the various
subtypes. That is convenient but gives not maximum performance due to dynamic
dispatch at runtime and due to bad cache use. So we may like to have a value type
with different content, so that we can store all the value types in a <span class="type">seq</span> and all
entities reside in a compact block of memory for good cache use.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  ShapeKind = enum
    line, rect, circ

  Shape = object
    visible: bool
    case kind: ShapeKind
    of line:
      x1, y1, x2, y2: float
    of rect:
      x, y, width, height: float
    of circ:
      x0, y0, radius: float

proc draw(el: Shape) =
  if el.kind == line:
    echo "process line segment"
  elif el.kind == rect:
    echo "process rectangle"
  elif el.kind == circ:
    echo "process circle"
  else:
    echo "unknown shape"

var
  s: seq[Shape]
s.add(Shape(kind: circ, x0: 0, y0:0, radius: 100, visible: true))
for el in s:
  draw(el)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Objects variants can have common fields like the boolean state visible above, but the
other fields are not allowed to use the same names, so we had to use <span class="var">x0</span> and <span class="var">y0</span> for
the names of the center coordinates in the circle variant.</p>
</div>
<div class="paragraph">
<p>As you can see, we can store all the different object variants as value objects in a
sequence and iterate over it. Note that object variants may waste some storage, as
all variants are silently enlarged to have the exact same size, so that all variant
types can be stored in an array or sequences and can be passed as <span class="proc">proc</span> parameters in
the same way to the same <span class="proc">proc</span>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_iterators">Iterators</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In section <a href="#_for_loops_and_iterators">For Loops and Iterators</a> we used a <span class="key">for</span> loop to iterate over the
individual characters of a <span class="type">string</span>. <span class="key">For</span> loops are useful for various
iteration purposes, e.g. to iterate over container types like <span class="type">strings</span>,
<span class="type">arrays</span>, and sequences, or over a numeric <span class="type">range</span>, and other countable
entities. We could do the same with a <span class="key">while</span> loop, but using a <span class="key">for</span>
loop is often more convenient and less error prone&#8201;&#8212;&#8201;we do not have to care for
increasing a loop variable and for the stop condition.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s <span class="key">for</span> loops are built on <span class="key">iterators</span>, that is, whenever a
<span class="key">for</span> loop is executed an <span class="key">iterator</span> is used under the hood.  Some
<span class="key">iterators</span> are used explicitly in <span class="key">for</span> loops, e.g. <span class="func">countup()</span>
of Nim&#8217;s standard library, others like <span class="func">items()</span> or <span class="func">pairs()</span> are
executed implicitly when no explicit <span class="key">iterator</span> name is specified.</p>
</div>
<div class="paragraph">
<p>The creation and use of <span class="key">iterators</span> is very easy in Nim. Before we will discuss
all the details and some restrictions of <span class="key">iterators</span>, and the important
differences between inline and closure <span class="key">iterators</span>, we will give a small
example:</p>
</div>
<div class="paragraph">
<p>We have already used some of Nim&#8217;s standard <span class="key">iterators</span> to iterate over the
characters of a <span class="key">string</span> or the content of a sequence.</p>
</div>
<div class="paragraph">
<p>In an earlier section of the book we declared a procedure that extracts all the
decimal digits from a <span class="type">string</span>. We can do the same with an <span class="key">iterator</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">iterator decDigits(s: string): char =
  var pos = 0
  while pos &lt; s.len:
    if s[pos] in {'0' .. '9'}:
      yield(s[pos])
    inc(pos)

for d in decDigits("df4j6dr78sd31tz"):
  stdout.write(d)
stdout.write('\n')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of an <span class="key">iterator</span> is very similar to the definition of a
<span class="proc">proc</span> or function, but while a function returns a result only once to the
caller, an iterator uses the <span class="key">yield</span> statement to give data back to the call
site multiple times, instead of returning just once.</p>
</div>
<div class="paragraph">
<p>Whenever a <span class="key">yield</span> statement is reached in the body of the <span class="key">iterator</span>,
the yielded data is bound to the <span class="key">for</span> loop variable(s), the body of the for
loop is executed, and at the end of the <span class="key">for</span> loop body control returns to the
iterator, that is execution continues direct after the <span class="key">yield</span> statement.  The
<span class="key">iterator&#8217;s</span> local variables and execution state are automatically saved
between calls.  The iteration process continues until the end of the body of the
iterator declaration is reached and the iterator terminates.</p>
</div>
<div class="paragraph">
<p><span class="key">Iterators</span> are used in <span class="key">for</span> loops to iterate over containers,
<span class="type">ranges</span> or other data.  After the <span class="key">for</span> keyword, we specify one or more
arbitrary variable names, which we then can use in the body of the <span class="key">for</span> loop
to access the yielded value(s).  The data type of this iteration variable(s) is
inferred from the iterators return type, and its scope is limited to the body of the
<span class="key">for</span> loop.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s standard library defines for container types like <span class="type">strings</span>,
<span class="type">array</span> and sequences <span class="key">iterators</span> named <span class="func">items()</span> and
<span class="func">pairs()</span>&#8201;&#8212;&#8201;<span class="func">items()</span> is the default name when a <span class="key">for</span> loop with
only one variable is used, and <span class="func">pairs()</span> is the default name when two
variables are used, e.g. the index position and the character when iterating over a
<span class="type">string</span>.</p>
</div>
<div class="paragraph">
<p>In Nim&#8217;s standard library, you may find <span class="func">items()</span> and <span class="func">pairs()</span>
<span class="key">iterators</span> like these two:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">iterator items(a: string): char =
  var i = 0
  while i &lt; len(a):
    yield a[i]
    inc(i)

iterator pairs(a: string): tuple[key: int, val: char] =
  var i = 0
  while i &lt; len(a):
    yield (i, a[i])
    inc(i)

var s = "Nim is nice."
for c in items(s):
  stdout.write(c, '*')
echo ""
for i, c in pairs(s):
  echo i, ": ", c</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above we specified the <span class="key">iterator</span> names <span class="func">items()</span> and
<span class="func">pairs()</span> explicitly in the <span class="key">for</span> statement, but as these names are the
defaults, we can just write <span class="code">for c in s:</span> and <span class="code">for i, c in s:</span>.</p>
</div>
<div class="paragraph">
<p>The two <span class="key">iterators</span> in the example code from above use as argument a value type
and return the single characters as value type. This way, we can not modify the
<span class="type">string</span> content. When we intend to modify the content of a container by use
of an <span class="key">iterator</span>, we have to pass the container as <span class="key">var</span> parameter, and
return the elements as <span class="key">var</span> also. By convention for iterating over mutable
containers the iterator names <span class="func">mitems()</span> and <span class="func">mpairs()</span> are used, where
the leading <span class="var">m</span> stands for mutable.  We have to specify these names explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">iterator mitems(a: var string): var char =
  var i = 0
  while i &lt; len(a):
    yield a[i]
    inc(i)

iterator mpairs(a: var string): tuple[key: int, val: var char] =
  var i = 0
  while i &lt; len(a):
    yield (i, a[i])
    inc(i)

from strutils import toLowerAscii
var s = "NIM"
for i, c in mpairs(s):
  if i &gt; 0:
    c = toLowerAscii(c)
echo s # Nim</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whenever we iterate over a container, we should not delete, insert or append elements
to the container, as that may confuse the loop inside the <span class="key">iterator</span> body.
<span class="key">Iterators</span> of Nim&#8217;s standard library check the length of the container and
generate an exception when the length changes during the iteration.</p>
</div>
<div class="paragraph">
<p>Nim differentiate between inline and closure <span class="key">iterators</span>. When a <span class="key">for</span>
loop uses an inline <span class="key">iterator</span>, then the actual <span class="key">iterator</span> loop is
inlined in the <span class="key">for</span> loop body in a way that for each <span class="key">yield</span> statement
in the <span class="key">iterator</span> body, the body of the <span class="key">for</span> loop is executed.  Actually
the <span class="code">for c in items(s): stdout.write(c, '*')</span> in our example from above is
rewritten by the compiler into a code block like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i = 0
while i &lt; len(a):
  var c = a[i]
  echo c, '*'
  inc(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, the body of the <span class="key">for</span> loop is inlined into the loop of the
<span class="key">iterator</span>.</p>
</div>
<div class="paragraph">
<p>This results in very fast code with no overhead, but similar to the use of
<span class="key">templates</span>, this increases the total code size.  Actually, when the
<span class="key">iterator</span> should use multiple <span class="key">yield</span> statements, then the code of the
body of the <span class="key">for</span> loop is inserted for each <span class="key">yield</span> statement.</p>
</div>
<div class="paragraph">
<p>Inline <span class="key">iterators</span> are currently the default <span class="key">iterator</span> type, so the
<span class="key">iterators</span> of the examples above are all inline <span class="key">iterators</span>.</p>
</div>
<div class="paragraph">
<p>Closure <span class="key">iterators</span> behave more like procedures, the <span class="key">iterator</span> is
actually invoked, which costs some performance. We can use all the <span class="key">iterators</span>
of the examples from above as closure <span class="key">iterators</span> by applying the closure
pragma as in <span class="code">iterator items(a: string): char {.closure.} =</span>.</p>
</div>
<div class="paragraph">
<p>Closure <span class="key">iterators</span> behaves like <span class="key">objects</span>, we can assign instances of
inline <span class="key">iterators</span> to variables, and then call the instances explicitly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">iterator myCounter(a, b: int): int {.closure.} =
  var i = a
  while i &lt; b:
    yield i
    inc(i)

for x in myCounter(3, 5): # ordinary use of the operator
  echo x

echo "---"
var counter = myCounter # use of an iterator instance
while true:
  echo counter(5, 7)
  if counter.finished:
    break</code></pre>
</div>
</div>
<div class="paragraph">
<p>which gives us this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>3
4
---
5
6
0</pre>
</div>
</div>
<div class="paragraph">
<p>Here, we have used the <span class="func">finished()</span> function to check if the <span class="key">iterator</span>
is done.</p>
</div>
<div class="paragraph">
<p>Actually <span class="func">finished()</span> returns <span class="lit">true</span> only, when the <span class="key">iterator</span> has
already failed to <span class="key">yield</span> a valid value, and not already when the last valid
value was yielded. That is, why we get in the example above as last value the invalid
value zero.</p>
</div>
<div class="paragraph">
<p>We can avoid this behavior, when we rewrite the loop as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var counter2 = myCounter
while true:
  let v = counter2(5, 7)
  if counter2.finished:
    break # v is invalid
  echo v</code></pre>
</div>
</div>
<div class="paragraph">
<p>Closure <span class="key">iterators</span> are resumable functions, and so one has to provide the
arguments to every call. To get around this limitation, one can capture parameters of
an outer factory
proc:<sup class="footnote">[<a id="_footnoteref_34" class="footnote" href="#_footnotedef_34" title="View footnote.">34</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc mycount(a, b: int): iterator (): int =
  result = iterator (): int =
    var i = a
    while i &lt; b:
      yield i
      inc(i)

var c1 = mycount(5, 7)
for i in c1():
  echo i

echo "---"

var c2 = mycount(2, 5)
while true:
  let v = c2()
  if c2.finished:
    break # v is invalid
  echo v</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example from the compiler manual, the <span class="proc">proc</span> <span class="func">mycount()</span>
captures the bound for the counter.  When we compile and run the code above, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>5
6
---
2
3
4</pre>
</div>
</div>
<div class="paragraph">
<p>At the end of this section we will list some properties of <span class="key">iterators</span>:
<span class="key">Iterators</span> have their own name space, so we can freely use for <span class="proc">procs</span>
and <span class="key">iterators</span> the same names. <span class="key">Iterators</span> have no predefined
<span class="key">result</span> variable, and do not support recursion.  Inline <span class="key">iterators</span> can
be used only inside <span class="key">for</span> loops, and can not be forward declared, because
the compiler must be able to inline an <span class="key">iterator</span>.  (This restriction will be
gone in a future version of the compiler.) And <span class="key">iterators</span> do not support
recursion.  Closure iterator are not supported by the JS backend, and cannot be
executed at compile time.  Inline iterators are second class citizens; They can be
passed as parameters only to other inlining code facilities like templates, macros,
and other inline iterators. In contrast to that, a closure iterator can be passed
around more freely.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_templates">Templates</h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Nim <span class="key">templates</span> are very different from C++ templates!
In C++ templates are used for
generic programming&#8201;&#8212;&#8201;a style of computer programming in which algorithms are
written in terms of types to-be-specified-later that are then instantiated when needed
for specific types provided as parameters.<sup class="footnote">[<a id="_footnoteref_35" class="footnote" href="#_footnotedef_35" title="View footnote.">35</a>]</sup>
This is just called generics in Nim and other programming languages, we learned about Nim&#8217;s generics
earlier in this book.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Nim <span class="key">templates</span> are a simple, parameterized code substitution mechanism,
and are used similarly
as procedures.
The syntax to <span class="italic">invoke</span> a <span class="key">template</span> is the same as calling a procedure.
But while procedures built a single block of code that is then
called multiple times, <span class="key">templates</span> work more like C macros as a (textual) code substitution. Wherever
we invoke a <span class="key">template</span>, the <span class="key">template</span> source code is inserted at the call site.
In this way, Nim <span class="key">templates</span>
have indeed some similarity to C macros. But while C macros are executed by the C pre-processor and
can do only plain source text substitutions, Nim <span class="key">templates</span>
operates on Nim&#8217;s abstract syntax trees,
are processed
in the semantic pass of the compiler,
integrate well with the rest of the language, and share none of C&#8217;s preprocessor macros flaws.</p>
</div>
<div class="paragraph">
<p>In some way Nim <span class="key">templates</span> are a simplified application  of Nim&#8217;s powerful <span class="key">macro</span> and meta-programming
system, which we will discuss in detail in part VI of the book.</p>
</div>
<div class="paragraph">
<p>In C we could use the "#define" preprocessur directive to define two simple C macros.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PI 3.1416
#define SQR(x) (x)*(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The C pre-processor would then replace the symbol <span class="const">PI</span> in the C source code with the <span class="type">float</span> literal <span class="lit">3.1416</span>.
And as the C pre-processor can recognize some simple form of parameters, it would
replace <span class="func">SQR(a + b)</span> with <span class="code">(a+b)*(a+b)</span>.</p>
</div>
<div class="paragraph">
<p>In Nim we would define a <span class="key">const</span> for <span class="const">PI</span> and use a generic <span class="proc">proc</span> or a <span class="key">template</span> for <span class="func">SQR()</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const PI = 3.1416
proc sqr1[T](x: T): T = x * x
template sqr2(x: typed): typed = x * x</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the <span class="func">sqr2()</span> <span class="key">template</span> uses the special <span class="key">typed</span> parameter, which specifies
that the parameter has a well-defined type in the <span class="key">template</span> body, but that
arbitrary data types are accepted. So <span class="func">sqr1()</span> and <span class="func">sqr2()</span> would work for all
numeric types and also for other data types for which we have
defined a <span class="op"><strong></span> operation. When there is no <span class="op"></strong></span> operator defined for the passed  data
type, the compiler will give an error message.</p>
</div>
<div class="paragraph">
<p>Nim <span class="key">templates</span> accept like <span class="proc">procs</span> all of Nim&#8217;s ordinary data types, and additional
the abstract meta-types <span class="key">typed</span> and <span class="key">untyped</span>.
The abstract data types <span class="key">typed</span> and <span class="key">untyped</span> can be used only for the types of
<span class="key">template</span> and <span class="key">macro</span> parameters, but not for parameters of procedures, functions,
iterators, or to define variables.</p>
</div>
<div class="paragraph">
<p>We will explain the differences between <span class="key">typed</span>
and <span class="key">untyped</span> in detail later in this section&#8201;&#8212;&#8201;the short version of the explanation is, that
<span class="key">typed</span> <span class="key">template</span> parameters must have a well-defined data type when we pass it to the <span class="key">template</span>,
while <span class="key">untyped</span> parameters can be passed as still undefined symbolic name also.</p>
</div>
<div class="paragraph">
<p>So we can in principle replace each procedure or function definition with a <span class="key">template</span>.
The important difference between procedures and <span class="key">templates</span> is, that ordinary
<span class="proc">procs</span> are instantiated only once, generic <span class="proc">procs</span> may be instantiated for each data type with which
they are used, but <span class="key">templates</span> are instantiated for each invocation of the <span class="key">template</span>.
The compiler creates for each defined <span class="proc">proc</span> some machine code, which is executed whenever
the <span class="proc">proc</span> is called. But for <span class="key">templates</span>, the compiler does some code substitution&#8201;&#8212;&#8201;the source
code of the <span class="key">template</span> is inserted where the <span class="key">template</span> is invoked. This avoids the need for an
actual jump to a different machine code block when a procedure is called, but increases the
total code size for each use of a <span class="key">template</span>. So we would typically avoid <span class="key">templates</span>
that contain a lot of code and are used often.</p>
</div>
<div class="paragraph">
<p>For each ordinary <span class="proc">proc</span> one block of machine code instructions is generated, and
when the <span class="proc">proc</span> is called, program executions has to jump to this block, and back
when the <span class="proc">proc</span> execution is done. This jumping involves some minimal overhead, which
is noticeable for tiny <span class="proc">procs</span> called frequently. To avoid this overhead, we may use a <span class="key">template</span> instead,
or we may use inlined <span class="proc">procs</span>, which we discussed in the previous section. <span class="proc">Proc</span>
inlining can be done by the compiler automatically when the <span class="proc">proc</span> is defined in
the source code file where it is used, or when we mark the <span class="proc">proc</span> with the <span class="lit">inline</span> pragma.
Additional, when we compile our program with <span class="term">-d:lto</span>, the compiler can inline all procedures and functions.
Generally the compiler should know well when inlining makes sense, so in most
cases it makes not much sense to just use <span class="key">templates</span> instead of (small) procs
just to avoid the <span class="proc">proc</span> call overhead.</p>
</div>
<div class="paragraph">
<p><span class="key">Templates</span> can be used as some form of alias. Sometimes we have nested data structures,
and would like to have a shorter alias for the access of fields:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Point = object
    x, y: int

  Circle = object
    center: Point

template x(c: Circle): int = c.center.x

template `x=`(c: var Circle; v: int) = c.center.x = v

var a, b: Circle

a.center.x = 7
echo a.center.x

b.x = 7
echo b.x</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two <span class="key">templates</span> simplify the access of field <span class="var">x</span>, and as <span class="key">templates</span> are pure
code substitution, the use of them costs no performance. Since version 1.6
Nim has also the <span class="italic">with</span> <span class="key">macro</span>, which can be also used to save some typing.
Note that in the second <span class="key">template</span>, we have called the second <span class="type">int</span> parameter <span class="var">v</span>&#8201;&#8212;&#8201;calling them <span class="var">x</span> would give some trouble:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Error: in expression 'b.center.7': identifier expected, but found '7'</pre>
</div>
</div>
<div class="paragraph">
<p>Nim&#8217;s <span class="mod">system</span> module uses <span class="key">templates</span> to define some operators like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template `!=` (a, b: untyped): untyped =
  not (a == b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This way <span class="op">!=</span> is always the opposite of <span class="op">==</span>, so when we define the <span class="op">==</span> operator
for our own custom data types, <span class="op">!=</span> is available for free.</p>
</div>
<div class="paragraph">
<p>In some situations, using <span class="key">templates</span> instead of <span class="proc">procs</span> can avoid some overhead.
Let us investigate a <span class="func">log()</span> <span class="key">template</span>, that can print messages to <span class="var">stdout</span>
when a global boolean constant is set to <span class="lit">true</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const
  debug = true

template log(msg: string) =
  if debug: stdout.writeLine(msg)

var
  x = 4
log("x has the value: " &amp; $x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here <span class="func">log()</span> is called with the constructed argument <span class="code">("x has the value: " &amp; $x)</span>
which implies a <span class="type">string</span> concatenation operation at runtime. As we use a <span class="key">template</span>, the
invocation of <span class="func">log("x has the value: " &amp; $x)</span> is actually replaced by the compiler with code like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">  if debug: stdout.writeLine("x has the value: " &amp; $x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>So when <span class="const">debug</span> is set to <span class="lit">false</span>, absolutely no code is generated. For an ordinary, not inlined
<span class="proc">proc</span> the situation is different, the expensive <span class="type">string</span> concatenation operation would always have to be
performed, but the <span class="func">log()</span> <span class="proc">proc</span> would immediately return for <span class="code">debug == false</span>. What exactly would happen
when <span class="func">log()</span> is an inlined <span class="proc">proc</span> may depend on the actual used compiler backend.</p>
</div>
<div class="paragraph">
<p>Note that the delayed (lazy) parameter evaluation for <span class="key">template</span> parameters can have disadvantages:
When we modify the <span class="func">log()</span> <span class="key">template</span> like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template log(msg: string) =
  for i in 0 .. 2:
    stdout.writeLine(msg)

var x = 4
log("x has the value: " &amp; $x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>the expensive <span class="type">string</span> concatenation operation would be done in principle three times
in the <span class="key">template</span> body.<sup class="footnote">[<a id="_footnoteref_36" class="footnote" href="#_footnotedef_36" title="View footnote.">36</a>]</sup>
While for a <span class="proc">proc</span> the already evaluated parameter would be passed.
So when we access a parameter multiple times inside a <span class="key">template</span>, it can make sense to
assign the parameter to a local variable and then use that variable only.</p>
</div>
<div class="paragraph">
<p><span class="key">Templates</span> can inject entities defined in the <span class="key">template</span> body into the surrounding scope.
By default, variables defined in the <span class="key">template</span> body are not injected in the surrounding scope, but
<span class="proc">procs</span> are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template gen =
  var a: int
  proc maxx(a, b: int): int =
    if a &gt; b: a else: b

gen()
echo maxx(2, 3)
# echo a</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call <span class="code">echo maxx(2, 3)</span> compiles and works, while <span class="func">echo a</span> complains about an undefined symbol.</p>
</div>
<div class="paragraph">
<p>A very special property of <span class="key">templates</span> and <span class="key">macros</span> is, that we can pass to them code blocks
when we use <span class="key">untyped</span> for the type of the last parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template withFile(f: untyped; filename: string; actions: untyped) =
  var f: File
  if open(f, filename, fmWrite):
      actions
      close(f)

withFile(myTextFile, "thisIsReallyNotAnExistingFileWithImportantContent.txt"):
  myTextFile.writeLine("line 1")
  myTextFile.writeLine("line 2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="key">template</span> <span class="func">withFile()</span> from the above example has three parameters&#8201;&#8212;&#8201;a parameter <span class="var">f</span> of <span class="key">untyped</span> type, a <span class="var">filename</span> of <span class="type">string</span> type, and as
last parameter one more <span class="key">untyped</span> parameter which we call actions.
For these last <span class="key">untyped</span> actions parameter, we can pass an indented code block.</p>
</div>
<div class="paragraph">
<p>When we invoke the <span class="func">withFile()</span> <span class="key">template</span>, we pass the first two parameters in the
well-know way by putting them in a parameter list enclosed in round brackets. But
instead of passing this way also the final actions parameter, we put a colon after
the parameter list, and pass this way the following indented code block as last <span class="key">untyped</span> parameter.
In the body of the above <span class="key">template</span> we have an <span class="func">open()</span> call which opens a file with the specified
filename and the <span class="lit">fmWrite</span> mode, then executes the passed code block, and finally closes
the file. The first parameter of our <span class="func">withFile()</span> <span class="key">template</span> has also a special property:
As we use <span class="key">untyped</span> for the <span class="var">f</span> parameter, we can pass the still undefined symbol
<span class="var">myTextFile</span> to the <span class="key">template</span>. In the <span class="key">template</span> body, this symbol is used as a variable
name, and our two <span class="func">writeLine()</span> <span class="proc">proc</span> calls can use it to refer to the file variable.</p>
</div>
<div class="paragraph">
<p>As Nim <span class="key">templates</span> are hygienic, the instance of the file variable created in the body
of our <span class="key">template</span> can be used by the passed code block, but it actually
exists only in the <span class="key">template</span>, and pollutes not the global name space of our program.</p>
</div>
<div class="paragraph">
<p>We can use <span class="key">templates</span> to create new <span class="proc">procs</span>. An example is lifting <span class="proc">procs</span> like <span class="func">math.sqrt()</span>
that accepts a scalar parameter and returns a scalar value, to work with <span class="type">arrays</span>
and sequences. The following example is taken from the official <span class="italic">tut2</span> tutorial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from std/math import sqrt

template liftScalarProc(fname) =
  proc fname[T](x: openarray[T]): auto =
    var temp: T
    type outType = typeof(fname(temp))
    result = newSeq[outType](x.len)
    for i in 0 .. x.high:
      result[i] = fname(x[i])

liftScalarProc(sqrt)   # make sqrt() work for sequences
echo sqrt(@[4.0, 16.0, 25.0, 36.0])   # =&gt; @[2.0, 4.0, 5.0, 6.0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="key">template</span> called <span class="func">liftScalarProc()</span> creates a generic
<span class="proc">proc</span>, that accept as parameter an <span class="type">openArray[T]</span>
and returns a <span class="type">seq[T]</span>. Well, we should be able to understand the
basic ideas used in that code, but it is still fascinating that it really works.</p>
</div>
<div class="sect2">
<h3 id="_typed_vs_untyped_parameters">Typed vs untyped parameters</h3>
<div class="paragraph">
<p>Parameters passed to <span class="key">templates</span> can have all the data types
that we can use for <span class="procs">procs</span> including special types like <span class="type">openarray</span> and <span class="type">varargs</span>, and we
can use as types additional the symbols <span class="key">untyped</span>, <span class="key">typed</span> or <span class="key">typedesc</span>.</p>
</div>
<div class="paragraph">
<p>The <span class="key">typedesc</span> type can be used to pass type information to the <span class="key">template</span>, e.g.
when we want to create a variable of a special data type. The "meta-types"
<span class="key">typed</span> and <span class="key">untyped</span> are used, when we want to create some form of generic
<span class="key">template</span>, that can accept different data types. Actually the distinction
between <span class="key">typed</span> and <span class="key">untyped</span> parameters is not that difficult and important
for <span class="key">templates</span> as it is for <span class="key">macros</span>, in most cases it is just clear if we need the <span class="key">typed</span> or
<span class="key">untyped</span> parameter type for a <span class="key">template</span>, or both work fine. We discuss
the differences between <span class="key">typed</span> and <span class="key">untyped</span> in much more detail in part VI of
the book, when we discuss <span class="key">macros</span> and meta-programming.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates the use of the <span class="key">untyped</span> and the <span class="key">typedesc</span> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template declareInt(n: untyped) =
  var n: int

declareInt(i)
i = 3
echo i

template declareVar(n: untyped; t: typedesc) =
  var n: t

declareVar(x, float)
x = 3.0
echo x</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the parameter <span class="var">n</span> is <span class="key">untyped</span>, the compiler allows us to pass
an undefined symbol to the <span class="key">template</span>. If we changed the parameter
type to <span class="key">typed</span> the compiler would complain with a message like
<span class="italic">Error: undeclared identifier: 'i'</span></p>
</div>
<div class="paragraph">
<p>For the second <span class="key">template</span> called <span class="func">declareVar()</span> we use an additional parameter
of <span class="key">typedesc</span> type, so that the <span class="key">template</span> can create for us a variable of just the passed
data type.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Citing the manual: "An  <span class="key">untyped</span> parameter means that symbol lookups and type resolution is not
performed before the expression is passed to the <span class="key">template</span>. This means that
undeclared identifiers, for example, can be passed to the <span class="key">template</span>.
A <span class="key">template</span> where every parameter is  <span class="key">untyped</span> is called an immediate <span class="key">template</span>. For historical reasons,
<span class="key">templates</span> can be explicitly annotated with an immediate pragma and then these <span class="key">templates</span> do not take
part in overloading resolution and the parameters' types are ignored by the compiler.
Explicit immediate <span class="key">templates</span> are now deprecated.
For historical reasons, stmt was an alias for <span class="key">typed</span> and expr was an alias for  <span class="key">untyped</span>, but they are removed."</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_passing_a_code_block_to_a_template">Passing a code block to a template</h3>
<div class="paragraph">
<p>In the <span class="func">withFile()</span> example above, we showed that we
can pass a block of statements as the last argument to a <span class="key">template</span> following the special <span class="op">:</span> syntax.
To demonstrate the difference between code blocks of <span class="key">typed</span> and <span class="key">untyped</span> data type
we will cite the compiler manual, see <a href="https://nim-lang.org/docs/manual.html#templates-passing-a-code-block-to-a-template" class="bare">https://nim-lang.org/docs/manual.html#templates-passing-a-code-block-to-a-template</a>:</p>
</div>
<div class="paragraph">
<p>Usually, to pass a block of code to a <span class="key">template</span>, the parameter that accepts the block needs to be of type <span class="key">untyped</span>.
Because symbol lookups are then delayed until <span class="key">template</span> instantiation time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template t(body: typed) =
  proc p = echo "hey"
  block:
    body

t:
  p()  # fails with 'undeclared identifier: p'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above code fails with the error message that <span class="var">p</span> is not declared. The reason for this is that the <span class="func">p()</span>
body is type-checked before getting passed to the body parameter, and type checking in Nim implies symbol lookups.
The same code works with <span class="key">untyped</span> as the passed body is not required to be type-checked:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">template t(body: untyped) =
  proc p = echo "hey"
  block:
    body

t:
  p()  # compiles</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_passing_operators_to_templates">Passing operators to templates</h3>
<div class="paragraph">
<p>One more use case for <span class="key">templates</span> with <span class="key">untyped</span> parameters is the generation
of math operations for custom data types. Let us assume that we have created
a custom <span class="type">Vector</span> <span class="key">object</span>, for which we have to define addition and subtractions
operations. Instead of writing code for both cases, we can use a <span class="key">template</span>
and pass the actual math operator as <span class="key">untyped</span> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Vector = object
    x, y, z: int

template genOp(op: untyped) =
  proc `op`(a, b: Vector): Vector =
    Vector(x: `op`(a.x, b.x), y: `op`(a.y, b.y), z: `op`(a.z, b.z))

genOp(`+`)
genOp(`-`)

echo `+`(2, 3) # 5

var p = Vector(x: 1, y: 1, z: 1)
var p2 = p + p
echo p2 # (x: 2, y: 2, z: 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works, because for operators math like <span class="code">1+2</span> can be written as <span class="code"><code>+</code>(1, 2)</span> and because
we can pass such an operator as <span class="key">untyped</span> parameter to a <span class="key">template</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_advanced_template_use">Advanced template use</h3>
<div class="paragraph">
<p>For the advanced <span class="key">template</span> stuff, you should consult the compiler manual.</p>
</div>
<div class="paragraph">
<p>This includes the symbol binding rules, identifier construction in <span class="key">templates</span>,
lookup rules for <span class="key">template</span> parameters, hygiene in <span class="key">templates</span>, use of the <span class="lit">inject</span> pragma, and
limitations of the method call syntax.</p>
</div>
<div class="paragraph">
<p>All this is explained well in the compiler manual, so it makes no sense to repeat it here.
And it makes more sense to read it when you actually have problems with the (default)
behavior of <span class="key">templates</span> in special situations.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_casts_and_type_conversion">Casts and Type Conversion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While we have various types of casts in C++, we have only one cast and type
conversions in Nim. In Nim, <span class="key">cast</span> just reinterpret the same bit pattern for another
data type. For example, the boolean value <span class="lit">false</span> is internally encoded as a <span class="type">byte</span> with
all bits cleared, and <span class="lit">true</span> is encoded as a <span class="type">byte</span> with all bits but the least
significant one cleared. We could <span class="key">cast</span> a <span class="type">bool</span> to an <span class="type">int8</span> of the same size and would get a
number with decimal value <span class="lit">0</span> or <span class="lit">1</span>. Casting is not a real operation at all, as nothing is really
done. We watch the same bit pattern, just from a different perspective. But casting is
dangerous, it violates the safe type system of the language, and it can go very
wrong: Can we cast between <span class="type">float64</span> and <span class="type">int64</span>? Well they have the same size, and both are
numbers. We can <span class="key">cast</span>, but the result would be far away from what we may expect.
While <span class="type">int64</span> has the well known and simple value encoding, that is rightmost bit
stands for <span class="lit">2^0</span>, next bit for <span class="lit">2^1</span> and so far, the encoding of floating point numbers is much more
difficult and has not such a simple scheme. In <span class="type">floats</span>, some bits represent the so-called
mantissa and some bits represent the exponent. When we <span class="key">cast</span>, we may again get a
number, but the value is not easy predictable. We have to be very carefully when
we <span class="key">cast</span> between types of different size. Nim may permit that, but we have to think
what may really happen. When we <span class="key">cast</span> between a <span class="type">bool</span> and an <span class="type">int64</span>, in one direction 7
bytes have to be ignored, and in the other direction for 7 missing bytes there is
some padding necessary. We do a <span class="key">cast</span> by writing after the keyword <span class="key">cast</span> in square
brackets the desired type, followed by parenthesis enclosing the source variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i: uint8 = cast[unint8](myBoolVar)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Totally different to casting is type conversion. We can convert integers to floating point numbers
without problems, for the conversion we use the type like a <span class="proc">proc</span> call, that is
<span class="func">int(myfloat)</span> or <span class="func">float(myInt)</span>&#8201;&#8212;&#8201;of course we could use method call syntax like
<span class="func">myInt.float</span> instead. Type conversion is some effort for the CPU, but most advanced
CPUs should have fast instructions for basic conversion.</p>
</div>
<div class="paragraph">
<p>Nim generally only allows type conversions that involve not too much effort. So we
should not expect <span class="code">var i ="1234"; echo i.int * 7</span> to be available. Such a conversion is
expensive, at runtime it costs many CPU cycles as we would have to extract the
digits, multiply with it weight and sum them up. So for that operation, functions like
<span class="func">parseInt()</span> are available from the Nim standard library that accept a <span class="type">string</span> as
argument and return an <span class="type">int</span>. There exists different variants of <span class="func">parseInt()</span>, one may
raise exceptions for invalid input, the other may return a boolean.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_bitwise_operations">Bitwise Operations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All systems programming languages, and most other languages, have support for
bit manipulation operations, which includes querying and setting individual bits
of variables, and combining the bits of two or more variables. As the CPU hardware
supports these operations directly, these operations are very efficient. In the
C programming language operators like <span class="op">&amp;</span>, <span class="op">|</span>, <span class="op">&lt;&lt;</span>, <span class="op">&gt;&gt;</span>, <span class="op">^</span>, <span class="op">~</span> are used
for bit-wise <span class="op">and</span> and <span class="op">or</span> operations, for shifting all the bits of a variable to the left or to
the right, and for the process of inverting all the bits and for applying the exclusive-or operation
on the bits of two operands. Actually, for the right shift operation, we have to distinguish between a
logical and an arithmetic shift: For a logical shift the bit pattern is only moved right, and
the leftmost bit is always cleared. But for an arithmetic shift, the leftmost bit may stay set when
it was set before, indicating a negative number in case of a numeric variable. In C the actual
behavior for a <span class="op">&gt;&gt;</span> shift right operation may be implementation dependent.</p>
</div>
<div class="paragraph">
<p>Nim prefers to use textual operators instead of cryptic symbols,
so the logical operators <span class="op">and</span>, <span class="op">or</span> and <span class="op">not</span> have overloads to work on the actual bit pattern of integer
variables instead of on boolean values, and for logical left and right shifts the operators are called
<span class="op">shr</span> and <span class="op">shl</span>. For <span class="op">shl</span> shifted in bits from the right are always cleared, while
 <span class="op">shr</span> shifts in cleared bits from the left for unsigned arguments, but preserved the
leftmost set bit for signed arguments, which corresponds to an arithmetic shift operation.
The Nim standard library provides also an <span class="func">ashr()</span> function for arithmetic shifts, but that
one seems to be a legacy.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from strutils import toBin
var i = 1.int8 # 0b00000001
i = i shl 7 # 0b10000000
i = i shr 2 # 0b11100000 as sign is preserved
echo i.toBin(8)
var j: uint8 = 0b11111111
j = j shr 2 # 0b00111111, div 4 for unsigned int
echo j.int8.toBin(8)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bit-wise operators <span class="op">and</span>, <span class="op">or</span> and <span class="op">not</span> behave very similar
to the boolean ones, but the operation is performed for all the bit values instead of two boolean operands.
The shift operators require a right-hand operand specifying how many positions the
bit pattern of the integer variable on the left should be moved. As the <span class="op">shr</span> operator preserves the leftmost sign bit for
each individual shift when applied to a signed integer argument, we get a value with the three leftmost bits set in the above example.
For showing the bit pattern, we used the <span class="func">toBin()</span> function in the above code, the second
parameter determines how many bits are actually printed.
Remember, that for
unsigned numbers, <span class="op">shl</span> by one position is a multiplication by two, and shr by one position is a division by two.
Negative numbers are not allowed for the number of bits to shift&#8201;&#8212;&#8201;<span class="code">i = i shl -1</span> does compile, but the result is
always zero. For all the shift operations, n shifts each by one position would give the same result as one single shift
by n positions. For most modern CPU hardware, all the bit shifting operations are very fast and generally take only one clock
cycle, independent of how many positions we move the bit pattern and independent if it is a logical or an arithmetic shift operation.</p>
</div>
<div class="paragraph">
<p>We can use the <span class="op">and</span> and the <span class="op">or</span> operator to extract single bits, or to set single bits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a = 3 # two rightmost bits, at position 0 and 1 are set
var b = a and 2 # extract bit 1, so b gets the value 2
b = a and 4 # extract bit 3, which is unset, so result is 0
b = a or (4 + 8) # result is \b00001111, decimal 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should be enough to teach you the most basic bit operations.
Actually, we need these operations not that often, but we should be aware of their
existence. The overloading of the <span class="op">and</span>, the <span class="op">or</span> and the <span class="op">not</span> operator for signed and unsigned
integer numbers may be convenient, but it may sometimes lead to confusion, when
we intend to do boolean operations but instead actually do operations on bit patterns.
It was suggested to call the operators bitand, bitor and bitand instead, and
indeed the <span class="mod">bitops</span> module of Nim&#8217;s standard library defines operators with these names and
provide additional more useful bit operations, including counting the number of set bits in
a variable or determining the number of leading zero bits. These operations are not
needed that frequently, but sometimes they can be very useful, and they are supported by fast CPU
instructions on modern PC hardware. Note that while we have shown these bit operations
on integer numbers only, you can always cast other data types to integers and then
apply these operations as well.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_exceptions">Exceptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When we execute our program code, sometimes something can go wrong: We may
be unable to open a file,
have an unexpected
division by zero or an overflow, or we get some invalid user input. There exists
various strategies to handle such situations. One is to terminate our program, we may
do that by a plain <span class="func">assert()</span> or <span class="func">quit()</span> statement. If we have absolutely no idea how
to recover from an error, then that may be our best option. The user may restart the
program, or the program may be restarted by some sort of supervisor program. For more
expectable errors some form of error indicator may be a better solution, for example
a <span class="func">parseInt()</span> procedure may return a boolean value for success. As we have to return
the numerical result for success as well, the <span class="func">parseInt()</span> <span class="proc">proc</span> may return a <span class="type">tuple</span>, or may use a <span class="key">var</span>
parameter in which the actual integer value is returned. Whenever a <span class="proc">proc</span> returns a reference, then the
return value <span class="lit">nil</span> may be used to indicate some form of error, or we may use Nim&#8217;s option
type to allow the caller to detect if a returned value is invalid.</p>
</div>
<div class="paragraph">
<p>Another popular strategy to handle error states is the use of <span class="type">Exceptions</span>. When somewhere
in the code path an invalid operation is detected, then that code can <span class="key">raise</span> an <span class="type">Exception</span>,
to indicate that a serious error has occurred.
This raised error may be handled elsewhere in the program, or if it is not handled at all, the
raised <span class="type">Exception</span> will finally cause a program termination.</p>
</div>
<div class="paragraph">
<p>Let us start again with a small example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc charToInt(c: char): int =
  if c in {'0' .. '9'}:
    return ord(c) - ord('0')
  raise newException(OSError, "parse error")

proc main =
  while true:
    stdout.write("Please enter a single decimal digit: ")
    let s = stdin.readline
    try:
      echo "Fine, the number is: ", charToInt(s[0])
    except:
      if s.len == 0:
        break
      echo "Try again"

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">charToInt()</span> <span class="proc">proc</span> <span class="key">raises</span> an <span class="type">Exception</span> when the passed character is not a decimal digit.
As the main program knows that <span class="func">charToInt()</span> may <span class="key">raise</span> an <span class="type">Exception</span>,
it encloses the <span class="func">charToInt()</span> call in a <span class="key">try/except</span> block: If code in the try block <span class="key">raises</span>
an <span class="type">Exception</span>, then the program execution proceeds in the <span class="key">except:</span> block.</p>
</div>
<div class="paragraph">
<p>The use of <span class="type">Exceptions</span> seems to be a good idea to handle
some kind of rare errors, and most modern programming languages supports some
form of raising and catching <span class="type">Exceptions</span>.
But there have also been some critics:
This form of raising <span class="type">Exceptions</span>, and catching them with <span class="key">try/except</span> blocks,
breaks the regular control flow of the program,
which may make it hard to reason about all the possible code paths.
For this reason, the popular Go programming language was initially released with <span class="type">Exception</span> handling explicitly omitted, with the developers arguing that it obfuscated control flow.
Actually, the Nim compiler can help us with the bookkeeping of all the involved <span class="type">Exceptions</span> by its
effect system, which is described in much detail in the compiler manual and which we will
discuss briefly in the next section. Nim&#8217;s <span class="type">Exception</span> tracking is part of Nim&#8217;s effect system&#8201;&#8212;&#8201;we can annotate each <span class="proc">proc</span> with all the various types of <span class="type">Exceptions</span> that it may <span class="key">raise</span>, and
the compiler can help us with this annotation and verify that it is correct.</p>
</div>
<div class="sect2">
<h3 id="_defects_and_catchable_errors">Defects and catchable Errors</h3>
<div class="paragraph">
<p>Nim&#8217;s strategy for the handling of <span class="type">Exceptions</span> has changed a bit in the last years. Nim differentiates
now between catchable errors, and defects, which may be not catchable, and are considered to be programming bugs.
The prototype of a defect is the DivByZeroDefect.
If we do an integer division by zero, then most common CPUs
will generate a signal and the OS will abort our program with SIGFPE.
So to prevent the program abort by a possible DivByZeroDefect, we have always to ensure that
for an integer division the denominator is not zero, or we let the Nim compiler
do this check by compiling with option  <span class="term">--checks:on</span>, which cost performance and increases
code size, as then for each division a check instructions is added.</p>
</div>
<div class="paragraph">
<p>In Nim all <span class="type">Exceptions</span> types are <span class="key">objects</span> that inherits from the <span class="type">Exception</span> type of the <span class="mod">system</span> module
and have public <span class="var">name</span> and <span class="var">msg</span> fields of <span class="type">string</span> type.</p>
</div>
<div class="paragraph">
<p><span class="type">Exceptions</span> that indicate programming bugs inherit from <span class="type">system.Defect</span> and can be uncatchable as they can be mapped to operations that terminates the whole process, like a quit / trap / exit operation.
<span class="type">Exceptions</span> that indicate other, catchable runtime errors inherit from <span class="type">system.CatchableError</span>.</p>
</div>
<div class="paragraph">
<p>These types are further subclassed in <span class="type">Defects</span> like <span class="type">OverflowDefect</span> or <span class="type">OutOfMemDefect</span>,
and <span class="type">Errors</span> like <span class="type">ValueError</span> or <span class="type">IOError</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_raise_statement">Raise statement</h3>
<div class="paragraph">
<p>Raising an <span class="type">Exception</span> is done with the <span class="key">raise</span> statement.
<span class="key">Raise</span> expects a heap allocated  reference to an <span class="type">Exception</span> <span class="key">object</span>, as the lifetime of
the <span class="type">Exception</span> instance is unknown. Generally we use the <span class="func">newException()</span>
<span class="key">template</span> to create the <span class="type">Exception</span> instance, and set the <span class="var">msg</span> field like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">raise newException(IOError, "IO failed")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In principle, we could also create the <span class="type">Exception</span> instance like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  e: ref OSError
new(e)
e.msg = "the request to the OS failed"
raise e</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <span class="type">Exception</span> name is given for a <span class="key">raise</span> call, the current <span class="type">Exception</span> is re-raised.
The <span class="type">ReraiseDefect</span> <span class="type">Exception</span> is raised if there is no <span class="type">Exception</span> to re-raise.
It follows that the <span class="key">raise</span> statement always raises an <span class="type">Exception</span>.
Reraising an <span class="type">Exception</span> can be useful in an <span class="key">except</span> block (see below), when the actual
<span class="type">Exception</span> type can not be handled.</p>
</div>
</div>
<div class="sect2">
<h3 id="_custom_exceptions">Custom exceptions</h3>
<div class="paragraph">
<p>Instead of raising one of the predefined <span class="type">Exceptions</span> from the <span class="mod">system</span> module, we can
create also our own variants and then <span class="key">raise</span> them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  LoadError = object of Exception</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_try_statement">Try statement</h3>
<div class="paragraph">
<p>In the Nim compiler manual, we have an example like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var
  f: File
if f.open("numbers.txt"):
  try:
    let a = f.readLine
    let b = f.readLine
    echo "sum: ", parseInt(a) + parseInt(b)
  except OverflowDefect:
    echo "overflow!"
  except ValueError, IOError:
    echo "value or IO error!"
  except:
    echo "Unknown exception!"
  finally:
    close(f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code tries to read two <span class="type">strings</span> from a text file that is assumed to contain numeric data,
and to add them after conversion to integer numbers.
Three errors may occur: The reading of the <span class="type">strings</span> may fail, the conversion to
integers may fail, and finally the addition may cause an overflow.
To catch the possible errors, we use the <span class="key">try/except/finally</span> construct.
The keywords <span class="key">try</span>, <span class="key">except</span> and <span class="key">finally</span> are followed by a colon,
and each keyword marks the start of a corresponding block of instructions&#8201;&#8212;&#8201;after the <span class="key">except</span> keyword
we can list the <span class="type">Error</span> and <span class="type">Defect</span> types for which the following code block should be executed.</p>
</div>
<div class="paragraph">
<p>The statements of the <span class="key">try</span> block are executed in sequential order as long as no  <span class="type">Exception</span> is raised.
If an <span class="type">Exception</span> is raised and the <span class="type">Exception</span> type matched any listed in an <span class="key">except</span> clause, the corresponding statements are executed.
If no <span class="type">Exception</span> types match and an <span class="key">except</span> clause with no listed <span class="type">Exception</span> types is specified,
the following code block is executed.
The statements following the <span class="key">except</span> clauses are called <span class="type">Exception</span> handlers.
If there is a <span class="key">finally</span> clause, it is always executed after the <span class="type">Exception</span> handlers.</p>
</div>
<div class="paragraph">
<p>An <span class="type">Exception</span> is "consumed" in an <span class="type">Exception</span> handler. However, an <span class="type">Exception</span> handler may <span class="key">raise</span> another <span class="type">Exception</span>
or re-raise the current one, which then may be caught elsewhere or generate a program termination if it remains uncaught.
If an <span class="type">Exception</span> is not handled, it is propagated through the call stack. This means that often the rest of the procedure - that is not within a <span class="key">finally</span> clause - is not executed (if an <span class="type">Exception</span> occurs).</p>
</div>
</div>
<div class="sect2">
<h3 id="_try_expressions">Try expressions</h3>
<div class="paragraph">
<p>Similar as we can use the <span class="key">if</span> keyword as an expression, we can do the same with the <span class="key">try</span> keyword.
The data types of the <span class="key">try</span> and the <span class="key">except</span> branches have to be compatible in this case, and an
optionally <span class="key">finally</span> branch has to return nothing (void):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from std/strutils import parseInt
let x = try: parseInt("3.14")
        except: NaN
        finally: echo "well we tried."

let i = (try: parseInt("133a") except: -1)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_except_clauses">Except clauses</h3>
<div class="paragraph">
<p>In an <span class="key">except</span> block, we can use the functions <span class="func">getCurrentException()</span>
to get the raised <span class="type">Exception</span>, or just <span class="func">getCurrentExceptionMsg()</span> to
get only the error message. Or we can access the current
<span class="type">Exception</span> in an <span class="key">except</span> block by use of the <span class="key">as</span> keyword like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">try:
  # ...
except IOError as e:
  # Now use "e"
  echo "I/O error: ", e.msg, " (", e.name, ')'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_imported_exceptions">Imported exceptions</h3>
<div class="paragraph">
<p>It is possible to <span class="key">raise</span> and catch imported C++ exceptions.
The Nim compiler manual has a detailed example for that, see
<a href="https://nim-lang.org/docs/manual.html#exception-handling-imported-exceptions" class="bare">https://nim-lang.org/docs/manual.html#exception-handling-imported-exceptions</a></p>
</div>
</div>
<div class="sect2">
<h3 id="_defer_statement">Defer statement</h3>
<div class="paragraph">
<p>The <span class="key">defer</span> statement can be used to ensure that special actions like
closing a file or freeing resources are always executed.
The <span class="key">defer</span> statement is rewritten by the compiler into a <span class="key">try/finally</span> construct.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var f = open("numbers.txt", fmWrite)
  defer: close(f)
  f.write "abc"
  f.write "def"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Is rewritten to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var f = open("numbers.txt", fmWrite)
  try:
    f.write "abc"
    f.write "def"
  finally:
    close(f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <span class="key">defer</span> is shorter, but with <span class="key">try/finally</span> it is more obvious
what is going on, so some people recommend ignoring the <span class="key">defer</span> statement.
Actually, task like closing files should soon be performed by Nim&#8217;s destructors
automatically, so <span class="key">defer</span> may get deprecated.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://forum.nim-lang.org/t/7514" class="bare">https://forum.nim-lang.org/t/7514</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Exception_handling" class="bare">https://en.wikipedia.org/wiki/Exception_handling</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_effect_system">Effect system</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_destructors">Destructors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Destructors and finalizers are used for automatic resource management.
For example, files can be closed automatically when a file variable goes out of scope,
or when we create high level Nim bindings to C libraries we can use
finalizers or destructors to deallocate entities of the C libs when a corresponding
Nim (proxy) object is freed. Libraries like the gintro GTK bindings make use of this.</p>
</div>
<div class="paragraph">
<p>Finalizers are procedures that can be passed as a second optional parameter to the
system <span class="func">new()</span> <span class="proc">proc</span>. That way the finalizer <span class="proc">proc</span> is attached to the data type of the variable which
we pass as first parameter to <span class="func">new()</span> and that finalizer <span class="proc">proc</span> is
automatically called whenever that variable is freed by the Nim memory management system.
As finalizers are passed as a parameter to a <span class="func">new()</span> call, and <span class="func">new()</span> is only used for
references, finalizers work only for <span class="key">ref</span> data types.</p>
</div>
<div class="paragraph">
<p>Destructors do not have this restriction. We define the destructor for a value type, but
it is also called for reference types by the compiler.</p>
</div>
<div class="paragraph">
<p>Starting with version 1.4 Nim got scope based resource management when
the program is compiled with <span class="code">--gc:arc</span> or <span class="-code">--gc:orc</span>. In that case
variables are immediately deallocated when they go out of scope, and if
a destructor was defined for the data type of that variable it is called automatically.</p>
</div>
<div class="paragraph">
<p>For the programming language C++ it is a common practice that resources like files are closed and released
automatically by destructors when they go out of scope, and now this is also
possible for Nim. To make use of destructors for our own data types we
have to define a <span class="proc">proc</span> called <span class="func">=destroy</span> which gets an instance of our data type passed as
a var value object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = object
    i: int

proc `=destroy`(o: var O) =
  echo "destroying O"

import random

proc test =
  for i in 0 .. 5:
    if rand(9) &gt; 1:
      var o: O
      o.i = rand(100)
      echo o.i * o.i

randomize()
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the for loop we enter a new scope when the <span class="key">if</span> condition is evaluated to <span class="lit">true</span>,
and at the end of the <span class="key">if</span> block we leaf the scope and the destructor is called automatically.
Inside the destructor <span class="proc">proc</span> we could do some cleanup tasks, close files and release resources.
Destructors are also called when <span class="key">ref</span> objects go out of scope:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = ref object of RootRef
    i: int

proc `=destroy`(o: var typeof(O()[])) =
  echo "destroying O"

import random

proc test =
  for i in 0 .. 5:
    if rand(9) &gt; 1:
      var o: O = O() # new O
      o.i = rand(100)
      echo o.i * o.i

randomize()
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To use destructors we have to compile with the option <span class="code">--gc:arc</span> or <span class="code">--gc:orc</span>, otherwise
the specified destructor <span class="proc">procs</span> are just ignored. In our code, we can test for working destructors with
a construct like <span class="code">when defined(gcDestructors):</span>.</p>
</div>
<div class="paragraph">
<p>Note that destructors do not work for plain pointer types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = object
    i: int
  OP = ptr O

proc `=destroy`(o: var O) =
  echo "destroying O"

import random

proc test =
  for i in 0 .. 5:
    if rand(9) &gt; 1:
      var o: OP = create(O) # new O
      o.i = rand(100)
      echo o.i * o.i

randomize()
test()</code></pre>
</div>
</div>
<div class="paragraph">
<p>So using destructors to release data from C libraries directly is not possible.
But at least for Nim &gt;= v1.6 destructors work for distinct pointer types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = object
    i: int
  OP1 = ptr O
  OP = distinct ptr O

proc `=destroy`(o: var OP) =
  echo "destroying OP"

import random

proc test =
  for i in 0 .. 5:
    if rand(9) &gt; 1:
      var o: OP = OP(create(O)) # new O
      OP1(o).i = rand(100)
      echo OP1(o).i * OP1(o).i

randomize()
test()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>81
destroying OP
3600
destroying OP
2401
destroying OP
9025
destroying OP</pre>
</div>
</div>
<div class="paragraph">
<p>So using destructors to destroy data from C libraries should be possible now.</p>
</div>
<div class="sect2">
<h3 id="_destructors_and_inheritance">Destructors and Inheritance</h3>
<div class="paragraph">
<p>When we use OOP style programming with subclassing of ref objects, then
it is useful to know that for subclassed ref objects the destructor of the
parent class is automatically invoked when we do not define our own one
for our subclassed type. This works also when we import the parent
type from another module, at least since Nim v1.6:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># module tt.nim
type
  O1* = ref object of Rootref
    i*: int

when defined(gcDestructors): # check not really needed, as =destroy call is just ignored when condition is false
  proc `=destroy`*(o1: var typeof(O1()[])) =
    echo "destroy O1 ", typeof(o1)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># module t.nim
import tt

type
  O2 = ref object of tt.O1
    j: int

type
  O3 = ref object
    o1: tt.O1

type
  O4 = object
    o1: tt.O1

type
  O5 = ref object of tt.O1
    x: float

when defined(gcDestructors):
  proc `=destroy`(o5: var typeof(O5()[])) =
    echo "destroy O5 ", typeof(o5)
    tt.`=destroy`(o5)

proc main =
  var o1: tt.O1
  new o1
  echo o1.i

  var o2: O2
  new o2
  echo o2.j

  var o3: O3
  new o3
  new o3.o1

  var o4: O4
  new o4.o1

  var o5: O5 = O5(x: 3.1415)
  echo o5.x

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile module t.nim with --gc:arc or --gc:orc and run it, we get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0
0
3.1415
destroy O5 O5:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType
destroy O1 O1:ObjectType</pre>
</div>
</div>
<div class="paragraph">
<p>So when our variables o1 to o5 go out of scope, then the destructors are called.
Module tt.nim defines a ref object type, but the destructor <span class="proc">proc</span> takes a var value
parameter. The destructor is called when a value object or a ref object goes out of scope.
Our variable o1 has type tt.O1, so it was indeed expected that its destructor from module tt.nim
is called. Variable o2 is a ref object with parent O1, as we define no destructor for this type, the destructor
of the parent type is called. The variables o3 and o4 are of ref object and of value object types, each with
a field of type O1, and for that field the destructor for O1 is called. Finally, for type O5 we define
our own destructor, which then additional calls the destructor of module tt.</p>
</div>
<div class="paragraph">
<p>Destructors are mostly used for library implementations, e.g. for a file data type which is
automatically closed when a file variable goes out of scope. As you may never have to use
destructors yourself, it is not necessary to remember all these details. But it is good to know
that destructors behave in a way as we may have expected, and when you later wants to use
a destructor in your own code, you can consult again this section or maybe better the Nim
manual.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://forum.nim-lang.org/t/8013" class="bare">https://forum.nim-lang.org/t/8013</a></p>
</li>
<li>
<p><a href="https://forum.nim-lang.org/t/7360" class="bare">https://forum.nim-lang.org/t/7360</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_finalizers">Finalizers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Nim, finalizers are procedures, that we can specify as an optional second parameter
when we call the system <span class="func">new()</span> <span class="proc">proc</span> to allocate heap memory for a reference type variable.
That specified finalizer <span class="proc">proc</span> is then later called by the Nim memory management system
when the <span class="key">ref</span> variable is freed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = ref object of RootRef
    i: int

proc finO(o: O) =
  echo "finalize O"

proc newO: O =
  new(result, finO)

proc main =
  var o = newO()
  var o2 = new(O)
  var o3 = O(i: 7)

main()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>finalize O
finalize O
finalize O</pre>
</div>
</div>
<div class="paragraph">
<p>The output of the above program is really surprising at first: Only for variable <span class="var">o</span> we call the
proc <span class="func">newO()</span> to initialize it, which then calls <span class="func">new()</span> by passing a finalizer <span class="proc">proc</span> named <span class="func">finO()</span>.
For <span class="var">o2</span> and <span class="var">o3</span>, we allocate memory as usual, without use of a finalizer <span class="proc">proc</span>.
But when <span class="var">o2</span> and <span class="var">o3</span> goes out of scope, even for these two variables, the finalizer <span class="proc">proc</span> <span class="func">finO()</span>
is called. The reason for this is, that the system <span class="proc">proc</span> <span class="func">new()</span> binds the optional finalizer <span class="proc">proc</span>
to the data type of the passed <span class="key">ref</span> variable. This binding process occurs for the first
call with a passed finalizer <span class="proc">proc</span> and can not be reverted. We can later call <span class="func">new()</span> without
finalizer or use the similar <span class="func">O()</span> call to initialize the <span class="key">ref</span> variable, but that can not undo the binding. And using a
different finalizer <span class="proc">proc</span> for the same data type would not work anymore. Passing the same finalizer
proc multiple times is OK and may be a common use case, but it has no real effect, as the first call
did the binding already.</p>
</div>
<div class="paragraph">
<p>This behavior of finalizers in Nim is indeed a bit confusing and error-prone. Maybe somewhere
in a large program we pass a finalizer <span class="proc">proc</span> to <span class="func">new()</span> and forget about it. Later, we use
<span class="func">new ()</span> without a finalizer or use the <span class="func">O()</span> notation to reserve the memory for our <span class="key">ref</span> variable.
So we think that no finalizer is involved, but as a finalizer was used somewhere at least once,
it is now bound to all of our allocations of that data type. That can easily lead to bugs
as the unintended called finalizers may do things that it should not do with our data.</p>
</div>
<div class="paragraph">
<p>Finalizer <span class="proc">procs</span> have to be defined always in the same module as the type for
which the finalizer shall be used is defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># module tt.nim
type
  O* = ref object of RootRef
    i: int

proc fin*[T](o: T) =
  echo "finalize T"

proc newO*: O =
  new(result, fin)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tt

type
  OO = ref object of tt.O
    x: float

proc finn[T](o: T) =
  echo "finalize O"

proc main =
  var oo: OO
  new(oo, finn)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We import module <span class="var">tt.nim</span> and subclass the <span class="type">ref object</span> type <span class="type">tt.O</span>.
While module <span class="var">tt.nim</span> defines a generic finalizer <span class="proc">proc</span> <span class="func">fin()</span>, we can
not use that one for our subclased type <span class="type">OO</span>, but have to copy it
from module <span class="var">tt.nim</span> into our main module and we may have even to use a different
proc name. Otherwise, we get the compiler message</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Error: type bound operation `fin` can be defined only in the same module with its type (OO:ObjectType)</pre>
</div>
</div>
<div class="paragraph">
<p>Whenever we should really need a finalizer or a destructor, we should prefer destructors
when we can compile our code with the compiler options --gc:arc or --gc:orc.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_modules">Modules</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Modules are Nim&#8217;s way to divide multiple source codes in clearly separated units and
to hide implementation details. Nim uses a module concept which is very similar to
Modula-2 or Oberon. All the Nim standard libraries are divided into modules which
collect and logically group data types and the related procedures. In some way,
modules are Nim&#8217;s classes.</p>
</div>
<div class="paragraph">
<p>In Nim, each module directly corresponds to one text file. Submodules as known from
Ruby, that divide a single text file in multiple modules are not supported by Nim
currently.</p>
</div>
<div class="paragraph">
<p>Every text file with Nim source code is basically a module, and that module can be
imported and used by other modules. But all symbols like data types or procedures
have to be exported to make them visible and usable by other modules. That is done
like in Oberon by appending an asterisk character to all names that should be
exported. These restricted exports allow hiding implementation details&#8201;&#8212;&#8201;all
symbols not exported are private to that module and can be changed and improved at
any time without noticing the importing module. Note that when we append the asterisk
to the name of an object to export that type, the object&#8217;s fields are still hidden and can not
be accessed from within the importing module. You may append an asterisk to selected field
names as well, or you may provide exported getter and setter <span class="proc">procs</span> for the field access.
A read-only export as known from the Oberon language is currently not possible with Nim.</p>
</div>
<div class="paragraph">
<p>We can import whole modules, that is, all symbols that are marked for export by the
asterisk, or we can import only the symbols that we need by specifying their names.
Let us create a module that declares a single procedure to remove all characters from
a string that are not letters:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># save this textfile with name mystrops.nim
proc remNoneLetters*(s: string): string =
  result = newString(s.len)
  var pos = 0
  for c in s:
    if c in {'a' .. 'z', 'A' .. 'Z'}:
      result[pos] = c
      inc(pos)
  result.setLen(pos)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We save above text file with our Nim source code with name mystrops.nim.
Note the export marker after the <span class="proc">proc</span> name.
We can import and use that module like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import mystrops

echo remNoneLetters("3h7.5g:8h")</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we import modules, then we put the import statement generally at the top of the
importing module, that way it is easy to see what modules are imported. The imported symbols
can be used in the code after the import statement.
Module names should be lower case and may as other Nim symbols only contain letters,
decimal digits and the underscore character.
We can import multiple modules with a single import statement when we separate the module names with commas.
Starting with Nim v1.6 it is recommended to import modules from Nim&#8217;s standard library with the <span class="var">std</span>
prefix as in <span class="code">import std/math</span> or <span class="code">import std/[strutils, sequtils]</span>.
Importing the same module multiple times is not a problem, and does not increase the
code file of the final executable.
Note that in the import statement
the module names have to be used literally, so this would not work:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">const strfuncs = "stringutils"
import strfuncs</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of importing whole modules, we can
import only single symbols with the <span class="code">from x import y, z</span> syntax like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from mystrops import remNoneLetters

echo remNoneLetters("3h7.5g:8h")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both forms are an unqualified import, that is we can refer to the proc by only its
name, we do not need the qualified form with module name prefix like
<span class="var">mystrops.remNoneLetters()</span> as long as there are no name conflicts. But whenever we
want, we can use the qualified form also.</p>
</div>
<div class="paragraph">
<p>Nim programmer mostly prefer importing whole modules and use unqualified names,
while that is considered bad style in some other languages like Python. In untyped
languages like Python unqualified imports may indeed pollute the name space and
generate many name conflicts, but in statically typed languages like Nim unqualified
imports seems to generate name conflicts only in very rare cases. Procedures with the
same name typically have different parameter lists, so the overload resolution of the
compiler can decide what <span class="proc">proc</span> is to be used. And when really a name conflict occurs,
then the compiler will tell us, and we can easily fix it by prefixing the <span class="proc">proc</span> name
with its module name.</p>
</div>
<div class="paragraph">
<p>For data types, constants or enums chances for name conflicts may be not that tiny,
so we may have to use qualified names.</p>
</div>
<div class="paragraph">
<p>We can also enforce a fully qualified import in Nim by a notation like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from mystrops import nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, we can use all symbols from that module only in qualified form. But
that does not always work that well in Nim, as Nim has not classes like Java, so a
qualified use of method call syntax or qualified use of user defined or overloaded
operators is difficult. Imagine strutils.add(s, '\n'), how should that look with
method call syntax?</p>
</div>
<div class="paragraph">
<p>For imports, we have also the except keyword, so we may do something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils except toUpper</code></pre>
</div>
</div>
<div class="paragraph">
<p>The except keyword can be used to prevent possible name conflicts without having to
use qualified names.</p>
</div>
<div class="paragraph">
<p>Note that the system module is imported automatically, we should not import it
directly. Also note, that Nim always imports only what is really needed in the final
executable, so importing only a few symbols from a module has no code size benefit
over importing the whole module. Still, it may improve readability of your code when
you import only single symbols when you are sure that you require not more. Maybe like
<span class="code">from math import Pi</span>. Note that you can even in that case access other symbols of that
module by fully qualified names like <span class="func">math.sin()</span>.</p>
</div>
<div class="paragraph">
<p>With the growing standard library, it may occur that module names of the standard
library interfere with your own module names. So Nim now allows and recommends
qualified import of modules from the standard library like <span class="code">import std/strutils</span>. And
for external packages installed by the nimble package manager, imports in the form
<span class="code">import package/[mod1, mod2, mod3]</span> are permitted.</p>
</div>
<div class="paragraph">
<p>Finally, you can also import modules under another name using the <span class="key">as</span> keyword
like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tables as maps</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the recent Nim compiler, you can also enforce full qualified import and use of an
alternate module name by using an import statement like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from tables as maps import nil</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this import statement, you could access symbols from the <span class="var">tables</span> module only by
use of the <span class="var">maps</span> module prefix like <span class="func">maps.newTable()</span>.</p>
</div>
<div class="paragraph">
<p>Finally, with the <span class="key">export</span> keyword one library module can export other modules, which it
imports itself. This may simplify the use of connected modules. As an example, when
using the <span class="var">gintro</span> bindings for GTK4, we import all the needed modules generally like
<span class="code">import gintro/[glib, gobject, gtk4]</span>. We may decide to simplify that import statement
by creating one more module called <span class="var">gtkplus</span> that consists only of these two lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># module gtkplus
import gintro/[glib, gobject, gtk4]
export glib, gobject, gtk4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then a user of <span class="var">gintro</span> could just write <span class="code">import gtkplus</span> to have access to all
the modules. Actually for GTK this is not really a good idea, we will tell you more
about the <span class="var">gintro</span> module and maybe about one more of Nim&#8217;s GUI libraries in the second half of the book.</p>
</div>
<div class="sect2">
<h3 id="_cyclic_imports">Cyclic Imports</h3>
<div class="paragraph">
<p>Typically, we try to arrange our own modules in a tree-like bottom-up structure. A module <span class="var">x</span> may define basic
types and simple functions working with these types, and a higher level module <span class="var">y</span> may import all symbols
from module <span class="var">x</span> and extend the functionality. But in rare cases it may be necessary that the modules <span class="var">x</span> and <span class="var">y</span>
import each other, as <span class="var">x</span> has to use types or functions of module <span class="var">y</span>, and vice versa. This case is called cyclic import and is
currently not supported by Nim. Indeed, we should generally try to avoid cyclic imports when possible, as cyclic imports
make the software design difficult. But sometimes we can not really avoid these cycles. In that case, currently the best solution is,
to put all the concerned data types in a separate low level module, which is then imported from both other modules.
The planned Nim version 2.0 may allow cyclic imports, so this restriction may vanish in the future.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_include">Include</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <span class="key">include</span> statement should be not confused with the <span class="key">import</span> statement. <span class="key">Include</span> just
insert a text file at the position where the <span class="key">include</span> statement occurs. <span class="key">Include</span> can be
used to split very large modules in smaller entities.</p>
</div>
</div>
</div>
<h1 id="_part_iii_nims_standard_library" class="sect0">Part III: Nim&#8217;s Standard Library</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>In this part of the book, we will introduce you to some of the most essential
modules of the Nim standard library. This includes modules for common operations
like the serialization of Nim data types to write them
to external nonvolatile storage and read them back into the program later, or handling command
line options and parameters for programs launched from within a terminal window.
Further, we will introduce you to important container data types like hash tables
(sometimes called hash maps in other programming languages) and various kinds
of set data types. We will also introduce modules for working with regular expressions,
and we will show how simple modules like the times or the random module can
be used. Most modules mentioned in this part will be from the Nim standard library, so that
you will not have to install external packages for that. But there may be some exceptions, e.g. for
some external nimble packages with a very useful functionality and an easy user interface.
One of these exceptions is the <span class="mod">regex</span> module: Nim&#8217;s standard library comes with the <span class="mod">re</span> and <span class="mod">nre</span>
modules, which both uses the PCRE C library. We have decided to introduce the <span class="nim">regex</span> module
instead, which is an external package written completely in Nim language.</p>
</div>
<div class="paragraph">
<p>Formally, Nim distinguish between pure and impure libraries and wrappers. The majority of
Nim&#8217;s library consist of pure libraries, that are modules complete written in Nim code.
Impure libraries provide a high level Nim interface, and can be used like pure libraries, but
use C libraries under the hood. Examples are the two modules <span class="mod">re</span> and <span class="mod">nre</span>
which both uses the PCRE C library, and some
database modules.  Impure libraries can be used like the pure ones, when the underlying
C library is installed. The few wrappers that are shipped with Nim provide only a low level
interface to C libraries, which may use unsafe <span class="type">pointers</span> as proc parameters and may require the user
to do manual memory management. Some impure modules uses these wrappers and hide
all the ugly stuff for us, but we generally do not use the wrappers directly.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s standard library is supported by thousands of external packages, which can easily be installed with Nim&#8217;s package managers,
and then can be used in the same way as the modules of the standard library. The next part of the book will
introduce you to the use of external packages and presents some of the most important ones.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_command_line_arguments">Command Line Arguments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When we launch a program from inside the terminal window, we can pass it
some additional parameters, e.g. the name of a file to process or option
parameters to influence the behavior of the program. We have done so
already when we launched the Nim compiler or maybe a text editor from inside our terminal
window. Using command line parameters is convenient when we work from inside a terminal
and there are parameters that we know in advance. A more interactive way to collect
parameters is reading in input while the program is already running, as we did in part II of the
book when processing the list of our friends. We will learn some more details of this interactive
processing of input in the next section.</p>
</div>
<div class="paragraph">
<p>Nim allows processing command line arguments in the same basic way as all C programs do it,
but Nim&#8217;s standard library and some external packages allow also much more advanced handling
of command line arguments. For simple cases, the C-like way is sufficient. For C programs
the command line arguments are even coupled very closely to the language itself, the
number of arguments and the list of parameters are the two typical parameters
of the C main() function and are used in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">// C program expecting one command line argument
// Compile with gcc t.c
#include &lt;stdio.h&gt;
int main( int argc, char *argv[] ) {
  printf("Executing program %s\n", argv[0]);
  if( argc == 2 ) {
     printf("The argument supplied is %s\n", argv[1]);
  }   else if( argc &gt; 2 ) {
     printf("Too many arguments supplied.\n");
  }
  else {
     printf("One argument expected.\n");
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here <span class="var">argc</span> is the number of available arguments, and <span class="var">argv</span> is an <span class="type">array</span> containing the
actual arguments in form of strings. These values are passed to each C program by the
OS when the program is launched from inside a terminal. Actually the value of <span class="var">argc</span> is the number
of passed arguments plus one, that is when we specify no arguments at all, <span class="var">argc</span> has the value one.
And <span class="var">argv[0]</span> is always the name of the executed program. We have to know that command line arguments
passed to a program are separated by white space, that is at least, by one space or tab character. For this
reason, we have to enclose single arguments containing white space in double quotes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc t.c -o t
$ ./t Nim two
Executing program ./t
Too many arguments supplied.
$ ./t "Nim two"
Executing program ./a.out
The argument supplied is Nim two</pre>
</div>
</div>
<div class="paragraph">
<p>In Nim we have the same functionality available by use of the <span class="func">paramCount()</span>
and <span class="func">paramStr()</span> <span class="proc">procs</span>, which we have to import from the <span class="mod">os</span> module.
But <span class="func">paramCount()</span> gives us the actual number of parameters, so
when we call our program on the command line without any arguments, <span class="func">paramCount()</span>
will return the value zero. The symbol <span class="func">paramStr()</span> is not a global <span class="type">array</span> variable, but a procedure.
ParamStr(0) gives us the name of our executable, and with arguments greater zero
we get the passed arguments as <span class="type">strings</span> in ascending order. Using an index number
for an argument that was not provided will cause <span class="func">paramStr()</span> to raise an exception.</p>
</div>
<div class="paragraph">
<p>An argument evaluation similar to our C program from above may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from os import paramCount, paramStr

proc main =
  echo "Executing program ", paramStr(0)
  let argc = paramCount() + 1
  if argc == 2:
    echo "The argument supplied is ", paramStr(1)
    if paramStr(1) in ["-d", "--debug"]:
      echo "Running in debug mode"
  elif argc &gt; 2:
    echo "Too many arguments supplied."
  else:
    echo "One argument expected."

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this plain API is OK when we expect one or two arguments, maybe a file name
and an option, like the <span class="term">-d</span> or <span class="term">--debug</span> parameter used in the code above. For more command
line arguments, things get complicated fast, as arguments can be passed in arbitrary orders and
combinations. So you should try one of the available libraries for that case.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/c-blake/cligen" class="bare">https://github.com/c-blake/cligen</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_reading_data_from_the_terminal">Reading data from the terminal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While using command line arguments is convenient for data like file names or
options that we already know when we launch a program from the terminal window,
often we have to provide textual user input while the program is already running.
Functions for this task are provided by the <span class="mod">io</span> module, which is part of the <span class="mod">system</span> module,
and which we have not to import explicitly. In one of the introducing sections of the
book, we used already the <span class="func">readLine()</span> and the <span class="func">getch()</span> <span class="proc">procs</span> for reading in a line of text from the terminal
and for waiting on a single key press event.</p>
</div>
<div class="paragraph">
<p>For input and output operations in a terminal window, the <span class="mod">io</span> module defines the three
variables <span class="var">stdin</span>, <span class="var">stdout</span> and <span class="var">stderr</span> of <span class="type">File</span> data type. We will discuss file-based input and output
operations in more detail in part III of the book. Many <span class="proc">procs</span> of the <span class="mod">io</span> module expects
as first parameter a variable of <span class="type">file</span> type. We can explicitly open a named file to write data
to external media like the SSD, or we can just use the <span class="var">stdin</span> and <span class="var">stdout</span> variables
to read data from the keyboard and to write text to the terminal window. Unlike other named
files, we do not have to call <span class="func">open()</span> or <span class="func">close()</span> on <span class="var">stdin</span> and <span class="var">stdout</span>
to open or close the files, and some other file operations like <span class="func">setFilePos()</span> may not work for
these file variables:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>var s: string = stdin.readLine()
stdout.write(s)
stdout.flushFile</pre>
</div>
</div>
<div class="paragraph">
<p>We mentioned already, that the <span class="func">readline()</span> function let you type
textual user input, including spaces, and that you have to terminate
your input by pressing the return key to pass the input string to the OS
which forwards the input to our program. This form of input is sometimes
called blocking, as for the time that we wait for user input, our program is really
waiting, it can not do other work til the user has pressed the return key.
For single character input, without the need for pressing actually the return
key, e.g. for a simple <span class="lit">yes/no</span> input, you may use the <span class="func">getch()</span> function, which
is also blocking. In a latter section of the book, we may show how
we can use threading to actually do some useful work, while we wait for user input.
In the literature <span class="var">stdin</span>, <span class="var">stdout</span> and <span class="var">stderr</span> are often called streams, where <span class="var">stderr</span>
can be used instead of <span class="var">stdout</span> for writing error messages. This can be useful
in special cases, when we have an application where we want to redirect
error messages to a file or to separate regular output and error messages.
For more details about these stream or file variables and the use of the <span class="var">stderr</span> variable,
you may consult external literature, if you should really need that info.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">io</span> module does not provide read functions for other basic data types like numeric or
boolean types. So we should use <span class="func">readLine()</span> to read the user input in <span class="type">string</span> form, which we can convert
by functions like <span class="func">parseInt()</span>, <span class="func">parseFloat()</span> or similar functions to numeric data. Note that parsing <span class="proc">procs</span>
like <span class="func">parseInt()</span> are provided by the module <span class="mod">strutils</span> as well as by the module <span class="mod">parseutils</span>&#8201;&#8212;&#8201;one function raises an exception for invalid input,
while the other one returns a boolean value indicating conversion success. Of course, we should
handle textual user input always carefully and never just assume that the input is actually valid data.
Some of the modules that can be used for converting textual input data into other data types
like the <span class="mod">strutils</span>, <span id="parseutils# and [" class="mod mod">strscans</span> modules are described in more detail at the end of this part
of the book.</p>
</div>
<div class="paragraph">
<p>For advanced user input processing, like cursor movement, colored
display or displaying progress bars, you may also consult the <span class="mod">terminal</span> module.
And finally, to create fancy textual user interfaces (TUIs) we recommend
trying external packages like the <span class="var">illwill</span> library.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Standard_streams" class="bare">https://en.wikipedia.org/wiki/Standard_streams</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/terminal.html" class="bare">https://nim-lang.org/docs/terminal.html</a></p>
</li>
<li>
<p><a href="https://github.com/johnnovak/illwill" class="bare">https://github.com/johnnovak/illwill</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_writing_text_to_the_terminal_window">Writing text to the terminal window</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In previous sections, we have used the <span class="func">echo()</span> function to write variables
of various data types to the terminal window. The <span class="func">echo()</span> function accepts
multiple arguments, writes the string representation of the passed arguments
to the terminal window, and terminates the action by writing the <span class="lit">\n</span> character
to move the cursor to the beginning of the next line in the terminal window.
We have already used the <span class="func">write()</span> function from the <span class="mod">io</span> module for
the case that we want to write a single <span class="type">string</span> to the terminal without
a terminating newline character. The <span class="mod">io</span> module contains some overloaded <span class="func">write()</span>
functions for other basic data types like <span class="type">int</span>, <span class="type">float</span> or <span class="type">bool</span>, and a variant with
a <span class="type">varargs</span> parameter and applied stringify operator, so that <span class="func">write()</span> can be used
like <span class="func">echo</span>, as long as we pass <span class="var">stdout</span> as first parameter. For the actual output operation, the C library function <span class="func">fprintf()</span> is used.
Note that write operations to <span class="var">stdout</span> are generally buffered, so the result
of <span class="func">write()</span> operations may remain invisible until we write a <span class="type">string</span> containing
a newline character or until we call the <span class="func">flushfile()</span> function to enforce
the writing of the buffer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_option_types"><span class="new">Option types</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Option types can be used to encapsulate values in a way that allows to mark the value as undefined.
This can be especially useful for the return types of functions, which may or may not return a meaningful value.</p>
</div>
<div class="paragraph">
<p>Let us assume that we have a function called <span class="func">find()</span> that searches in a <span class="str">string</span> for the
first index position of a character:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc find(s: string; c: char): int =
  result = -1 # not found
  var i = 0
  while i &lt; s.len:
    if s[i] == c:
      return i
    inc(i)

echo "Nim".find('i')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function returns the index position or  <span class="lit">-1</span> to indicate that the character has not been found.
This works, as we use in Nim typically signed integers, and
the valid <span class="str">string</span> index positions are never negative, so it is obvious
that a negative <span class="key">result</span> is some form of error indication. In a similar
way, whenever a function should return a reference or a <span class="key">pointer</span>, the
special value <span class="lit">nil</span> can be used to indicate the absence of a value.
Actually in most cases we can just define a special value as the
indication for the absence of a <span class="key">result</span> or as error indicator,
for example <span class="func">int.low</span>, <span class="func">char(0)</span>, or <span class="lit">NaN</span> for <span class="type">float</span> results.</p>
</div>
<div class="paragraph">
<p>Other ways to indicate failures is to <span class="key">return</span> a boolean value for success and to <span class="key">return</span>
the actual <span class="key">result</span> value as a <span class="key">var</span> parameter, to <span class="key">return</span> a <span class="type">tuple</span>, which encloses a boolean
for success indication and the actual <span class="key">result</span>, or returning the <span class="key">result(s)</span> as a sequence which can
be empty in case of no success:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc find(s: string; c: char; pos: var int): bool =
  pos = 0
  while pos &lt; s.len:
    if s[pos] == c:
      return true
    inc(pos)

var p: int
echo "Nim".find('i', p), ": ", p</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc find(s: string; c: char): tuple[succ: bool, pos: int] =
  var i = 0
  while i &lt; s.len:
    if s[i] == c:
      return (true, i)
    inc(i)

echo "Nim".find('i')</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc find(s: string; c: char): seq[int] =
  var i = 0
  while i &lt; s.len:
    if s[i] == c:
      result.add(i)
    inc(i)

echo "Nim".find('i')</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a more formalized way to indicate the absence of a meaningful <span class="key">result</span>,
many modern programming languages provide the concept of <span class="type">Option</span> types,
which are called sometimes also <span class="type">Maybe</span> types.
<span class="type">Option</span> types can encapsulate an arbitrary data type and provide
functions like <span class="func">isSome()</span> or <span class="func">isNone()</span> to test for the existence of a valid value, and
functions like <span class="func">get()</span> to extract the actual value from the <span class="type">Option</span> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/options

proc find(s: string; c: char): Option[int] =
  var i = 0
  while i &lt; s.len:
    if s[i] == c:
      return some(i)
    inc(i)

var res = "Nim".find('i')
if res.isSome:
  echo res.get</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="mod">options</span> module of Nim&#8217;s standard library provides the generic <span class="type">Option[]</span> data type
and the functions <span class="func">some()</span>, <span class="func">isSome()</span> and <span class="func">isNone()</span> to create a new <span class="type">Option</span> type encapsulating
some data, and to check if data is present. In the code above, we use <span class="func">some(i)</span> to wrap the
integer value in the <span class="type">Option</span> type when we have found a match. For no match,
the <span class="proc">proc</span> <span class="key">returns</span> the default empty <span class="type">Option</span> type instance. When we use the <span class="func">find()</span> function with the
<span class="type">Option[int]</span> <span class="key">result</span>, we have to call first <span class="func">isSome()</span> to check if valid data is available, and
then call <span class="func">get()</span> to get the actual data.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s <span class="type">Option</span> types are based on <span class="key">objects</span>. The generic <span class="type">Option[T]</span> type is an <span class="key">object</span> with two fields,
a boolean indicating the presence of data, and a field which can store the actual data.
Nim uses also an optimization: When the data type is of <span class="key">ref</span> or <span class="key">pointer</span> type, then the
bool field is not necessary, as the absence of data is equivalent to a data entity with <span class="lit">nil</span> value.</p>
</div>
<div class="paragraph">
<p>The overhead of <span class="type">Option</span> types is not that big&#8201;&#8212;&#8201;a <span class="proc">proc</span> which would return an 4-byte integer
would return an <span class="key">object</span> instead&#8201;&#8212;&#8201;the additional boolean field would increase the size
of the <span class="key">result</span> to 5 bytes, which is generally extended by the compiler to multiples
of the word size, that is 8 byte total. So we have 100 % size overhead for the worst case.
And the loss of performance for the encapsulation of data in <span class="type">Option</span> types
should be not significant in most use cases.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">options</span> module provides some more procedures for the handling of <span class="key">Option</span> types,
but this short introduction should be enough to get you started.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Option_type" class="bare">https://en.wikipedia.org/wiki/Option_type</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_serializationstoring_data_permanently_on_external_storage">Serialization&#8201;&#8212;&#8201;storing data permanently on external storage</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When you start writing larger programs, these programs may create data which you may want to
store permanently on external nonvolatile storage like SSDs or traditional hard disks of your computer.
For textual data, this is very easy, as you basically only has to write and read a stream
of unstructured bytes. But when your program deals with object instances, container data
types like sequences or references, things become more complicated. Writing the data
is always easy&#8201;&#8212;&#8201;you can just convert all the fields of your object data type to strings
and write them to a stream or a file. But the reading back part is much more difficult: You would
have to read in the data as strings and then process each string&#8201;&#8212;&#8201;maybe converting to a <span class="type">float</span> number&#8201;&#8212;&#8201;and then assign to the matching field of an object instance.</p>
</div>
<div class="paragraph">
<p>When your data consists only of value objects and no references, then you may consider
just writing that data in plain binary form to a file and read it back. This strategy seems
to be simple, and it is very fast, as no type conversion steps are involved. But at the same time it has some
drawbacks: The stored data can not be checked with tools like a text editor, it can generally not
be used from other programs, and when you should change the data types used in your program, you could
not read back stored files anymore.</p>
</div>
<div class="paragraph">
<p>So we will explain how you can store Nim data types in a human-readable text format first.
Two popular text formats are <span class="ndef">JSON</span> and <span class="ndef">YAML</span>. JSON is a simple format, which is easy to parse, but not
very good readable for humans. YAML is more complicated, but more flexible and is very good
readable for humans.</p>
</div>
<div class="paragraph">
<p>For Nim, we have already many modules which we can use for storing data in JSON or YAML format available.
The Nim standard library includes the <span class="mod">marshal</span> and the <span class="mod">json</span> module. The <span class="mod">marshal</span> module uses, like
the <span class="mod">json</span> module the json data file format, is easy to use and simple, but is not really designed
to generate human-readable data files, as the stored data is not stored as a sequence of individual lines.
So we will describe and use the <span class="mod">json</span> module in this section, which is also easy to use, but has some larger
set of functionality and can generate real human readable text files by use of the pretty() function.</p>
</div>
<div class="paragraph">
<p>Other available external packages for data serialization are the nim-serialization module set from (<a href="https://github.com/status-im/nim-serialization" class="bare">https://github.com/status-im/nim-serialization</a>)
and the very powerful but complicated NimYaml implementation (<a href="https://nimyaml.org/" class="bare">https://nimyaml.org/</a>). We may describe these packages
in part V of the book.</p>
</div>
<div class="paragraph">
<p>When we have to store and read back Nim data to nonvolatile storage media, we have some serious
points to consider: First we have to handle various data types like integers, floats, strings, objects&#8201;&#8212;&#8201;and
even the container types like sequences. And we may have to support reference types and maybe also inherited types
and containers filled with heterogeneous, subclassed reference objects. The <span class="mod">json</span> module supports all Nim data types,
including containers and references, but not heterogeneous sequences.</p>
</div>
<div class="paragraph">
<p>For our first json example, let us assume that we have written a small tool that
let the user create some geometrical shapes, and we want to store the shapes
to a file and read it back. For that, we generally use an intermediate step, which
converts the data to a string and the string back to the data object. The string is
then written to a file or stream and read back. Let us start with the string conversion&#8201;&#8212;&#8201;storing that string and reading it back from the file will be explained soon.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import json

type
  Line = object
    x1, y1, x2, y2: float

  Circ = ref object of RootRef
    x0, y0: float
    radius: float

  Data = object
    lines: seq[Line]
    circs: seq[Circ]

var
  l1 = Line(x1: 0, y1: 0, x2: 5, y2: 10)
  c1 = Circ(x0: 7, y0: 3, radius: 20)
  d1, d2: Data

d1.lines.add(l1)
d1.circs.add(c1)
d1.lines.add(Line(x1: 3, y1: 2, x2: 7, y2: 9))
d1.circs.add(Circ(x0: 9, y0: 7, radius: 2))

let str1 = pretty(%* d1) # convert the content of variable d1 to a string
echo str1 # let us see how the strings looks
d2 = to(parseJson(str1), Data) # read the string back into a data instance
let str2 = pretty(%* d2) # and verify that we got back the original content
echo str2

# assert d1 == d2 would fail
assert str1 == str2</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run the program, we would get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>{
  "lines": [
    {
      "x1": 0.0,
      "y1": 0.0,
      "x2": 5.0,
      "y2": 10.0
    },
    {
      "x1": 3.0,
      "y1": 2.0,
      "x2": 7.0,
      "y2": 9.0
    }
  ],
  "circs": [
    {
      "x0": 7.0,
      "y0": 3.0,
      "radius": 20.0
    },
    {
      "x0": 9.0,
      "y0": 7.0,
      "radius": 2.0
    }
  ]
}
{
  "lines": [
    {
      "x1": 0.0,
      "y1": 0.0,
      "x2": 5.0,
      "y2": 10.0
    },
    {
      "x1": 3.0,
      "y1": 2.0,
      "x2": 7.0,
      "y2": 9.0
    }
  ],
  "circs": [
    {
      "x0": 7.0,
      "y0": 3.0,
      "radius": 20.0
    },
    {
      "x0": 9.0,
      "y0": 7.0,
      "radius": 2.0
    }
  ]
}</pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, we converted the instance <span class="var">d1</span> of type <span class="type">Data</span> to a <span class="str">string</span>, and then we convert
that string back to variable <span class="var">d2</span> with matching content. We have made intentionally
the <span class="type">Circ</span> a <span class="key">ref</span> <span class="key">object</span>, so we can see that the conversion works for value and reference objects.
In the example program, we applied the %* macro to our data instance <span class="var">d1</span> to get a <span class="type">JsonNode</span>, and
finally use the <span class="func">pretty()</span> function to get a nice multi-line string. To fill the variable <span class="var">d2</span> with
the content stored in <span class="var">str1</span>, we first have to apply <span class="func">parseJson()</span> on the <span class="str">string</span> and then use <span class="func">to()</span> to
unmarshal the json node into the matching <span class="key">object</span> type.</p>
</div>
<div class="paragraph">
<p>Now let us investigate what happens when we try to use the <span class="mod">json</span> module with
a container with heterogeneous <span class="key">ref</span> <span class="key">objects</span>. For that we subclass the <span class="type">Disc</span> type,
creating a new <span class="type">Arc</span> type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import json
from math import PI

type
  Line = object
    x1, y1, x2, y2: float

  Circ = ref object of RootRef
    x0, y0: float
    radius: float

  Arc = ref object of Circ
    startAngle, endAngle: float

  Data = object
    lines: seq[Line]
    circs: seq[Circ]

var
  d1, d2: Data

d1.lines.add(Line(x1: 0, y1: 0, x2: 5, y2: 10))
d1.circs.add(Circ(x0: 7, y0: 3, radius: 20))
d1.lines.add(Line(x1: 3, y1: 2, x2: 7, y2: 9))
d1.circs.add(Arc(x0: 9, y0: 7, radius: 2, startAngle: 0, endAngle: PI))

echo d1.circs[1] of Arc, " ", Arc(d1.circs[1]).endAngle

let str1 = pretty(%* d1)
d2 = to(parseJson(str1), Data)
let str2 = pretty(%* d2)
echo str2
echo d2.circs[1] of Arc</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of that program looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>true 3.141592653589793
{
  "lines": [
    {
      "x1": 0.0,
      "y1": 0.0,
      "x2": 5.0,
      "y2": 10.0
    },
    {
      "x1": 3.0,
      "y1": 2.0,
      "x2": 7.0,
      "y2": 9.0
    }
  ],
  "circs": [
    {
      "x0": 7.0,
      "y0": 3.0,
      "radius": 20.0
    },
    {
      "x0": 9.0,
      "y0": 7.0,
      "radius": 2.0
    }
  ]
}
false</pre>
</div>
</div>
<div class="paragraph">
<p>While our initial instance <span class="var">d1</span> contains a run-time value of <span class="type">Arc</span> type, and so we can access
the <span class="var">endAngle</span> field, we get <span class="lit">false</span> as result for the <span class="code">of Arc</span> test for the <span class="var">d2</span> instance. So run-time type
information is lost.</p>
</div>
<div class="paragraph">
<p>When we have to store different data types in one container, then one solution is to use
object variants, which should work with the <span class="mod">json</span> module. Another obvious possibility is
to just copy the data into containers with the appropriate static type before storing to
an external medium, and copy them back when we read the data back from external storage.
Will will show an example for that now:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import json
from math import PI

type
  Line = ref object of RootRef
    x1, y1, x2, y2: float

  Circ = ref object of RootRef
    x0, y0: float
    radius: float

  Arc = ref object of Circ
    startAngle, endAngle: float

  Data = object
    elements: seq[RootRef]

  Storage = object
    lines: seq[Line]
    circs: seq[Circ]
    arcs: seq[Arc]

const
  DataFileName = "MyJsonTest.json"

var
  d1, d2: Data
  storage1, storage2: Storage
  outFile, inFile: File

d1.elements.add(Line(x1: 0, y1: 0, x2: 5, y2: 10))
d1.elements.add(Circ(x0: 7, y0: 3, radius: 20))
d1.elements.add(Line(x1: 3, y1: 2, x2: 7, y2: 9))
d1.elements.add(Arc(x0: 9, y0: 7, radius: 2, startAngle: 0, endAngle: PI))

for el in d1.elements:
  if el of Arc:
    storage1.arcs.add(Arc(el))
  elif el of Circ:
    storage1.circs.add(Circ(el))
  elif el of Line:
    storage1.lines.add(Line(el))
  else:
    assert(false)

let str1 = pretty(%* storage1)

if not open(outFile, DataFilename, fmWrite):
  echo "Could not open file for storing data"
  quit()
outFile.write(str1)
outFile.close

if not open(inFile, DataFilename, fmRead):
  echo "Could not open file for recovering data"
  quit()
let str2 = inFile.readAll()
inFile.close

assert str1 == str2

storage2 = to(parseJson(str2), Storage)

for el in storage2.lines:
  d2.elements.add(el)
for el in storage2.circs:
  d2.elements.add(el)
for el in storage2.arcs:
  d2.elements.add(el)

for el in d2.elements:
  if el of Arc:
    echo "found arc with endAngle: ", Arc(el).endAngle</code></pre>
</div>
</div>
<div class="paragraph">
<p>For this example program, we use OOP programming style and keep all the geometric object instances as
references in a single sequence. Note that doing this is not always a good idea, as this OOP style with
the use of references and dynamic run-time dispatch can be slower due to many small heap allocations for
each <span class="key">ref</span> <span class="key">object</span> and due to the dynamic dispatch (<span class="key">if</span> el <span class="key">of</span> &#8230;&#8203;) overhead. Using multiple, homogeneous sequences with value types for each of our
data types can be a better solution, and in that way you have more control whenever you process the data, for drawing
them on the screen or user interaction for example. Maybe you want to draw all the lines first?
But there can be situations where we really need to have all the objects as references in a single container.
A typical situation is, that we use an <span class="type">RTree</span> for fast object location. <span class="ndef">RTrees</span> are data structures, that can store
two-dimensional or multidimensional geometric objects and their rectangular bounding boxes in a tree-like fashion
for fast object location. This may be used in a drawing program, so that coordinates of a user mouse click can be fast
matched to an object. For such a use case, we would really prefer to have all the object instances available in one single <span class="type">RTree</span>,
and not use one <span class="type">RTree</span> data structure for each object shape.</p>
</div>
<div class="paragraph">
<p>Our program defines an additional <span class="type">Storage</span> data type, which contains homogeneous sequences for each possible geometric shape.
We then copy all our <span class="key">ref</span> <span class="key">objects</span> from the elements sequence in the matching sequences of the storage object using the
dynamic <span class="key">of</span> type query to select the exactly matching sequence.</p>
</div>
<div class="paragraph">
<p>After that we can use the already known json functions to serialize the storage object into a <span class="str">string</span>, store the string
to a file, read it back and deserialize the data again into a different variable of <span class="type">Storage</span> data type. Finally, we use a simple <span class="key">for</span> loop
to copy the <span class="key">ref</span> <span class="key">objects</span> from the temporary storage <span class="key">object</span> into a <span class="type">Data</span> variable called d2. For storing the data to an external
nonvolatile medium we use the <span class="type">File</span> data type and the related functions <span class="func">open()</span>, close, <span class="func">write()</span> and <span class="func">read()</span>. Their use should be
obvious: We pass an uninitialized variable of <span class="type">File</span> data type, a file name and a file mode to <span class="func">open()</span>, use <span class="func">write()</span> to write
the whole string, and use <span class="func">readAll()</span> to read the data back. When done with each file, we use <span class="func">close()</span> to close the file.
The <span class="type">File</span> data type is part of the <span class="mod">io</span> module, which is again part of the <span class="mod">system</span> module, so we don&#8217;t have to import these modules.
We could have used as an alternative also the <span class="mod">streams</span> module. We will learn some more details about the <span class="type">File</span> data type
and the <span class="mod">streams</span> module in later sections of the book.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We should mention that unfortunately, live is not always that easy, as sometimes we can not
freely select the textual output format. Imagine that you create a CAD (computer aided design) tool
that should be compatible with another existing tool. In this case, the textual storage format
is already defined by the existing tool, and generally that format does not match the json or
yaml file format. Even when the format should be one of these, matching it exactly would be difficult.
While writing out own data in that foreign format is still not really difficult, as we can just write
single matching strings, reading in the textual data is more complicated: Typically we would read the input file line by line, and
we would have to inspect and interpret each input string, maybe by use of regular expressions or a custom parser.
That generally includes handling of missing or invalid data.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/json.html" class="bare">https://nim-lang.org/docs/json.html</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/io.html" class="bare">https://nim-lang.org/docs/io.html</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/marshal.html" class="bare">https://nim-lang.org/docs/marshal.html</a></p>
</li>
<li>
<p><a href="https://github.com/status-im/nim-serialization" class="bare">https://github.com/status-im/nim-serialization</a></p>
</li>
<li>
<p><a href="https://nimyaml.org/" class="bare">https://nimyaml.org/</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_streams_and_files">Streams and Files</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous section, we learned how we can store structured data like
a sequence of objects in human-readable form to nonvolatile media
by use of the <span class="mod">json</span> module.</p>
</div>
<div class="paragraph">
<p>Text in form of a single <span class="str">string</span> or in form of a container holding
multiple <span class="str">strings</span> is some kind of unstructured data which we can
write directly to nonvolatile storage, and later read it back.
We can do the same with containers of basic, unstructured data types
like integer or floating point numbers, and with some restrictions we can even
write <span class="type">tuples</span> or objects directly as raw bits and bytes to external storage and read
it back later. Of course, this way the stored data is a binary blob, which can not
be read or modified by other tools like a text editor. But that may be not
intended or advantageous at all, maybe we do scientific data processing with
a single tool, and we just want to temporarily store the data and continue
with the processing later.</p>
</div>
<div class="sect2">
<h3 id="_files">Files</h3>
<div class="paragraph">
<p>For storing unstructured data, Nim provides the <span class="mod">io</span> module with the <span class="type">File</span>
data type and related <span class="proc">procs</span>, and the <span class="mod">streams</span> module with the <span class="type">Stream</span> data type
and related <span class="proc">procs</span>. While a <span class="type">File</span> in Nim is currently only a pointer to a C file, the <span class="mod">streams</span>
module has a higher abstraction level. Although the Nim language does not directly support
interfaces, the <span class="type">Stream</span> data type of the <span class="mod">streams</span> module is some form of an interface,
which is implemented by a <span class="type">StringStream</span> and a <span class="type">FileStream</span> data type. Internally, this interface
concept is realized by storing a set of function pointers in the <span class="type">Stream</span> instance.</p>
</div>
<div class="paragraph">
<p>When we have to store unstructured data like text, it is not always clear if we better should use
<span class="type">Files</span> or <span class="type">Streams</span>. <span class="type">Streams</span> may be the better choice when we (also) want to use a <span class="str">string</span> as data source like a file
or when we need the <span class="func">peek()</span> functions of the <span class="mod">streams</span> module to access data without advancing the position
in the stream.</p>
</div>
<div class="paragraph">
<p>We will use the <span class="type">File</span> data type of the <span class="mod">io</span> module first. As the <span class="mod">io</span> module is part of the <span class="mod">system</span> module, we do
not have to import it before we can use it. The principle usage of files is, that we call the function <span class="func">open()</span> to open
a file with given name, call some <span class="proc">procs</span> to write or read data, and finally <span class="func">close()</span> the file.
While Nim support destructors when we compile with --gc:arc or --gc:orc, the <span class="mod">io</span> module
does not yet use them, so we should actually call close() to close the file.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Historically, a file is a one dimensional data type which is accessed in sequential order. Up to the end of the
twenty century, it was not uncommon that large files were stored on magnetic tapes,
which could be read or written only slowly in sequential order. Read or write operations could take
place only at the actual position, and available functions like <span class="func">f.setFilePos()</span> were very slow
as it involves moving the tape. The introduction of hard disks and solid state disks removed this restriction,
and modern operating system often buffers files in RAM for longer time periods, so that files may have actually
similar performance as arrays or sequences. The funny fact is, that with the modern CPU caches
the ordinary RAM storage can look similar slow and sequential compared to the extreme fast cache as
magnetic tapes in the past.</p>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from os import fileExists
proc main =
  const FN = "NoImportantData"
  if os.fileExists(FN):
    echo "File exists, we may overwrite important data"
    quit()
  var f: File = open(FN, fmWrite)
  f.write("Hello ")
  f.writeLine("World!")
  f.writeLine(3.1415)
  f.close
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running that program will create a text file with this content in the current working directory:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Hello World!
3.1415</pre>
</div>
</div>
<div class="paragraph">
<p>At the start of our function, we check if a file with that name already exists in the current working directory by using the function <span class="func">os.fileExists()</span>
to ensure that we do not overwrite important data.</p>
</div>
<div class="paragraph">
<p>Module <span class="mod">io</span> provides multiple overloaded <span class="func">open()</span> <span class="proc">procs</span>. We use here a variant
which returns a file, and raises an exception for the unlikely case of an error.
We provide a file name and a file mode as parameters. We use mode <span class="const">fmWrite</span> as we want
to create a new file. Note that <span class="const">fmWrite</span> would clear the content of an existing file, so
we can not use <span class="const">fmWrite</span> to append data to an existing file. We would have to use
<span class="const">fmReadWriteExisting</span> or <span class="const">fmAppend</span> to append data to an already existing file.
As this <span class="func">open()</span> <span class="proc">proc</span> can raise an exception, it may make sense to enclose it
in a try/except block, or we could use an <span class="func">open()</span> variant which returns a boolean value to indicate success instead.
When the file is successfully opened, we can use <span class="proc">procs</span> like <span class="func">write()</span> or <span class="func">writeLine()</span> to
write text <span class="str">strings</span> to the file. Both <span class="proc">procs</span> accept multiple arguments and apply the stringify operator
<span class="op">$</span> on them before writing the content. <span class="func">WriteLine()</span> writes a <span class="lit">'\n'</span> after the last argument to start a new line.
When done, we call <span class="func">close()</span> to close the file. The operating system would close the file for us when our program terminates, so
calling close is not that important, but when we open many files without closing them we may get
errors from the operating system finally about too many open files and our program may fail or terminate.</p>
</div>
<div class="paragraph">
<p>The <span class="func">close()</span> <span class="proc">proc</span> gets passed the file not as a var parameter, so it can not set the file
to value nil. When the file has the value nil, then the <span class="func">close()</span> call is ignored, but when we would call
<span class="func">close()</span> multiple times with a non <span class="lit">nil</span> argument we get a program crash.
We may use the try/finally or the defer construct to ensure that we really close the file when done.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">io</span> module provides some <span class="proc">procs</span> like <span class="func">writeBuffer()</span>, <span class="func">writeBytes()</span> or <span class="func">writeChars()</span> which gives us
as return value the actual number of bytes written. This return value should generally match
the requested number of bytes to write, but can be smaller when the write operation fully
or partially failed, e.g. because the storage medium had no capacity left.</p>
</div>
<div class="paragraph">
<p>When performance really matters, we should note that passing non-string arguments
to <span class="func">write()</span> or <span class="func">writLine()</span> <span class="proc">procs</span> using their optional auto-stringify for us, involves
allocation of new <span class="str">strings</span> and cost some performance. When we have in our program already
a <span class="str">string</span> variable available, it can be faster to convert our data into that variable first and then pass
that variable to the <span class="func">write()</span> or <span class="func">writeLine()</span> <span class="proc">procs</span>.</p>
</div>
<div class="paragraph">
<p>Reading <span class="str">strings</span> from a file works very similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var f: File
  try:
    f = open("NoImportantData", fmRead)
    echo f.readLine
    echo f.readLine
  finally:
    if f != nil: # test for nil not really necessary, close() would ignore the call for f == nil
      f.close
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">readLine()</span> <span class="proc">proc</span> reads in a line of text. The LF, CR or CRLF line end markers
are not part of the returned text string. Of course, we may get an
empty string with length zero back when we read a line which
immediately starts with LF, CR or CRLF, or we may get back a <span class="type">string</span>
with no visible characters but only a few spaces or tabulator characters <span class="lit">'\t'</span>
when a line contains only white space.
When our <span class="func">read()</span> operations have moved the actual file io position to the
end of the file, and we try to read more content, then an exception is raised.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">io</span> module provides a <span class="func">readLine()</span> <span class="proc">proc</span> that returns a newly allocated <span class="str">string</span>,
and one that takes an existing <span class="str">string</span> as a <span class="key">var</span> parameter. The latter may be a bit faster,
as it can avoid the allocation of a new buffer when the passed <span class="str">string</span> has already enough capacity.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">io</span> module provides a function called <span class="func">endOfFile()</span> with a boolean result
which we can use to check if the end of file position is already reached.
The provided functions <span class="func">readBuffer()</span>, <span class="func">readBytes()</span> or <span class="func">readChars()</span> return
the actual number of bytes read, which can be smaller than the requested value when
the end of the file is reached earlier. Currently, <span class="func">readChars()</span> checks if the passed
<span class="type">openArray[char]</span> has enough capacity for the request, but <span class="func">readBytes()</span> does no
check!</p>
</div>
<div class="paragraph">
<p>We can use also the <span class="func">lines()</span> iterator to iterate over the lines of a text file, or use the <span class="func">readLines()</span>
proc to read the content line by line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var f: File
  f = open("NoImportantData", fmRead)
  for str in f.lines: # iterator
    echo str
  f.setFilePos(0) # read again from start index 0
  var s: string
  while f.readLine(s): # proc
    echo s
  f.close
  var sq = readLines("NoImportantData", 2) # read lines to seq of strings
  echo sq
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>As iterating over the comple file line by line moves
the actual file position to the end of the file, we called <span class="func">setFilePos()</span> to move again to the start position.
The <span class="func">readLines()</span> <span class="proc">proc</span> takes a filename
and the number of lines to read as parameters and returns a <span class="type">seq</span> of <span class="var">strings</span>. When the
file does not contain at least the number of requested lines, an EOF exception is raised.
Another provided <span class="proc">proc</span> is <span class="func">readAll()</span> which reads the entire file content into a returned <span class="str">string</span> variable.
For <span class="func">readAll()</span> to work, the actual file position has to be the start of the file. In case of an
error, an exception is raised.</p>
</div>
<div class="paragraph">
<p>We can also write and read binary data directly to a file, without converting it
to (human-readable) strings first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc main =
  var f: File
  f = open("NoImportantData", fmWrite)
  var i: int = 123
  var x: float = 3.1415
  assert f.writeBuffer(addr(x), sizeof(x)) == sizeof(x)
  assert f.writeBuffer(addr(i), sizeof(i)) == sizeof(i)
  f.close
  f = open("NoImportantData", fmRead)
  assert f.readBuffer(addr(x), sizeof(x)) == sizeof(x)
  assert f.readBuffer(addr(i), sizeof(i)) == sizeof(i)
  f.close
  echo i, " ", x
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, these are low level, dangerous operations. While <span class="func">writeBuffer()</span> should never crash
our program, <span class="func">readBuffer()</span> can do that easily when we specify wrong sizes or destination addresses, as that may overwrite
other data unintentionally. So we would generally not use these <span class="proc">procs</span> directly but write more safe
helper <span class="proc">procs</span>, when we really need or want this form of binary file access. Fast storing big data sets with restricted hardware may
be a use case, e.g. storing a <span class="type">float32</span> takes only 4 bytes on the storage medium and file io is fast, while
that number as human-readable digits may need more than 8 bytes (1.234567E3) and converting to
<span class="str">string</span> and parsing back costs some time.</p>
</div>
<div class="paragraph">
<p>In the same way, we can use <span class="func">writeBuffer()</span> and <span class="func">readBuffer()</span> to store <span class="type">tuples</span>, <span class="key">objects</span> and <span class="type">arrays</span>
or sequences of these directly in binary form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  O = object
    x: float
    i: int
    b: bool

proc main =
  var s: seq[O]
  s.add(O(x: 3.1415, i: 12, b: true))
  var f: File
  f = open("NoImportantData", fmWrite)
  assert f.writeBuffer(addr(s[0]), sizeof(O) * s.len) == sizeof(O) * s.len
  f.close
  f = open("NoImportantData", fmRead)
  var s2 = newSeq[O](1)
  assert f.readBuffer(addr(s2[0]), sizeof(O) * s2.len) == sizeof(O) * s2.len
  f.close
  echo s2[0]
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Output should look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>(x: 3.1415, i: 12, b: true)</pre>
</div>
</div>
<div class="paragraph">
<p>But of course this is dangerous and fragile. We just show that example as beginner
typically ask about it, and may want to try it at least once. Obviously this can
only
work when the <span class="type">tuples</span> or <span class="key">objects</span> contain only plain data types, that is no <span class="str">string</span>, no
references and of course no other nested container types like sequences or tables. And reading back
data may fail when we use a different OS or a different compiler version.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">io</span> module provides the <span class="type">File</span> variables <span class="var">stdin</span>, <span class="var">stdout</span> and <span class="var">stderr</span>,
which are the standard input, output and error streams.
Sometimes we use
<span class="func">stdout.write()</span> instead of the common <span class="func">echo()</span> <span class="proc">proc</span> when we want to write
something to the terminal window without moving the cursor to the next line already.</p>
</div>
<div class="paragraph">
<p>An important function of the <span class="mod">io</span> module is <span class="func">flushFile()</span>, which is used to ensure that
all buffer content of buffered files is actually written to the file. This is important
when we use the <span class="var">stdout</span> <span class="type">File</span> variable, maybe to ask the user a question in the terminal window.
We would call <span class="func">sdtout.flushFile()</span> to ensure that the user really sees the text on the screen
immediately. The <span class="func">echo()</span> <span class="proc">proc</span> calls <span class="func">flushFile()</span> automatically after each output operation.
When we close a file <span class="func">flushFile()</span> should be called automatically, but when
our program is terminated without calling <span class="func">close()</span> it may depend on the actual implementation and operating system</p>
</div>
<div class="paragraph">
<p>The <span class="mod">io</span> module provides some more useful procedures, but we will
stop this introducing section here and continue with the <span class="mod">streams</span> module in the next section.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/io.html" class="bare">https://nim-lang.org/docs/io.html</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_streams">Streams</h3>
<div class="paragraph">
<p>A stream is an abstract interface for performing certain I/O operations, which was introduced
by languages like C or Modula-2 decades ago. The <span class="mod">streams</span> module of the Nim standard library
provides a <span class="type">FileStream</span> and a <span class="type">StringStream</span> implementation, which behaves very similar.
Nim&#8217;s <span class="mod">streams</span> module provides similar functions as the <span class="mod">io</span> module with its <span class="type">File</span> data type,
but it can operate on <span class="str">strings</span> instead of on <span class="type">Files</span>, and it provides a set of <span class="func">peek()</span> functions
to access data at the current read position without moving forward. And some functions are
more robust, for example closing a stream multiple times does not crash the program,
as the first <span class="func">close()</span> call sets the file variable of file streams to <span class="lit">nil</span>, so that following <span class="func">close()</span> calls are ignored.
Currently, the <span class="mod">streams</span> module does not support automatically closing of streams when
they go out of scope.</p>
</div>
<div class="paragraph">
<p>We can create a new <span class="type">FileStream</span> by calling the overloaded <span class="proc">procs</span> <span class="func">newFileStream()</span>
with an already opened file or a filename as parameter, or we can use <span class="func">openFileStream()</span>.
The latter raises an exception when the stream can not be opened, while the former <span class="proc">procs</span>
just return nil. We can write and read textual data with the <span class="mod">streams</span> module in a very similar way as we did it with the
<span class="mod">io</span> module and the <span class="type">File</span> data type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from os import fileExists
import streams

proc main =
  const SN = "NoImportantData" # stream name
  if os.fileExists(SN):
    echo "File exists, we may overwrite important data"
    quit()
  var fstream = newFileStream(SN, fmReadWrite)
  if fstream != nil:
    fstream.write(123, ' ')
    fstream.writeLine(3.1415)
    fstream.setPosition(0)
    let l = fstream.readLine()
    fstream.close()
    assert l == "123 3.1415"
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We test again if a file with that name already exists. Then we try to create a
new <span class="type">FileStream</span> by using file mode <span class="const">fmReadWrite</span>, so that we can write and
read from that file. Finally, we write two numbers, which are automatically
converted to <span class="type">strings</span>, set the file position back to the beginning and verify
what we wrote by reading it in again, before we close the stream.</p>
</div>
<div class="paragraph">
<p>In a very similar way, we can write to and read from <span class="str">string</span> streams</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import streams
proc main =
  var stream = newStringStream()
  stream.write(123, ' ')
  stream.writeLine(3.1415)
  stream.setPosition(0)
  let l = stream.readLine()
  stream.close()
  assert l == "123 3.1415"
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we do not test if the stream variable is not <span class="lit">nil</span>, as
<span class="func">newStringStream()</span> should never fail.</p>
</div>
<div class="paragraph">
<p>For buffered streams, we can call <span class="func">flush()</span> to ensure that the buffer content (of file streams) is written,
similar as we can do it for plain <span class="type">Files</span> of the <span class="mod">io</span> module.
Instead of <span class="func">io.endofFile()</span> we use the <span class="proc">proc</span> <span class="func">atEnd()</span> to test if the current stream position
is already at the end of the stream. Functions <span class="func">getPosition()</span> and <span class="func">setPosition()</span> are
available to query or set the actual position in the stream. While the <span class="mod">io</span> module
with its <span class="type">File</span> data type supports for <span class="func">io.setFilePos()</span> although position modes relative to the actual position or relative to the file end,
<span class="func">streams.setPosition()</span> always use absolute values, that is positions measured from the beginning of the stream.
The <span class="mod">streams</span> module provides also the low level <span class="proc">procs</span> <span class="func">readData()</span> and <span class="func">readDataStr()</span>
which reads data to a memory region or into a <span class="str">string</span> and returns the actual number of bytes read
to indicate success. And as for the <span class="mod">io</span> module, a <span class="proc">proc</span> <span class="func">readAll()</span> is available to read all data
of a stream into the returned <span class="str">string</span> variable.</p>
</div>
<div class="paragraph">
<p>The <span class="proc">procs</span> <span class="func">writeLine()</span> writes the passed arguments always as <span class="type">strings</span>. The overloaded <span class="func">write()</span>
<span class="proc">procs</span> with <span class="type">varargs</span> arguments write the passed values as <span class="str">strings</span> and apply the stringify operator <span class="op">$</span>
if necessary. The same does the <span class="func">writeLine()</span> <span class="proc">proc</span>, but it writes a newline character
when all passed variables have been written. One more overloaded write <span class="proc">proc</span> for single string parameters exist.</p>
</div>
<div class="paragraph">
<p>But for single non string arguments a generic <span class="func">write()</span> <span class="proc">proc</span> is used, which writes numbers
(and other data types like boolean types or single characters) directly in binary form without converting them to <span class="type">strings</span>.</p>
</div>
<div class="paragraph">
<p>To read the binary numbers back, we can use functions like <span class="func">readFloat64()</span> which have a
well-defined return type and read a fixed number of bytes. Or we can use the generic <span class="func">read()</span> <span class="proc">proc</span>
which accepts a <span class="key">var</span> parameter which defines the data type that we intend to read in binary form.
Additional to the various <span class="func">read()</span> <span class="proc">procs</span> the <span class="mod">streams</span>
module provides a set of <span class="func">peek()</span> <span class="proc">procs</span> which reads data in without moving the actual
position in the stream forward. This may be useful for parsing of files, as we can
read the same information multiple times easily. Internally, the <span class="func">peek()</span> functions uses
a call of <span class="func">setPosition()</span> to save the current position and one more call of <span class="func">setPosition()</span>
to set back the old position to the initial value, so <span class="func">peek()</span> has some overhead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import streams
from os import getFileSize
proc main =
  const SN = "NoImportantData" # stream name
  var fstream = newFileStream(SN, fmReadWrite)
  if fstream != nil:
    fstream.write("012") # write a 3 byte string
    var pi: float64 = 3.1415
    fstream.write(pi) # write as 8 byte binary blob
    fstream.setPosition(0) # prepare for reading from start
    var i16: int16
    i16 = fstream.peekint16 # read first 2 bytes as int16, do not change actual position
    assert i16 == '0'.ord + '1'.ord * 256
    var i8: int8
    i8 = fstream.readInt8 # read back one byte
    # fstream.read(i8) # does work also
    assert i8 == '0'.ord # char(0) has position 48 in ASCII table
    assert i8 == 48
    var buffer: array[2, char]
    fstream.read(buffer)
    let x = fstream.readFloat64 # read back in binary form
    assert x == 3.1415
    fstream.close()
    assert buffer == ['1', '2']
    assert os.getFileSize(SN) == 3 + 8 # 3 byte string and a float64
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, we write a three byte long string and a <span class="type">float64</span> to the file stream.
We call <span class="func">setPosition(0)</span> to read the stream from the beginning again, and then
read in an <span class="type">int16</span> with the function <span class="func">peekint16()</span> without moving the actual position
forward, followed from <span class="func">readInt8()</span>, which moves the actual position one byte forward.
(Instead of <span class="func">readInt8()</span> we could also call <span class="func">read()</span> with variable <span class="var">i8</span> as passed <span class="key">var</span> parameter.)
Then we read in two bytes and finally the <span class="type">float64</span> value at the end of the stream.
Finally, we check by use of the function <span class="func">getFileSize()</span> from the <span class="mod">os</span> module if
the file has really the expected size.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">streams</span> module provides many functions, and the possible writing data
as <span class="str">strings</span> or in binary form can make using that module a bit daunting at first.
But most <span class="proc">procs</span> have examples in the API docs which helps you to use it.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>For reading <span class="str">strings</span> and whole lines the <span class="mod">streams</span> module provides functions like
<span class="func">readLine()</span>, <span class="func">peekLine()</span>, <span class="func">readStr()</span> and <span class="func">peekStr()</span> each in a variant which returns a newly allocated
<span class="str">string</span> and one that uses a passed <span class="key">var</span> parameter to return the <span class="str">string</span>. The variants with
<span class="key">var</span> parameters may be a bit faster, as they can avoid allocating a new <span class="str">string</span> when the passed
in <span class="key">var</span> parameter has already enough capacity.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/streams.html" class="bare">https://nim-lang.org/docs/streams.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_string_processing">String Processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p><span class="str">string</span> processing is a wide area. Nim&#8217;s standard library provides various modules
like <span class="mod">strutils</span>, <span class="mod">parseutils</span> and <span class="mod">strscans</span> for supporting this task, and external packages
supports more advanced operation like <span class="str">string</span> pattern matching with regular expressions (regex).
We will start with the <span class="mod">strutils</span> module, which is one of the mostly used modules of
the Nim standard library. Then we will introduce some more specialized modules like
<span class="mod">strscans</span>, <span class="mod">parsecvs</span>, <span class="mod">parseutils</span>, <span class="mod">strformat</span>, and finally we will give an introduction to the use of regular expressions
(regex) and to the use of the parsing expression grammar (PEG). While we describe generally
only modules of Nim&#8217;s standard library in this part III of the book, we will make an exception
for regex and PEG. The reason for this is, that regex and PEG use is closely related to
basic string processing and that very powerful external packages exists, which are not
too difficult to use and so needs not too much introductory explanation.</p>
</div>
<div class="paragraph">
<p>Whenever we do string processing in Nim, we should care a bit for performance,
as some <span class="str">string</span> operations can be slow by design. For simple tasks, we should
prefer to use functions from the simple modules like <span class="mod">strutils</span> when possible, and
use regex or PEG only when really necessary or when performance is uncritical.
And even when we use elementary simple functions like a <span class="str">string</span> split, it is
generally good to have a feeling how the requested operations may work.
Whenever <span class="str">string</span> functions return a <span class="str">string</span> as a result, this implies an allocation, which
takes some time and consumes some memory. An example is the <span class="func">split()</span> operation,
which returns a sequence of multiple <span class="type">strings</span>. The <span class="func">split()</span> function is easy to use, so
it is often the first choice when we read in lines of text from files and want to process
it. But as for each section of the split line a string is allocated, it may be not as fast as desired.
In some cases the compiler may be able to optimize the slitting process, but
it may be also a good idea to think about other ways to extract the data, maybe by
applying <span class="proc">procs</span> from the <span class="mod">strscans</span> module which can parse lines directly into passed <span class="key">var</span>
parameters avoiding unnecessary allocations.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Remember that Nim <span class="str">strings</span> are value types and have value semantic.
String assignment copies the string content and does not create just
a reference as in some other programming languages. Nim defines also
a <span class="str">string</span> variant called <span class="type">TaintedString</span>, which is mainly just an alias for
an ordinary <span class="str">string</span> as long as the taint mode is not turned on. Functions like
<span class="func">io.readLine()</span> return tainted <span class="str">strings</span>, which typically can be used like ordinary <span class="type">strings</span>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basic_string_operations">Basic string operations</h3>
<div class="paragraph">
<p>We discussed Nim&#8217;s <span class="str">string</span> data type already in part II of the book. Remember that a <span class="type">string</span>
in Nim is a variable size container for ASCII characters. <span class="str">Strings</span> can be plain ASCII <span class="type">strings</span>, or
the bytes of the <span class="str">string</span> can be interpreted as Unicode glyphs. Nim has also a <span class="type">cstring</span> data type,
which was initially introduced to be compatible with the character arrays used in C libraries
as <span class="type">strings</span>, but is now called compatible string as <span class="type">cstrings</span> do also support the JavaScript backend.
Nim <span class="str">strings</span> can be passed directly to C libs, as a Nim <span class="str">string</span> contains a Null terminated buffer
for the actual data, which is identical to a C language <span class="str">string</span>. So whenever we convert a Nim <span class="str">string</span> to a C language <span class="var">string</span>
or pass a Nim <span class="str">string</span> to a C library, this is free of costs, while converting a C <span class="str">string</span> to a Nim <span class="str">string</span> always
means allocating a new Nim <span class="str">string</span> and coping the data content. Technically for a Nim <span class="str">string</span> <span class="var">s</span>
<span class="code">addr s[0]</span> is the C <span class="str">string</span> pointer, called * char in C language. Whenever we pass <span class="str">strings</span> to
C libraries, we have to care for the fact that Nim&#8217;s garbage collector may deallocate the <span class="var">string</span>
automatically. Most C libs create copies of passed <span class="str">strings</span> when the libs use the <span class="str">string</span> for
a longer time span. GTK for example does this with text for its widgets. But when the
C lib does not copy the <span class="str">string</span> but use it directly for a longer time, then it can occur that
the Nim code frees the <span class="str">string</span>, as the only one Nim variable referring to the <span class="str">string</span> goes
out of scope, but the C library still uses the <span class="str">string</span>. For that rare case, we may call
<span class="func">GC_ref()</span> on the <span class="str">string</span> to prevent garbage collection, but that may generate memory leaks then.
For the case that C libs create <span class="type">strings</span>, they provide generally also a function to deallocate the
<span class="str">string</span>. When we use such a C function, it is typically the best solution that we copy
the <span class="str">string</span> from the C lib to a Nim <span class="str">string</span> and immediately deallocate the C <span class="str">string</span> by a
call of the provided <span class="func">free()/dealloc()</span> function. For most C libs there exist good high level bindings
which do not have this issues, so we mostly can use the C libs like pure Nim libs.</p>
</div>
<div class="paragraph">
<p>Nim' s <span class="mod">system</span> module provides already some basic <span class="str">string</span> operation like accessing single
characters by the subscript operator <span class="op">[]</span>, accessing slices of multiple adjacent characters, or
joining multiple strings with the <span class="op">&amp;</span> operator. The overloaded <span class="func">add()</span> functions to
append single characters or other <span class="str">strings</span> to existing <span class="str">string</span> variables are also provided by
the <span class="mod">system</span> module.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s: string = "I like"
s &amp;= " Nim."
s[^1] = '!'
s[0 .. 4] = "We low" # result is: "We love Nim!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start the above example by assigning to the <span class="str">string</span> variable <span class="var">s</span> a string literal,
then we append one more <span class="str">string</span> literal, and finally replace the last character
and the first five characters by another character and by another <span class="str">string</span>.
Note that by using the slice operator we can not only replace character ranges, but we can also
replace slices of different length. This way, we can also delete ranges in the <span class="type">string</span>
by replacing it with the empty <span class="str">string</span> <span class="var">""</span>.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">system</span> module also defines the stringify operator <span class="op">$</span>, which converts
expressions to the <span class="str">string</span> presentation when we put it in front of it. <span class="proc">procs</span>
like <span class="func">echo()</span> apply the stringify operator automatically on all of its arguments when necessary.
And the <span class="mod">system</span> module provides the <span class="func">contains()</span> function, which we can use to
test if a <span class="str">string</span> contains a character. Instead of contains, we can also use the <span class="op">in</span> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>echo $7
echo "Nim".contains('i')
echo 'i' in "Nim"</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="mod">system</span> module also provides the <span class="proc">procs</span> <span class="func">newString()</span> and <span class="func">newStringOfCap()</span>
which are mostly used for optimizing purposes. The function <span class="func">newString(n)</span> creates a <span class="type">string</span>
of length <span class="var">n</span>, but with uninitialized content. We would have to assign characters
to the positions <span class="code">0 .. n-1</span> to create a valid <span class="str">string</span>. The function <span class="func">newStringOfCap()</span> creates
a <span class="str">string</span> with length zero, but with a buffer capacity of <span class="var">n</span> characters.
When we know the needed buffer capacity, or at least a lower bound of it, it makes sense
to create the <span class="str">string</span> with <span class="func">newStringOfCap()</span> with optimal buffer size to avoid reallocations.
Of course, we could still append more data, Nim would allocate a larger buffer and copy content.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s1 = newString('z'.ord - 'a'.ord + 1)
for c in items('a' .. 'z'):
  s1[c.ord - 'a'.ord] = c

var s2 = newStringOfCap(32) # we intend to append not more than 32 characters, but we could do.
for c in 'a' .. 'z':
  s2.add(c)
# s1, s2 is abcdefghijklmnopqrstuvwxyz</code></pre>
</div>
</div>
<div class="paragraph">
<p>Filling in characters into an existing <span class="str">string</span> by use of the subscript operator
<span class="op">[]</span> is faster than appending single characters with the <span class="func">add()</span> function, because
the <span class="func">add()</span> function has to check if the <span class="str">string</span> has still enough capacity and because
<span class="func">add()</span> has to increase the actual <span class="str">string</span> length by one for each call.</p>
</div>
<div class="paragraph">
<p>Note that a single character like <span class="lit">'a'</span> is very different from a <span class="str">string</span> with only
one character like <span class="lit">"a"</span>. A character in Nim is nothing more than a single byte, while
a <span class="str">string</span>&#8201;&#8212;&#8201;even one with only one character or an empty one&#8201;&#8212;&#8201;is an opaque entity with length, capacity and a pointer to a data buffer.
When a single character is sufficient, we should
use that and not a <span class="str">string</span> containing a single character. A function call like <span class="func">s.add("a")</span>
may produce less optimized code than <span class="func">s.add('a')</span>, but maybe the compiler optimized
the former for us. When we consider optimization, we may wonder if
in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s = "Hello!"
echo s
s = "Bye."
echo s</code></pre>
</div>
</div>
<div class="paragraph">
<p>line 3 allocates a new <span class="str">string</span> or just copies the <span class="str">string</span> literal <span class="lit">"Bye."</span>
in the existing data area. Well we would hope for the latter of course.</p>
</div>
<div class="paragraph">
<p>Another interesting question is if in</p>
</div>
<div class="listingblock">
<div class="content">
<pre>var s = "Result is: "
var x = 12.34
echo s, x
echo s &amp; $x</pre>
</div>
</div>
<div class="paragraph">
<p>we should better use line 3 or line 4. Line 3 looks more clear, and we assume that
it also would produce better code, as the actual append operation is avoided.</p>
</div>
<div class="paragraph">
<p>Often used functions are <span class="func">len()</span> and <span class="func">setLen()</span> to query and set
the length of a <span class="str">string</span>. While <span class="func">len()</span> looks like a function call,
it is a compiler intern function, so calls are fully optimized. So it is OK to write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">for i in 0 .. s.len():
  echo '*'</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is not necessary to introduce a temporary variable like let <span class="code">l = s.len()</span> to avoid
many function calls. In C this is different, as in C a call of function <span class="func">strLen()</span> would not only
imply a function call, but that function would really have to count all characters up to
the terminating <span class="lit">'\x0'</span> as C <span class="str">strings</span> have no length field.
The function <span class="func">setLen()</span> is mostly used to truncate <span class="type">strings</span>. A call like <span class="func">s.setLen(0)</span>
makes <span class="var">s</span> look like a newly allocated <span class="str">string</span>, but its data buffer can be reused. Reusing
<span class="str">strings</span> is generally better for performance than allocating many new <span class="type">strings</span>.
The <span class="func">setLen()</span> function is rarely used to increase the <span class="str">string</span> length&#8201;&#8212;&#8201;in that case an allocation
of a larger data buffer can occur, and the <span class="str">string</span> would still look the same
as initially all the new <span class="str">string</span> positions would still contain the default binary zero content.
We would have to fill in actual characters by use of the <span class="op">[]</span> subscript operator.
To get the lowest and highest character index of a <span class="str">string</span>, we can use <span class="func">s.low</span> and <span class="func">s.high</span>.
<span class="func">s.low</span> should be always return zero, and <span class="func">high()</span> is identical to <span class="code">len() - 1</span>, so <span class="func">high()</span> is
<span class="lit">-1</span> for an empty <span class="str">string</span>. Note that while calling <span class="func">high()</span> and <span class="func">len()</span> on a Nim <span class="type">string</span>
has no costs, this may be different to C <span class="str">strings</span> as these have no length field.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">system</span> module provides the overloaded <span class="op">&amp;</span> operator which we can use
to concatenate <span class="type">chars</span> and <span class="type">strings</span>, the <span class="op">&amp;=</span> operator to append a new <span class="str">string</span> to an existing <span class="str">string</span>, and
the <span class="func">add()</span> functions to append characters or <span class="str">strings</span> to an existing <span class="str">string</span>. For
best performance we should try to use always the most simple, "native" operations,
at least as that does not make the code ugly, or we know for sure that the compiler optimizes
it for us.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s = "Ni"
s = s &amp; "m" # maybe not a good idea for optimal performance
s.add('m') # better</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <span class="func">add()</span> can be also used to add a <span class="type">cstring</span> to a <span class="str">string</span>, and the JS backend
allows even to append one <span class="type">cstring</span> to another one by <span class="func">add()</span> calls.</p>
</div>
<div class="paragraph">
<p>Module <span class="mod">system</span> also exports a <span class="func">substr()</span> <span class="proc">proc</span> which copies and return a <span class="type">slice</span> of a <span class="str">string</span>.
Overloads with optional first index with default <span class="lit">0</span> and optional last index with default
<span class="var">s.high</span> exists.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s = "Hello!"
assert s.substr(2, 3) == s[2 .. 3]

s = "ABC"
echo s[0 .. 5] # fail
echo s.substr(0, 5) # index is clipped to s.high
s[0 .. 5] = "" # fail</code></pre>
</div>
</div>
<div class="paragraph">
<p>And of course, <span class="op">==</span> and <span class="op">!=</span> operators for <span class="str">string</span> comparison are provided.
To test if a <span class="str">string</span> is empty, we can compare with an empty <span class="str">string</span> literal
or test if <span class="func">len()</span> is zero. The latter is guaranteed to have the best performance, but
the former is a bit shorter and should be not bad performance wise. Some other languages
provide an <span class="func">empty()</span> test function for this, we may define our own when we really want.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">if s != "":
if s.len != 0:</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we pass a <span class="str">string</span> to a <span class="proc">proc</span> that does no operations with it, maybe
it only calls <span class="func">echo()</span> or <span class="func">stdout.write()</span> to print it, then it may have
a tiny performance advantage to pass it as <span class="var">cstring</span>. This is similar
as we may pass sequences as <span class="type">openArray</span> to functions, which
also avoids one level of indirection. Also note, that while a Nim <span class="str">string</span> is
a value type, so we can not test it for <span class="lit">nil</span> or return <span class="lit">nil</span> from a <span class="proc">proc</span>
that shall return a <span class="str">string</span>, this restriction does not hold for <span class="var">cstrings</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_module_stringutils">Module stringutils</h3>
<div class="paragraph">
<p>The module <span class="mod">stringutils</span> provides a set of functions (120 currently) and a few iterators
for simple <span class="str">string</span> operations. Using that functions and iterators is simple in most cases and
mosty well explained in the API docs. Remembering which functions exist, their exact name
and the function arguments can be a bit difficult at first. We will introduce in this section some of the
most used or more difficult functions, and give some warnings when the actual performance
may be not as good as expected.</p>
</div>
<div class="paragraph">
<p>Performance critical operations are generally that one which has to allocate new <span class="str">strings</span> or that has
to shift many characters, like text inserting operations. Note that some functions of this module,
like <span class="func">toUpperAscii()</span> work only with the lower and upper ASCII letters. For Unicode operations
we may need the <span class="mod">unicode</span> module.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>In this section we use the term whitespace, which refers to the invisible characters
{' ', '\t', '\v', '\c', '\n', '\f'} (space, tab, vertical tab, carriage return, new line, form feed).
Note that we have two possible newline characters {'\c', '\n'} that starts a new line, and that older
windows text files may still use the two character string "\c\n" to start a new line.
The character set {'A'..'Z', 'a'..'z'} is called (ASCII) letters, the set {'0'..'9'} (decimal) digits and the
set {'0'..'9', 'A'..'F', 'a'..'f'} hex digits used to represent hexadecimal numbers.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The <span class="mod">stringutils</span> module support string interpolation by use of the <span class="op">%</span> operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo "The $1 programming language is $2." % ["best", "Nim"]
echo "The $# programming languages are $#." % ["most difficult", "C++, Rust and Haskell"]
echo "A $adj programming language is $lang." % ["adj", "low level", "lang", "assembly"]
echo "Let's learn $#" % "Nim!"
echo format("I know $# programming languages.", 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use <span class="lit">$1</span> up to <span class="lit">$9</span> to mark positions where <span class="str">string</span> <span class="var">n</span> from the array should be inserted, or
just <span class="lit">$</span> to insert the <span class="str">strings</span> in the order as they appear in the <span class="type">array</span>. We can also use
named insert markers and specify name-value <span class="str">string</span> pairs in the <span class="type">array</span>. For a single
<span class="str">string</span>, we can omit the <span class="type">array</span> and pass just as <span class="str">string</span>, and finally we can use the <span class="func">format()</span>
proc to enable stringify for the parameters.</p>
</div>
<div class="paragraph">
<p>We mentioned already the useful but performance critical set of <span class="func">split()</span> functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
let str = "Zero, first, second, third"
var s: seq[string] = str.split(", ")
echo s
echo str.split(", ", 0)
echo str.split(", ", 1)
echo str.split(", ", 3)
echo str.split(", ", 4)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>@["Zero", "first", "second", "third"]
@["Zero, first, second, third"]
@["Zero", "first, second, third"]
@["Zero", "first", "second", "third"]
@["Zero", "first", "second", "third"]</pre>
</div>
</div>
<div class="paragraph">
<p>We used the <span class="func">split()</span> variant, which accepts a <span class="str">string</span> as split marker. This function
accepts one optional parameter for the number of splits to execute and returns
a sequence containing the single <span class="type">strings</span>. The split marker <span class="str">string</span>, also called separator,
is removed from the <span class="type">strings</span>. The default value for the number of splits is <span class="lit">-1</span> indicating
that we want a split at each separator position. If we specify a positive number <span class="var">n</span>, then only
<span class="var">n</span> splits are executed and the last element of the returned sequence will contain the remainder
of the <span class="str">string</span>. When we specify for the intended splits a value which is larger than the number of contained
split markers, then we get a full split.</p>
</div>
<div class="paragraph">
<p>The reason why this function is not very fast is that it has to allocate a sequence for the return value
and a new <span class="str">string</span> for each split and one more for the last <span class="str">string</span> or the remainder. For the case that we
do need only the first few <span class="str">strings</span> of the split, it is a good idea to specify the number of actual splits
to increase performance.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">strutils</span> module provides overloaded functions which use single characters as separators or
which accepts a set of characters as separators, so we may split at space, tabulator, comma or semicolon
with {' ', '\t', ',', ';'}. And a
function <span class="func">splitWhitespace()</span> is available to split at whitespace like spaces and tabulators, which
removes all the whitespace between the strings. Notice that the <span class="func">split()</span> function for <span class="str">strings</span> or single characters does
one split for each separator, so we can get empty strings as result as in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
let str = "Zero___first_second__third"
let str2 = "Zero first\tsecond           third"
echo str.split('_')
echo str2.splitWhiteSpace()
# @["Zero", "", "", "first", "second", "", "third"]
# @["Zero", "first", "second", "third"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>An interesting behavior of <span class="func">splitWhiteSpace()</span> is that whitespace at the start or
end of a <span class="str">string</span> is just ignored, while the <span class="func">split()</span> function returns additional empty strings
when the string to split starts or ends with the separator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
let str = "_Zero_first_second_third_"
let str2 = "   Zero first\tsecond           third   "
echo str.split('_')
echo str2.splitWhiteSpace()
# @["", "Zero", "first", "second", "third", ""]
# @["Zero", "first", "second", "third"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another function is <span class="func">splitLines()</span> which splits a string at CR, LF or CR-LF characters.</p>
</div>
<div class="paragraph">
<p>For these splitting functions also iterator variants exists, which behave
like the functions with same name. When we limit for the iterators
the number of splits to perform, we may get as last returned value
the remained <span class="str">string</span>. You may consult the API docs for details if necessary.</p>
</div>
<div class="paragraph">
<p>Functions with names <span class="func">rsplit()</span> are also available which behave like <span class="func">split()</span> but start
the splitting process from the end of the <span class="str">string</span>, so we can get the file extension of
a file name with something like <span class="code">filename.rsplit(1)[^1]</span>.</p>
</div>
<div class="paragraph">
<p>The functions <span class="func">removePrefix()</span> and <span class="func">removeSuffix()</span> can sometimes help to avoid
expensive split operations. There is an overloaded function that removes all single characters,
all characters from a set or a single string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
var s = "NNimmm Language"
s.removePrefix('N'); echo s # immm Language
s.removePrefix({'N', 'i', 'm', ' '}); echo s # Language
s.removePrefix("Langu"); echo s # age
s. removeSuffix("ge"); echo s # a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other useful functions are <span class="func">startsWith()</span> and <span class="func">endsWith()</span> which accept a single character or a <span class="type">string</span>
and return a boolean value:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
var s = "Nim Language"
echo s.startsWith('N') # true
echo s.startsWith("Nim") # true
echo s.endsWith('e') # true
echo s.endsWith("Programming") # false</code></pre>
</div>
</div>
<div class="paragraph">
<p>An efficient function similar to <span class="func">find()</span> is <span class="func">continuesWith()</span> used like <span class="code">"Nim Language".continuesWith("Lang", 4)</span>
which tests if a <span class="str">string</span> contains a substring at position <span class="var">n</span>.</p>
</div>
<div class="paragraph">
<p>We can use the <span class="func">join()</span> <span class="proc">proc</span> to join <span class="str">strings</span> in <span class="type">arrays</span> or sequences to single <span class="str">strings</span> with an optional glue string. <span class="func">Join()</span> works
also when the elements are not already <span class="str">strings</span>&#8201;&#8212;&#8201;in that case, the stringify operator is applied first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
var a = ["Nim", "Rust", "Julia"]
var s = a.join(", ")
echo s
echo s.split(", ").join("; ")
echo [1, 2, 3].join("; ")
# Nim, Rust, Julia
# Nim; Rust; Julia
# 1; 2; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The overloaded <span class="func">find()</span> functions accepts optional <span class="var">start</span> and <span class="var">end</span> positions and returns
the index position of the first match or <span class="lit">-1</span> when the search gave no result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strutils
var s = "Nim Language"
echo s.find('L') # 4
echo s.find({' ', 'a'}) # 3
echo s.find("age") # 9
echo s.find("Rust") # -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">contains()</span> function can be used to test if a character, a set of characters, or a substring
is contained in a <span class="str">string</span>. Instead of <span class="func">contains(s, sub)</span> we can write <span class="code">sub in s</span>. Note that a function variant for
single characters is defined in the <span class="mod">system</span> module.</p>
</div>
<div class="paragraph">
<p>The <span class="func">replace()</span> function can be used to replace all occurrences of a character or a substring
in a <span class="str">string</span> and to return the new <span class="str">string</span>. We can use <span class="func">replace()</span> with an empty replacement to delete a substring.
The also available <span class="func">delete()</span> function is used to delete a range specified by two indices in place.</p>
</div>
<div class="paragraph">
<p>Additionally, a <span class="func">replaceWord()</span> function exists, which does only replace whole words, i.e. words that
are surrounded by word boundary characters like spaces, tabulators or newlines.</p>
</div>
<div class="paragraph">
<p>The function <span class="func">multiReplace()</span> is a variant that can replace multiple substring/replacement pairs passed as <span class="type">tuples</span> in one pass.</p>
</div>
<div class="paragraph">
<p>The function <span class="func">strip()</span> can be used to remove multiple characters from a set at the start and the end of a <span class="str">string</span>. The default
character set is whitespace, and per default strip removes characters at both ends of the string. The function <span class="func">stripLineEnd()</span>
removes a single line end marker as \r, \n, \r\n, \f, \v from the end of the string, but only once.</p>
</div>
<div class="paragraph">
<p>Sometimes useful is the boolean function <span class="func">isEmptyOrWhitespace()</span> which checks if a string is empty or contains
only whitespace. Also useful can be the function <span class="func">repeat()</span> which returns a <span class="str">string</span> that contains the passed
character or the passed <span class="str">string</span> <span class="var">n</span> times, and the function <span class="func">spaces()</span> which returns a <span class="str">string</span> containing only <span class="var">n</span> spaces.</p>
</div>
<div class="paragraph">
<p>For single character tests we have functions like <span class="func">isDigit()</span>, <span class="func">isUpperAscii()</span>, <span class="func">isLowerAscii()</span>, <span class="func">isSpaceAscii</span>,
<span class="func">isAlphaNumeric()</span>.
Function <span class="func">isDigit()</span> test for characters '0'..'9', <span class="func">isUpperAscii()</span> for 'A'..'Z', <span class="func">islowerAscii()</span> for 'a'..'z', <span class="func">isSpaceAsccii()</span> for ASCII whitespace (' ', '\t')
and <span class="func">isAlphaNumeric()</span> test for lower or upper case ASCII letter or a decimal digit.</p>
</div>
<div class="paragraph">
<p>Function <span class="func">toLowerAscii()</span> convert all the characters 'A'..'Z' to lower case, and <span class="func">toUpperAscii()</span> converts all the characters
'a'..'z' to upper case. The function argument can be a <span class="str">string</span> or just a single character. With <span class="func">capitalizeAscii()</span> we can
convert the first ASCII character of a <span class="str">string</span> to upper case.</p>
</div>
<div class="paragraph">
<p>The overloaded functions <span class="func">count()</span> can be used to count the characters or substrings in a <span class="str">string</span>, and
<span class="func">countLines()</span> is available to count the number of lines, where lines are separated by CR, LF or CR-LF.</p>
</div>
<div class="paragraph">
<p>Sometimes we may also need functions like <span class="func">formatFloat()</span>, <span class="func">formatBiggestFloat()</span> or <span class="func">formatEng()</span> to
format <span class="type">float</span> numbers for output purposes. You would have to consult the <span class="mod">strutils</span> API docs
for all the format details. An <span class="func">intToStr()</span> function with an argument to specify the minimal <span class="type">string</span>
length is also available. The string may get leading zeros for alignment.</p>
</div>
<div class="paragraph">
<p>Finally, some important functions are the parsing functions like <span class="func">parseFloat()</span> or <span class="func">parseInt()</span> which converts
<span class="str">strings</span> to <span class="type">float</span> or integer numbers. Both raises an exception when the <span class="str">string</span> does not contain a valid number.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">strutils</span> module contains some more not that often used function, like functions to
convert data to hexadecimal, octal or binary representation, or to parse numbers back from that
string representation into numbers. Other functions like <span class="func">align()</span>, <span class="func">center()</span> and <span class="func">indent()</span> are available
for <span class="str">string</span> positioning. We will not try to describe these seldom used functions here, as it is hard
to remember the detailed behavior. You should skim the API docs and consult them
when you need one of the exotic functions or when you have forgotten how to use a concrete
function.<sup class="footnote">[<a id="_footnoteref_37" class="footnote" href="#_footnotedef_37" title="View footnote.">37</a>]</sup></p>
</div>
</div>
<div class="sect2">
<h3 id="_module_parseutils">Module parseutils</h3>
<div class="paragraph">
<p>The module <span class="mod">parseutils</span> provides a set of functions for
efficient and fast parsing of <span class="type">strings</span>. The functions avoid the allocation
of new <span class="type">strings</span> by passing back results in <span class="key">var</span> <span class="type">string</span> parameters and by
returning the number of processed characters. The module <span class="mod">parseutils</span> is a good choice
when we need efficient parsing of <span class="type">strings</span> and the input <span class="type">strings</span> have
a simple structure. For more complicated input data, we may have to use
RegEx or PEGs. Let us assume that we have a set of library names which
includes the version numbers, but we require the plain names. The function
<span class="func">parseWhile()</span> is a good candidate for this task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import parseutils
var libs = ["libdconf.so.1.0.0", "libnice.so.10.11.0", "libwebkit2gtk-5.0.so.0.0.0"]
var l = newStringOfCap(128)
for s in libs:
  echo s.parseUntil(l, {'.', '-'})
  echo l
  echo s.parseWhile(l, {'a'..'z'})
  echo l</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, we allocate a <span class="type">string</span> with enough capacity, so that the <span class="func">parse()</span> functions
can use it without having to do allocations. As we want to receive the plain names,
using <span class="func">parseWhile()</span> with a char set as last parameter may be a possible solution.
But as we see this will not really work for <span class="mod">webkit2gtk</span> which contains a digit in its
name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>8
libdconf
8
libdconf
7
libnice
7
libnice
13
libwebkit2gtk
9
libwebkit</pre>
</div>
</div>
<div class="paragraph">
<p>We can fix this by passing the extended char set {'a'..'z', '0'..'9'} to <span class="func">parseWhile()</span> or by use of <span class="func">parseUntil()</span>
with a character set that does not belong to a name.
Both functions return the number of processed characters and provide the captured string
in the passed var parameter. Note that we can use the slice operator .. to specify character ranges for the char set parameter when
the characters build a continues sequence in the ASCII table.</p>
</div>
<div class="paragraph">
<p>A related function is <span class="func">skipUntil()</span>, which we may use when we are more interested in
the version numbers after the name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">  let p = s.skipUntil({'.', '-'})
  echo s[p .. ^1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>All these functions accept an optional start parameter as last argument.
A common use case is to use an integer position variable initialized with zero,
which we increase by the returned value so that the parsing can continue
at the current position in the string. The next example will use this strategy.
For <span class="func">parseUntil()</span>
overloaded functions are available which gets not a char set but a single character or a substring
as parameter. These functions stop parsing when the character or the substring is found and return
that position.</p>
</div>
<div class="paragraph">
<p>Functions like <span class="func">parseInt()</span> and <span class="func">parseFloat()</span> can be used to extract numbers from strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import parseutils
var s = "In the year 2020 I gain 2.5 kg more fat."
var year: int
var value: float
var p = s.skipUntil({'0'..'9'})
p += parseUtils.parseInt(s, year, p)
p += s.skipUntil({'0'..'9'}, p)
p += parseUtils.parseFloat(s, value, p)
echo year, ": ", value # 2020: 2.5</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example we used the module prefix as <span class="mod">strutils</span> contains also a <span class="func">parseInt()</span> and a <span class="func">parseFloat()</span> function.
The functions <span class="func">parseBin()</span>, <span class="func">parseOct()</span> and parseHex() behave similarly. Returned is the number
of processed characters. We add the returned value to the start position so that parsing can continue
at the new position.</p>
</div>
<div class="paragraph">
<p>There are some more functions available in this module, which we will not discuss further. It is enough
that you know that this module exists and provides some efficient parsing functions. Whenever you
should really need one of these <span class="proc">procs</span> you would have to consult the API documentation for details.</p>
</div>
</div>
<div class="sect2">
<h3 id="_module_strscans">Module strscans</h3>
<div class="paragraph">
<p>The <span class="mod">strscans</span> module provides a <span class="func">scanf()</span> macro
which can be used to extract substrings from textual user input. The content of the substrings is automatically
converted to Nim variables of matching data types.</p>
</div>
<div class="paragraph">
<p>Processing of well-defined <span class="str">strings</span> is easy, and with user defined matcher functions even
text input with less strict shape can be processed.</p>
</div>
<div class="paragraph">
<p>Let us start with a simple example: We may have to create a program where the user should be able
to create rectangles by entering the coordinates of two opposite corners in the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Rect x1,y1,x2,y2</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/strscans

var x1, y1, x2, y2: float
var name: string

let input = "Rect 10.0,20.0,100,200"

if scanf(input, "$w $f,$f,$f,$f", name, x1, y1, x2, y2):
  echo name, ' ', x1, ' ', y1, ' ', x2, ' ', y2 # Rect 10.0 20.0 100.0 200.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter for the <span class="func">scanf()</span> macro is the user input <span class="str">string</span>, and the second
parameter is a pattern <span class="str">string</span> that specifies how the input <span class="str">string</span> should be processed. The following
parameters are variables that gets the results of the input evaluation.
The second parameter has some similarity with a regular expression. The letters
after the dollar sign specifies the data type of the substrings, $i or $f ask to process
an integer or a floating point number, and $w requests to process an ASCII identifier. Other
characters are captured verbatim, that is the space character after $w has to match a space
in the input <span class="str">string</span>, and the comma characters that separates the $f has to match commas
in the input string. The <span class="func">scanf()</span> macro supports capturing of some more data types, i.e. $c for an arbitrary character
or $s for optional white space. The optional white space is not captured, just ignored. With the use of $s
our program allows already a more flexible input string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">let input = "Rect10.0,    20.0,100,200"

if scanf(input, "$w$s$f,$s$f,$s$f,$s$f", name, x1, y1, x2, y2):
  echo name, ' ', x1, ' ', y1, ' ', x2, ' ', y2 # Rect 10.0 20.0 100.0 200.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>To allow processing even more flexible input strings,
it is possible to use user definable matchers in the form of Nim <span class="proc">procs</span>
with a well-defined parameter signature. There are two different types of matcher
<span class="proc">procs</span> supported&#8201;&#8212;&#8201;matchers to just skip a part of the input string, and capturing matchers.
For the next example we will use a <span class="proc">proc</span> which can skip various separators like comma, semicolon or
white space. And we will use a capturing matcher <span class="proc">proc</span> for the object name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/strscans

proc sep(input: string; start: int; seps: set[char] = {' ',',',';'}): int =
  while start + result &lt; input.len and input[start + result] in {' ','\t'}:
    inc(result)
  if start + result &lt; input.len and input[start + result] in {';',','}:
    inc(result)
  while start + result &lt; input.len and input[start + result] in {' ','\t'}:
    inc(result)

proc stt(input: string; strVal: var string; start: int; n: int): int =
  if input[start .. start + "Rect".high] == "Rect":
    strVal = "Rect"
    result = "Rect".len

var x1, y1, x2, y2: float
var name: string

let input = "Rect 10.0    ;20.0,100  ,  200"

if scanf(input, "${stt(0)}$s$f$[sep]$f$[sep]$f$[sep]$f", name, x1, y1, x2, y2):
  echo name, ' ', x1, ' ', y1, ' ', x2, ' ', y2 # Rect 10.0 20.0 100.0 200.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The use of our user definable matcher <span class="func">sep()</span> allows separating the four numbers
with a colon or a semicolon with arbitrary leading or trailing white space, or with
only white space. Multiple colons or semicolons between two numbers resulting
from a typo would be not permitted.</p>
</div>
<div class="paragraph">
<p>The signature for this matcher <span class="proc">proc</span> has this shape:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc sep(input: string; start: int; seps: set[char] = {' ',',',';'}): int =</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first parameter is the <span class="str">string</span> to process, and the second parameter is
the position at which the processing should start. (Or in other words, the second
parameter of integer type is the actual position in the input <span class="str">string</span>, that position
moves during the whole capering process from the start of the input <span class="str">string</span> to
its end. The end may not be reached if the capering fails at some point.)
The last parameter
has always the type <span class="type">set[char]</span> with a default value indication which
characters that <span class="proc">proc</span> can process. Actually a default value seems to be necessary, but the
actual value seems not to matter.
The <span class="proc">proc</span> returns the number of
characters that should be skipped. Zero is a valid return value, so
we can support optional separators. In most cases separators are
necessary to process the input <span class="str">string</span>, but we can imagine input
formats where separators are optional, e.g. when an integer number
is followed by a name. A name never starts with a digit, so the boundary
between the two values is well-defined. This none capturing matcher <span class="proc">proc</span> is called by use of
$[sep] in the pattern <span class="str">string</span>.</p>
</div>
<div class="paragraph">
<p>The signature of the capturing matcher <span class="proc">proc</span> has this shape:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc stt(input: string; strVal: var string; start: int; n: int): int =</code></pre>
</div>
</div>
<div class="paragraph">
<p>That <span class="proc">proc</span> also gets as parameters the input <span class="str">string</span> and the start position, and has to
return the number of processed characters. But additional, a <span class="key">var</span> parameter of arbitrary data type
is used to return the result of the capture, and the last parameter with arbitrary data type can
influence the capturing process. One possible use of the last parameter is to use an integer value
to limit the maximum number of characters to process. This <span class="proc">proc</span> is called in the pattern <span class="type">string</span>
by using curly braces like ${stt(0)}.</p>
</div>
<div class="paragraph">
<p><span class="func">Scanf()</span> returns true when all the parameters match, in that case all the passed in variables get
assigned a value. Currently, <span class="func">scanf()</span> does not support the capturing of optionally data, as the whole
processing stops when one capture fails, i.e. when $i is used to request the capture of an integer value,
but the input string does not contain decimal digits at the current capture position. In the
same way, the whole capturing process stops when a user defined capturing matcher returns zero
as no capturing is possible. So intermediate optional arguments are currently not supported.
When the processing stops due to missing arguments, <span class="func">scanf()</span> returns <span class="lit">false</span>, but the already processed captures
still have a valid value assigned. In this way, we can use at least optional trailing arguments.</p>
</div>
<div class="paragraph">
<p>As next example for the use of the <span class="func">scanf()</span> macro we will give a real world example: A simple CAD (Computer Aided Design) program
has a PCB (Printed Circuit Board) mode, in which the user can create new PCB pads by entering the pad data in a text entry widget.
A PCB pad is a rectangular shaped copper field which has an associated number and a name and maybe rounded corners.
The user should be able to enter two 2D coordinates, the corner radius, an optional x/y translation for the
next pad of the same size, followed by the number of pads to create and the pad number and name. That is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>pad x1 y1 x2 y2 r dx dy n num name</pre>
</div>
</div>
<div class="paragraph">
<p>The first five arguments are mandatory, the rest is optional with default values. The user should
be able to separate the arguments with white space or with a colon or a semicolon. Additionally,
the values <span class="var">x2</span> and  <span class="var">y2</span> can be preceded with a  <span class="plain">&#43;</span> character to indicate that the  <span class="var">x2</span>,  <span class="var">y2</span>
<span class="type">tuple</span> is not
an absolute coordinate value but the width and high of the pad.</p>
</div>
<div class="paragraph">
<p>A program fragment to process this form of user input may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/strscans

proc jecho(x: varargs[string, `$`]) =
  for el in x:
    stdout.write(el &amp; " ")
  stdout.write('\n')
  stdout.flushfile

proc stt(input: string; strVal: var string; start: int; n: int): int =
  if input[start .. start + "pad".high] == "pad":
    strVal = "pad"
    result = "pad".len

proc pls(input: string; plusVal: var int; start: int; n: int): int =
  if input[start] == '+':
    plusVal = 1 # bool
    result = 1

proc sep(input: string; start: int; seps: set[char] = {' ',',',';'}): int =
  while start + result &lt; input.len and input[start + result] in {' ','\t'}:
    inc(result)
  if start + result &lt; input.len and input[start + result] in {';',','}:
    inc(result)
  while start + result &lt; input.len and input[start + result] in {' ','\t'}:
    inc(result)

proc plus(input: string; plusVal: var int; start: int; n: int): int =
  result = sep(input, start)
  if input[start + result] == '+':
    plusVal = 1 # bool
    result += 1

var st: string
var x1, y1, x2, y2, dx, dy: float
var px2, py2: int # bool
var n: int
var number, name: string

(st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name) = ("pad", NaN, NaN, 0, NaN, 0, NaN, NaN, NaN, 0, "", "") # defaults

var res: bool
var input = "pad 10.0, 10   12 +12.0 ;20 0 8 Num Name"

# unfortunately the input start with "pad" is needed for unpatched strscan!

# using the pls matcher, this fails when there is no '+'
res = scanf(input, "${stt(0)}$[sep]$f$[sep]$f$[sep]${pls(0)}$f$[sep]${pls(0)}$f$[sep]$f$[sep]$f$[sep]$i$[sep]$w$[sep]$w", st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name)
jecho(res, st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name)

# using the plus matcher, so the '+' is optional
res = scanf(input, "${stt(0)}$[sep]$f$[sep]$f${plus(0)}$f${plus(0)}$f$[sep]$f$[sep]$f$[sep]$i$[sep]$w$[sep]$w", st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name)
jecho(res, st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name)

input = "pad 10.0, 10   12 +12.0" # test with missing optional values
(st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name) = ("pad", NaN, NaN, 0, NaN, 0, NaN, NaN, NaN, 0, "", "") # defaults
# using the plus matcher, so the '+' is optional
res = scanf(input, "${stt(0)}$[sep]$f$[sep]$f${plus(0)}$f${plus(0)}$f$[sep]$f$[sep]$f$[sep]$i$[sep]$w$[sep]$w", st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name)
jecho(res, st, x1, y1, px2, x2, py2, y2, dx, dy, n, number, name)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run this program, we get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>false pad 10.0 10.0 0 nan 0 nan nan nan 0
true pad 10.0 10.0 0 12.0 1 12.0 20.0 0.0 8 Num Name
false pad 10.0 10.0 0 12.0 1 12.0 nan nan 0</pre>
</div>
</div>
<div class="paragraph">
<p>The first  <span class="func">scanf()</span> call uses the sequence $[sep]${pls(0)} which fails when the  <span class="type">float</span> value has no leading  <span class="plain">&#43;</span> sign, so this call
is of no real use. The second and third  <span id="scanf()# call uses instead a ${plus(0)} call" class="func">plus()</span> <span class="proc">proc</span> processes
the separators as well as the optional  <span class="plain">&#43;</span> character, so that <span class="proc">proc</span> has never to return zero, and the capturing process continues.
For the last  <span class="func">scanf()</span> call we give as input only five values, so  <span class="func">scanf()</span> returns false, but the first five values gets assigned values, and the
rest has default values. One restriction of above code is, that we have always to start the input string with  <span class="lit">pad</span>, otherwise
the processing stops immediately. As  <span class="func">scanf()</span> does not support the capture of boolean values, we use the integer data type
for the variables  <span class="var">px2</span> and  <span class="var">py2</span>. The value zero means that there is no  <span class="plain">&#43;</span> prefix, and  <span class="lit">1</span> indicates that there is a plus prefix.<sup class="footnote">[<a id="_footnoteref_38" class="footnote" href="#_footnotedef_38" title="View footnote.">38</a>]</sup></p>
</div>
<div class="paragraph">
<p>The next tiny example shows how we can use the last parameter of the user defined matcher <span class="proc">proc</span> to
control the matching process:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strscans

proc ndigits(input: string; intVal: var int; start: int; n: int): int =
  var i, x: int
  while i &lt; n and i + start &lt; input.len and input[i + start] in {'0'..'9'}:
    x = x * 10 + input[i + start].ord - '0'.ord
    inc(i)
  # only overwrite if we had a match
  if i == n:
    result = n
    intVal = x

var input = "1234"
var a, b: int

if scanf(input, "${ndigits(2)}$s${ndigits(2)}$.", a, b):
  echo "Input is OK:", a, " ", b</code></pre>
</div>
</div>
<div class="paragraph">
<p>We want to capture two integer values, each with one or two decimal digits.
By passing the upper limit of digits to the <span class="func">ndigits()</span> <span class="proc">proc</span>, we get the intended result
even when the user does not separate the two numbers with white space. Additionally,
we have used $. at the end of the pattern string. The $. matches only when the end of the input
string is reached, so that <span class="func">scanf()</span> would return false if there are more characters in
the input <span class="str">string</span> left.</p>
</div>
<div class="paragraph">
<p>The latest version of the <span class="mod">strscans</span> module provides also a variant of the <span class="func">scanf()</span> macro
called <span class="func">scanTuple()</span> which returns a <span class="type">tuple</span>. We could use it in this way in our example above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">let (res, a, b) = scanTuple(input, "${ndigits(2)}$s${ndigits(2)}$.", int, int)
echo res, " ", a, " ", b</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we have not to declare the capering variables in advance. The final result of the
scan process is returned in an additional boolean variable. When we use user defined matchers
as above, we have to specify the data types of the returned values as additional parameters
after the pattern string.</p>
</div>
<div class="paragraph">
<p>Additionally, the <span class="mod">strscans</span> module provides a <span class="func">scanp()</span> macro which works somewhat similar to
PEG or RegEx libraries. We will not try to explain the <span class="func">scanp()</span> macro, as its use may be too
difficult for a beginner book. And when we really have to process text <span class="str">strings</span> with
regular expression grammars, then we can use the available RegEx or PEG modules,
which have no restrictions and work for Nim in a similar way as for other programming languages.
We will introduce the Nim RegEx and PEG modules later in the book&#8201;&#8212;&#8201;maybe we will compare
the scanp() macro there.</p>
</div>
</div>
<div class="sect2">
<h3 id="_module_strformat">Module strformat</h3>
<div class="paragraph">
<p>With the <span class="func">fmt()</span> macro from the <span class="mod">strformat</span> module, we can format and interpolate <span class="str">strings</span> similar to Python3 with its f-strings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strformat
from strutils import `%`
var lang = "C"
var year = 1972
stdout.write "The programming language ", $lang, " was created in ", $year, ".\n"
echo "The programming language " &amp; $lang &amp; " was created in " &amp; $year, "."
echo "The programming language $# was created in $#." % [$lang, $year]
echo fmt"The programming language {lang} was created in {year}."
# The programming language C was created in 1972.</code></pre>
</div>
</div>
<div class="paragraph">
<p>From the four ways to print some text, the last one with <span class="func">fmt()</span> is the shortest and perhaps the cleanest.
As <span class="func">fmt()</span> is a macro which is processed at compile time, there is no unnecessary run-time
overhead involved. A small restriction of <span class="func">fmt()</span> is, that it&#8217;s argument is regarded as
a generalized raw <span class="str">string</span> literal. So we can not use escape sequences like <span class="lit">"\n"</span> in the <span class="str">string</span> literal.
But the <span class="mod">strformat</span> API docs mention various solutions for this: We can use the unary <span class="op">&amp;</span> operator instead of the <span class="func">fmt()</span> call,
or we can use the notations <span class="lit">{'\n'}</span>, <span class="func">fmt()</span> or <span class="func">"".fmt</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strformat
var lang = "Fortran"
var year = 1957
stdout.write &amp;"The programming language {lang} was created in {year}.\n"
stdout.write fmt"The programming language {lang} was created in {year}.{'\n'}"
stdout.write fmt("The programming language {lang} was created in {year}.\n")
stdout.write "The programming language {lang} was created in {year}.\n".fmt
# The programming language Fortran was created in 1957.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">fmt()</span> macro works also with multi-line raw <span class="type">strings</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strformat
echo fmt"""This is a {1 + 1 + 1} lines
multiline
string."""</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">fmt()</span> macro accept a few directives for the formatting of integer and floating point numbers like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strformat
var pi = 3.1415
var people = 123
echo fmt"The number{pi:&gt;8.2f} is called PI by {people:&gt;8} people."</code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic pattern is, that the numeric variable is followed by a colon
and the total number of desired characters. We can precede the number with a
&lt; or &gt; to indicate left or right alignment, and for floating point numbers
we can use a notation similar as used for printf() in the C language:
n.mf stands for a <span class="type">float</span> formatted with <span class="var">n</span> characters total and <span class="var">m</span> decimal places.
As in C we can use <span class="lit">e</span> instead of <span class="lit">f</span> to indicate scientific notation. If the value which specifies
the total number of characters starts with a zero digit, then the formatted
number uses zeros instead of spaces for leading digits. And <span class="lit">X</span> after the colon
generates hexadecimal value for integer numbers.</p>
</div>
<div class="paragraph">
<p>A useful property of the <span class="func">fmt()</span> macro is, that we can put an equal sign into the curly braces
to get the initial expression both as <span class="str">string</span> and as interpolated value, as in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strformat
var pi = 3.1415
echo fmt"{2 * pi = }" # 2 * pi = 6.283</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is similar to the <span class="func">dump()</span> macro from the <span class="mod">sugar</span> module and is mostly used for debugging purposes.</p>
</div>
<div class="paragraph">
<p>To use curly braces as literals in a <span class="func">fmt()</span> argument we can use character literals with a backslash
as we did to include a newline character, or we can use an extended <span class="func">fmt()</span> macro with two additional
arguments which specifies the two characters that should be used instead of {} to mark the
expression which should be interpolated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import strformat
echo fmt"{2} curly braces {'\{'} {'\}'}." # 2 curly braces { }.
echo "three time three is &lt;3 * 3&gt;".fmt('&lt;', '&gt;') # three time three is 9</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will
not try to explain all these various formatting options in detail, as it is
really hard to remember. It is enough that you know that these options exists, so
you can consult the API docs for details when you would need it.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/strutils.html" class="bare">https://nim-lang.org/docs/strutils.html</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/parseutils.html" class="bare">https://nim-lang.org/docs/parseutils.html</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/strscans.html" class="bare">https://nim-lang.org/docs/strscans.html</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/strformat.html" class="bare">https://nim-lang.org/docs/strformat.html</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Regular_expression" class="bare">https://en.wikipedia.org/wiki/Regular_expression</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" class="bare">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" class="bare">https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_arrays_and_sequences_2">Arrays and Sequences</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Together with <span class="str">strings</span>, <span class="type">arrays</span> and sequences are the most important built-in containers for the Nim language.
While <span class="type">arrays</span> have a fixed size defined already at compile time, sequences are like <span class="str">strings</span> of dynamic size and
can grow when we append more elements. As <span class="type">arrays</span> have fixed size they can be allocated on the stack, while
due to the dynamic size of sequences the actual data buffer has to be allocated on the heap. We explained some details
about sequences already in part II of the book. One important aspect was that sequences use a continues data
buffer with a fixed capacity to store the actual elements. When that data buffer is fully occupied, and we try to
add more elements, then a new larger buffer is allocated on the heap and the contained elements have
to been copied from the old to the new larger buffer before the old buffer can be deallocated.</p>
</div>
<div class="paragraph">
<p>When we pass <span class="type">arrays</span> or sequences to <span class="proc">procs</span>, then we can use the special data type <span class="type">openArray</span> when we define the <span class="proc">proc</span> to
allow passing both arrays and sequences. Note that this is very different from generic <span class="proc">procs</span>: When we define
a generic <span class="proc">proc</span>, then the compiler creates a new <span class="proc">proc</span> instance for each of the generic data type that we use, so when we
call a generic <span class="proc">proc</span> which accepts floats and signed and unsigned integers, and we call it a few times
with <span class="type">float</span> and with signed integer arguments, then the compiler has to create two distinct instances of the
proc. For <span class="type">openArray</span> parameters all the time only one <span class="proc">proc</span> instance is necessary as sequences behave like <span class="type">arrays</span>
in many ways. Both use a continues block of memory where the elements are stored, and the position of an
entry is given by the start address of this memory block and an offset given by the index multiplied with the size
of an <span class="type">array</span> element. So when passing the actual parameter to the <span class="proc">proc</span>, the compiler passes the <span class="type">array</span> and the data
section of the sequence in the same manner. Both can be passed by copy or by address. The compiler passes
also the actual size, the lower index is always zero for <span class="type">openArrays</span>. Of course, when we pass a <span class="type">seq</span> as <span class="type">openArray</span>,
there are some restrictions, e.g. we could not add elements in the <span class="proc">proc</span> as the passed variable behaves like an array.</p>
</div>
<div class="paragraph">
<p>Memory layout of sequences and <span class="str">strings</span> is very similar, both have length, capacity and a data buffer on the heap,
and some <span class="proc">procs</span> that work on the data structure have the same names as <span class="func">add()</span>, <span class="func">len()</span> and <span class="func">setlen()</span> and both support
operators like <span class="op">[]</span>, <span class="op">&amp;</span> and <span class="op">..</span> for access to single elements, and for concatenation and slicing.</p>
</div>
<div class="paragraph">
<p>Some often used functions and operators for sequences and <span class="type">arrays</span> are defined in the <span class="mod">system</span> module, like creating
new sequences, converting <span class="type">arrays</span> to sequences, joining sequences or adding elements to it.
Other important functions, operators and iterators are defined in the <span class="mod">sequtils</span> module, which we
describe in the next section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s0: seq[int]
var s1: seq[int] = newSeqOfCap[int](2)
var s2: seq[int] = newSeq[int](2)

s0.add(3)
s0.add(5)
s1.add(3)
s1.add(5)
s2[0] = 3
s2[1] = 5
echo s0; echo s1; echo s2 # @[3, 5] for each</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can initialize sequences by a call of <span class="func">newSeq()</span>, <span class="func">newSeqOfCap()</span> or not at all.
When we use <span class="func">newSeq(n)</span> we get a <span class="type">seq</span> with <span class="var">n</span> elements initialized to binary zero each, and
we then can just overwrite the elements by use of the subscript operator <span class="op">[]</span>
which is faster than appending elements with <span class="func">add()</span> to an empty <span class="type">seq</span>.
With <span class="func">newSeqOfCap()</span> we can allocate a <span class="type">seq</span> of size zero but with a buffer size
of that specified capacity. We can append elements by calling the <span class="func">add()</span>
function, and as long we append not more elements as specified in the
<span class="func">newSeqOfCap()</span> call we can avoid reallocations of the internal <span class="type">seq</span> buffer. When performance
in not that critical, we can just use an uninitialized <span class="type">seq</span> and <span class="func">add()</span> elements&#8201;&#8212;&#8201;when the default capacity is exhausted, a reallocation occurs, generally with
doubled data buffer size.</p>
</div>
<div class="paragraph">
<p>We can use the overloaded <span class="func">add()</span> <span class="proc">proc</span> to append single elements or to append
a whole array to a <span class="type">seq</span>, and the <span class="op">&amp;</span> operator is available to join two sequences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">s0.add([7, 9])
s0 &amp;= s1
s1 = s0 &amp; s2
echo s1 # @[3, 5, 7, 9, 3, 5, 3, 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use <span class="func">len()</span> to query the length of a <span class="type">seq</span> and <span class="func">setLen()</span> to set a new length.
In most cases <span class="func">setLen(n)</span> is used to shorten a <span class="type">seq</span>, that is, to keep the first <span class="var">n</span>
elements, but we can also use <span class="func">setLen()</span> to increase the length of a <span class="type">seq</span>. In that
case, the new entries get the value binary zero as default, and we can use the subscript
operator <span class="op">[]</span> to fill in actual content. Increasing the length with <span class="func">setLen()</span> may cause
a reallocation if the current capacity is not sufficient. Functions <span class="func">low()</span> and <span class="func">high()</span> are
available to get the lowest and the highest index position of an <span class="type">array</span> or a <span class="type">seq</span>.
As arrays can have negative indices, <span class="func">low()</span> can be less than zero for <span class="type">arrays</span>, but for
sequences and <span class="type">openArray</span> <span class="proc">proc</span> parameters <span class="func">low()</span> is always zero.</p>
</div>
<div class="paragraph">
<p>Module <span class="mod">system</span> provides also the <span class="op">@</span> <span class="type">array</span> to <span class="type">seq</span> operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i = 7
var j = 9
var s0 = @[1, 2]
s0 = s0 &amp; @[i, j] # don't use this variant!
s0.add([i, j]) # faster
echo s0 # @[1, 2, 7, 9, 7, 9]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the code in line 4 would be really slow, as that would have to allocate a temporary <span class="type">seq</span>.
Using <span class="func">add()</span> to add a temporary array to the seq should be faster.</p>
</div>
<div class="paragraph">
<p>Slicing is also supported by the <span class="mod">system</span> module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var s0 = @[1, 3, 5]
var s1 = s0[1 .. 2] # @[3, 5]
for el in s0[1 .. 2]: # may create a copy of the seq
  echo el</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that line three may create a temporary copy of the sequence,
which may be not that nice for optimal performance. We discussed that
topic already in part II of the book, Nim 2.0 may improve the situation further by
introducing views which create no copies. Beside the <span class="op">s[a .. b]</span> slice operator which includes
the elements at position <span class="var">a</span> and <span class="var">b</span>, there is <span class="op">s[a ..&lt; b]</span> which does not include position <span class="var">b</span> and <span class="op">s[a .. ^b]</span>
where position <span class="var">b</span> is taken from the end of the <span class="type">seq</span> or <span class="type">array</span>, e.g. <span class="lit">^1</span> is the last position, <span class="lit">^2</span> the second last.</p>
</div>
<div class="paragraph">
<p>For deleting elements from a sequence, we have <span class="func">del()</span> which replaces the element at the specified position with the
last element of the <span class="type">seq</span> and reduces the <span class="type">seq</span> length by one, and the <span class="func">delete()</span> function which shifts all elements after
the specified position one step forward. Obviously, the latter is slower, but it preserves the order of elements.
The function <span class="func">pop()</span> deletes and returns the last item of a <span class="type">seq</span>. For using <span class="func">pop()</span> on an empty seq, we may
expect a raised exception. With insert, we can insert an item at the specified position by moving all the elements
after this position upwards.
Note that <span class="func">del()</span>, <span class="func">delete()</span>, <span class="func">pop()</span> and <span class="func">insert()</span> are not available for <span class="type">arrays</span>.</p>
</div>
<div class="paragraph">
<p>Comparison of two <span class="type">arrays</span> or sequences by the <span class="op">==</span> operator returns <span class="lit">true</span> when the length as well as all
contained items matches.</p>
</div>
<div class="paragraph">
<p>With the function <span class="func">contains()</span> we can test if an item is contained in a <span class="type">seq</span> or an <span class="type">array</span>. We can also use the operators
<span class="code">a in b</span> and <span class="code">a notin b</span> instead. The elements are tested from the start of the container until a match is found
or the last position in the container is reached, so this is a O(n) operation.</p>
</div>
<div class="sect2">
<h3 id="_module_sequtils">Module sequtils</h3>
<div class="paragraph">
<p>This module defines some useful <span class="proc">procs</span>, iterators and templates for working with <span class="type">arrays</span> and sequences.
Some functions of module <span class="mod">sequtils</span> use a generic <span class="type">openArray</span> parameter and so can be used for <span class="str">strings</span> as well.
While the <span class="func">max()</span> and <span class="func">min()</span> <span class="proc">procs</span> are available from the <span class="mod">system</span> module, the <span class="func">minIndex()</span> and <span class="func">maxIndex()</span>
<span class="proc">procs</span> are provided by <span class="type">sequtils</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
var s = @[7, 3, 5]
echo s.min, " ", s.max # 3 7
echo s.minIndex, " ", s.maxIndex # 1 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sometimes we may need a <span class="func">minmax()</span> <span class="proc">proc</span> which gives us both values, but that one is currently not available.
We have to create it our self if needed, when performance is not that critical we can call <span class="func">min()</span> and <span class="func">max()</span>
separately.<sup class="footnote">[<a id="_footnoteref_39" class="footnote" href="#_footnotedef_39" title="View footnote.">39</a>]</sup></p>
</div>
<div class="paragraph">
<p>The functions <span class="func">minIndex()</span> and <span class="func">maxIndex()</span> as well as <span class="func">count()</span> or <span class="func">deduplicate()</span> can work with strings also:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
var s = @[3, 5, 1, 7, 3, 3, 5]
echo s.count(5) # 2
echo s.deduplicate # @[3, 5, 1, 7]
echo "abc".maxIndex() #2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function name <span class="func">deduplicate()</span> may be irritating, as the function does not work in place,
we may expect the name deduplicated() as for <span class="func">sort()</span> and <span class="func">sorted()</span>. Other programming languages
use the name <span class="func">uniq()</span> instead. Deduplication is easy when the elements are sorted, as for that case
we can just iterate over the seq and ignore equal adjacent items. That is why <span class="func">deduplicate()</span> accepts
an optional boolean parameter indicating if the <span class="type">seq</span> is sorted. If the <span class="type">seq</span> is not sorted, it may be necessary
to create a temporary set to store the already seen items so that they can be ignored the next time
when they occur again in the seq.</p>
</div>
<div class="paragraph">
<p>The function <span class="func">concat()</span> can join multiple sequences (yes only sequences, it does not work with <span class="type">arrays</span> currently),
maybe that is more efficient than using the <span class="op">&amp;</span> operator.
And <span class="func">insert()</span> can insert a new value at a position by shifting following items, and <span class="func">delete()</span>
allows removing a range of items from the <span class="type">seq</span> when we specify two index positions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
var s: seq[int]
s = concat(@[1, 2], @[3, 4], @[5, 6])
echo s # @[1, 2, 3, 4, 5, 6]
echo @[1, 2] &amp; @[3, 4] &amp; @[5, 6] # @[1, 2, 3, 4, 5, 6]
s.insert(7, 2)
s.delete(3, s.high)
echo s # @[1, 2, 7]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Proc <span class="func">repeat()</span> is used to create a <span class="type">seq</span> which contains a single value multiple times, and <span class="func">cycle()</span>
repeats the items of an existing <span class="type">seq</span> multiple times:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
echo 2.repeat(4) # @[2, 2, 2, 2]
echo @[1, 2].cycle(3) # @[1, 2, 1, 2, 1, 2]</code></pre>
</div>
</div>
<div class="paragraph">
<p>A bit more complicated but really useful are functions like <span class="func">map()</span>, <span class="func">filter()</span>, <span class="func">keep()</span> and the corresponding <span class="func">&#8230;&#8203;It()</span> templates:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils, sugar
var s = (0 .. 9).toSeq
echo s.map(proc(x: int): int = x * x) # always @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
echo s.map(x =&gt; x * x) # from sugar module
echo s.mapIt(it * it)

echo s.mapIt("*" &amp; $it &amp; "*") # @["*0*", "*1*", "*2*", "*3*", "*4*", "*5*", "*6*", "*7*", "*8*", "*9*"]

echo s.filter(proc(x: int): bool = (x and 1) == 0) # both @[0, 2, 4, 6, 8]
echo s.filterIt((it and 1) == 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The map variants return a new <span class="type">seq</span>, with an operation performed on all items.
The returned <span class="type">seq</span> can have a different base type. In line 4 we used the <span class="op">&#8658;</span> operator from
the <span class="mod">sugar</span> module for a simpler notation</p>
</div>
<div class="paragraph">
<p>The <span class="func">filter()</span> variants apply a <span class="proc">proc</span> with boolean result type on the <span class="type">seq</span> items and
return the items for which the result is true. Remembering if the elements for
which the <span class="proc">procs</span> gives a <span class="lit">true</span> result are returned or removed from the initial
<span class="type">seq</span> may be not easy. It helps to remember that <span class="func">filter()</span> behaves like the <span class="func">keepIf()</span> <span class="proc">procs</span>&#8201;&#8212;&#8201;items with positive result survive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils, sugar
var s = (0 .. 9).toSeq
var s1 = s
s1.apply(x =&gt; x * x) # @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
s1 = s
s1.keepIf(proc(x: int): bool = (x and 1) == 0) # @[0, 2, 4, 6, 8]</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above code, we used <span class="func">toSeq()</span> with a slice argument to create
an initial sequence with continues integers from the slice.
The <span class="func">apply()</span> function performs a transformation operation on all the items,
and <span class="func">keepIf()</span> preserve only the items for which a boolean predicate evaluates to <span class="lit">true</span>.</p>
</div>
<div class="paragraph">
<p>Two useful predicate functions are <span class="func">any()</span> and <span class="func">all()</span> to check if at least one item fulfills
a condition or if all items fulfill a condition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
var s = (0 .. 9).toSeq
echo s.all(proc(x: int): bool = x &lt; 10) # true
echo s.any(proc(x: int): bool = x * x == 25) # true</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <span class="func">zip()</span> we can join the items of two sequences to tuples, and with <span class="func">unzip()</span> we
can separate the tuple items again in two separate sequences:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
var s = (0 .. 9).toSeq
var s1 = s.mapIt(it * it)
var z = zip(s, s1)
echo z
echo z.unzip
# @[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25), (6, 36), (7, 49), (8, 64), (9, 81)]
# (@[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], @[0, 1, 4, 9, 16, 25, 36, 49, 64, 81])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, sometimes the templates <span class="func">foldl()</span> and <span class="func">foldr()</span> can be useful for folding a sequence, that
is to generate one final value from all the items. The fold templates use the variables <span class="var">a</span> and <span class="var">b</span>
to generate the result, a &#43; b would sum all the items. <span class="func">Foldl()</span> performs the operation
from left to right, returning the accumulation and accepts an optional start value, while
<span class="func">foldr()</span> starts from right, i.e. with the item at the end of the <span class="type">seq</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils
var s = (0 .. 9).toSeq
echo s.foldl(a + b, 100) # 145
echo s.foldr(a + b) #45</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="mod">sequtils</span> module contains some more <span class="proc">procs</span>, templates and macros that are not needed that often.
It would not make much sense to mention all of them here, as it is already not easy to remember
the ones that we have introduced above. You should skim the <span class="type">sequtils</span> API docs from time to time
to remember what is available.</p>
</div>
<div class="paragraph">
<p>Maybe you have missed the difference of two sequences, which some other programming languages
provide:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">[1, 2, 3, 4, 1, 5] - [2, 4] # [1, 3, 5]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Well that is an expensive operation, O(n^2) if implemented in a naive way, as it may iterate for all
items in the second <span class="type">seq</span> over the whole first <span class="type">seq</span> to remove the unwanted items.
A better approach is to convert the items in the second <span class="type">seq</span> to a temporary (hash) <span class="type">set</span> to allow faster query:</p>
</div>
<div class="paragraph">
<p>A fast on the fly solution is this, as suggested by someone in the Nim forum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils, sets, sugar
let a = [1, 2, 5, 2, 9, 7, 0]
let b = [7, 4, 1, 10, 7]
let bSet = b.toHashSet()
echo a.filter((x) =&gt; x notin bSet) # @[2, 5, 2, 9, 0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we should need this operation frequently, we may define our own <span class="proc">proc</span> like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># https://ruby-doc.org/core-2.6/Array.html#method-i-2D
# Array Difference
import sets

proc `-`*[T](a, b: openArray[T]): seq[T] =
  let s = b.toHashSet
  result = newSeq[T](a.len)
  var i = 0
  for el in a:
    if el notin s:
      result[i] = el
      inc(i)
  result.setLen(i)

proc `-=`*[T](a: var seq[T]; b: openArray[T]) =
  let s = b.toHashSet
  var i = 0
  var j = 0
  while i &lt; a.len:
    if a[i] notin s:
      a[j] = a[i]
      inc(j)
    inc(i)
  a.setLen(a.len - (i - j))

proc main =
  let a = [1, 2, 5, 2, 9, 7, 0]
  let b = [7, 4, 1, 10, 7]
  echo a - b
  echo b - a

  var x = @a
  x -= b
  echo x

main()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>@[2, 5, 2, 9, 0]
@[4, 10]
@[2, 5, 2, 9, 0]</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this preserves the order in the first <span class="type">seq</span>, which is often requested. If order is not
critical, then we could convert both sequences to a <span class="type">set</span> and build the <span class="type">set</span> difference&#8201;&#8212;&#8201;but when order does not matter, we may use sets instead of sequences from the beginning.</p>
</div>
<div class="paragraph">
<p>Perhaps you missed also a <span class="func">shift()</span> function which other container types or programming languages may provide, that is
used similar to <span class="func">pop()</span>, but deletes and returns the first item of a <span class="type">seq</span>? Well, it should be obvious why a
<span class="func">shift()</span> is not provided by default and why such a function would generally be avoided&#8201;&#8212;&#8201;the function
name gives you already a good hint. And if you should need such a function, it should be no problem
to implement one if efficiency is really not critical. But possibly in that case it would be better to
use a different container type, maybe the double-ended queue provided by the <span class="mod">deques</span> module.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/sequtils.html" class="bare">https://nim-lang.org/docs/sequtils.html</a></p>
</li>
<li>
<p><a href="https://forum.nim-lang.org/t/7753#49189" class="bare">https://forum.nim-lang.org/t/7753#49189</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_random_numbers">Random Numbers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Most computer programs work fully deterministic, that is, one input data set
generates exactly one well-defined output data set. This behavior is not
desired when we create games or simulations: The actions of computer controlled characters
should not do exactly the same again and again when we restart the game, and perhaps
the computer generated landscape in the game should look different when we restart the game too.</p>
</div>
<div class="paragraph">
<p>To generate such an unpredictable behavior, we use random number generators, which can generate
sequences of random number of integer or <span class="type">float</span> type. The most significant property of true random numbers is
that we can not predict the next one from the sequence of all values seen before. Random number sources have no memory!
Children often think they have. If a child got value six in a dice game three times in sequence, it typically assumes that it is extremely
unlikely that the next roll will give again the value 6. But as the dice has no memory, the chance to get a specific number is always
1/6, as we have 6 possible values all with same probability. At least when the dice is not manipulated.
Another significant property of random numbers is the distribution of the possible values. For most random
number sources, we would expect a uniform distribution of all possible values: For a dice with numbers 1 .. 6 we
would expect that we get all these numbers with nearly the same total quantity when we roll the dice for a long time again and again.
But of course, not all random quantities are distributes uniformly. The distribution can have different shapes. An important non-uniform
distribution is the Gauss distribution, where the final result depends on many random decisions. So an average value
is more likely than extreme values. You may know the marble nail board with multiple slots as an example: Marbles are thrown in at the
top, and whenever they hit a nail, they get distracted to the left or right.</p>
</div>
<div class="paragraph">
<p>To build a perfect random generator we would have to use some physical noise sources like photons emitted by a thermal light source
falling on a light detector with single photon resolution (Photo-multiplier), radioactive decay, thermal noise or similar physical entropy sources. But using real physically
sources for random numbers is difficult and the random number generation is slow. So in computer programming
we generally use so called pseudo-random-numbers, which are sequences of numbers calculated based on a given starting
number. A mathematical function gets the last n numbers seen before and generates the next one from that. If that function uses a
smart mathematical expression, its results looks really like random numbers. For games the generated sequences are typically good enough,
for cryptographic applications they may be not good enough. So what we need for a random number generator is
a sequence of start numbers, and a mathematical function with internal state. For each call of that
function, a new random number is returned and the internal stage is changed so that the next call
will result in a different number. When we always use the same sequence of starting numbers, then
our generator would always generate the same sequence of random numbers. Sometimes this is desired, e.g. when we want
a behavior that looks random, but is reproducible, maybe for debugging tasks. But in most cases, we would use
starting numbers that are different for each program start. To get well suited start numbers we can just use the current
time with nanosecond resolution which most computer hardware do provide.</p>
</div>
<div class="paragraph">
<p>Most simple and fast random number generators use for its internal state two integer numbers. From these
two numbers the next random value is calculated and then the numbers representing the
internal state are modified also, to ensure that the next generated number is again different.</p>
</div>
<div class="paragraph">
<p>Nim uses in its <span class="mod">random</span> module an implementation of the xoroshiro128&#43; (xor/rotate/shift/rotate) library.
A <span class="type">Rand</span> object with two integer fields is used to store the actual state, and some simple and fast
logic operations as bit shift, logical xor and addition is used to update state and to generate the
next number:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
when defined(js):
  type Ui = uint32
  const randMax = 4_294_967_295u32
else:
  type Ui = uint64

  Rand* = object # State of a random number generator.
    a0, a1: Ui

proc rotl(x, k: Ui): Ui =
  result = (x shl k) or (x shr (Ui(64) - k))

proc next*(r: var Rand): uint64 =
  let s0 = r.a0
  var s1 = r.a1
  result = s0 + s1
  s1 = s1 xor s0
  r.a0 = rotl(s0, 55) xor s1 xor (s1 shl 14) # a, b
  r.a1 = rotl(s1, 36) # c</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="type">Rand</span> object stores the internal state, <span class="func">rotl()</span> is a helper function which
updates the state for each call, and <span class="func">next()</span> is the actual generator procedure
returning an <span class="type">uint64</span> value. Note that the addition used in <span class="func">next()</span> does
wrap around instead of giving an overflow error as unsigned integers
are used. The numbers returned by the <span class="func">rand()</span> <span class="proc">proc</span> are the foundation for
all the other random number types provided by the <span class="mod">random</span> module.
To get integers with reduced numeric range, we can just use the modulo
operation, and to get <span class="type">float</span> results we may convert the integer value to float and apply
some basic mathematical operations like division for range reduction.</p>
</div>
<div class="paragraph">
<p>The most basic functions provided by the <span class="mod">random</span> module are the overloaded <span class="func">rand()</span>
functions. <span class="func">Rand()</span> called with an integer parameter <span class="var">n</span> gives us integer random numbers in the
range from <span class="lit">0</span> up to <span class="var">n</span>, and <span class="func">rand()</span> called with a <span class="type">float</span> parameter <span class="var">x</span> will give us
random <span class="type">float</span> numbers in the range <span class="var">0 .. x</span>. When we just use the rand() functions in this way,
we would get the same sequence of numbers for each run of our program, as the generator
always starts with the same well-defined initial state. We can call
the <span class="proc">proc</span> <span class="func">randomize()</span> before calling <span class="func">rand()</span> to initialize the generator to a different
state based on the current time. Then <span class="func">rand()</span> will provide us with different
number sequences for each start of our program.</p>
</div>
<div class="paragraph">
<p>Generally, it is a good idea to not use the one internal global state of the <span class="mod">random</span> module
for generation of our random number, but to use our own state variable. That way we
prevent conflicts with other modules which may use the <span class="mod">random</span> module as well. Imagine that
we want to get the same sequence of random numbers for each run of our program
as we are debugging our game, but another module initialize the internal state
of module <span class="mod">random</span> with a value based on the current time.</p>
</div>
<div class="paragraph">
<p>So the module <span class="mod">random</span> provides overloaded <span class="func">rand()</span> functions that gets a state variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from times import getTime, toUnix, nanosecond
import random

let now = getTime()
var rstate = initRand(now.toUnix * 1_000_000_000 + now.nanosecond)

for i in 0 .. 5:
  echo rstate.rand(5) + 1 # dice roll

for i in 0 .. 2:
  echo rstate.rand(100.0) # float random number in range 0.0 .. 100.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unfortunately, the <span class="func">initRand()</span> call to initialize it with a current time value is a bit complicated, as
we have to provide the current time value directly. Note that you typically should call
<span class="func">initRand()</span> only once in your program. A common mistake of beginners is, to call
<span class="func">initRand()</span> each time directly in front of the <span class="func">rand()</span> call. That is not only not needed and
slows down the generation process, it also can lead to strange number sequences.</p>
</div>
<div class="paragraph">
<p>At the end of this section, we will discuss the problem of filling a container with random but unique
numbers. For example, assume that we want to generate a sequence of <span class="lit">100</span> random numbers in the range <span class="var">1 .. 100</span>,
with the restriction that each number should occur exactly once in the sequence. Of course, a code
segment like <span class="code">s[i] = (rand(99) &#43; 1)</span> would not work, as the same numbers could be generated multiple times
or not at all. The obvious solution for this task is to fill an array first with consecutive numbers <span class="lit">1</span> to <span class="lit">100</span> and
then exchange the initial positions with destination positions determined by <span class="func">rand(99)</span>
The <span class="mod">random</span> module provides the <span class="func">shuffle()</span> function for this shaking of a container.
A related function is <span class="func">sample()</span>, which is used to randomly select an element from an <span class="type">openArray</span> or a <span class="type">set</span>.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Random_number_generation" class="bare">https://en.wikipedia.org/wiki/Random_number_generation</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Applications_of_randomness" class="bare">https://en.wikipedia.org/wiki/Applications_of_randomness</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Pseudorandom_number_generator" class="bare">https://en.wikipedia.org/wiki/Pseudorandom_number_generator</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/random.html" class="bare">https://nim-lang.org/docs/random.html</a></p>
</li>
<li>
<p><a href="https://prng.di.unimi.it/" class="bare">https://prng.di.unimi.it/</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_timers">Timers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sometimes we may want to measure the execution time of a code segment of
our program. For this, the Nim standard library provides various modules
including the larger <span class="mod">times</span> module and the <span class="mod">monotimes</span> module.
The <span class="mod">times</span> module provides many functions and data types for handling
dates and times, while the small <span class="mod">monotimes</span> module is more specialized for measuring
of time intervals. For our first test, we will use the <span class="func">times.cpuTime()</span> function and
the <span class="func">monotimes.getMonoTime()</span> function. The former gives us time values as seconds
in <span class="type">float</span> format, while the later returns an <span class="type">int64</span> nanosecond value. To measure execution
times of code segments, we ask for the current time at the start and at the end of that segment and
build the difference. Actually, we will try to measure the time needed for a <span class="type">float</span> square root calculation.
In the past, calculating square roots was considered a relatively slow operation, slow compared to
a plain floating point math operation like multiplication or division. But on most modern hardware
square root calculation is really fast actually, as we will see.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[random, times, monotimes]
from std/math import sqrt

proc warmup =
  var x: float
  for i in 1 .. 1e10.int:
    x += 1.0 / i.float
  echo x

proc main1 =
  let x = rand(3.0)
  let y = rand(7.0)
  let start = cpuTime()
  let res = sqrt(x) + y
  let stop = cpuTime()
  echo stop - start
  echo res

proc main2 =
  let x = rand(3.0)
  let y = rand(7.0)
  let start = getMonoTime()
  let res = sqrt(x) + y
  let stop = getMonoTime()
  echo stop - start
  echo res

randomize()
warmup()
main1()
main2()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To get meaningful results, we have to take some care: Most important is, that
the code segment that we want to measure is really executed. This may sound odd, but
assume that the code produces no noticeable result at all. In that case, the compiler may just remove
that code fragment from the generated executable, as it is not needed for correct program execution. Or assume
that the code fragment uses only data which is already known at compile time. Then
the compiler may do all the calculations already at compile time, and the whole
code fragment is removed again and replaced by the pre-calculated values. And finally, we
have to remember that our computer may execute other task at the same time or may be in
various power saving states with reduced CPU clock frequency, from which it takes some time to wake up. To take care of this, we
try to execute some warm up code before our actual timing task, and we do use the <span class="func">rand()</span> function
from the
<span class="mod">random</span> module to provide input values for our code that are not known during compile time.
Finally, we output the result of the calculation by use of an <span class="func">echo()</span> statement to make clear
to the
compiler that the result of the calculation is really needed. Now let us compile and run this program.
We compile with option -d:release or -d:danger to enable optimizations and avoid generation of debugging code
that may distort our timing. The result is still a bit surprising:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./t1
23.6030665949975
4.98999998654881e-07
4.676567857718999
42 nanoseconds
8.527354349689125</pre>
</div>
</div>
<div class="paragraph">
<p>Lines three and five are the results of our timing attempt. Both values are obvious too large and do
not match. The reason for the wrong results is the overhead by the function calls itself. That overhead seems
to be much larger for the <span class="func">cpuTime()</span> call, as we get a result of about <span class="lit">500</span> nanoseconds. Maybe the reason for this is
that <span class="func">cpuTime()</span> works with <span class="type">floats</span> internally. At least, we see that <span class="func">getMonoTime()</span> can measure time intervals
in the range of a few hundred nanoseconds. When we run the program a few times, the printed time intervals
may vary. The reason for that are internal processes in the CPU like clock rate and state changes. Generally, the
smallest time value of multiple program executions is the most important for us, as that is the minimal
time which is actually needed for the program execution. With this example, we have learned how we can measure
time differences in our program, and that measuring really small time-intervals is difficult.</p>
</div>
<div class="paragraph">
<p>Fortunately, measuring such tiny time intervals is supported by the criterion package, which we may describe
in later sections of the book.</p>
</div>
<div class="paragraph">
<p>For now, we will present another example program, where we measure program code with longer running times.
For that, we create a loop that is executed many times. So the offset of the timer functions calls can be neglected
compared to the actual running time of the loop, and due to the longer running time the printed time values get
more reliable with low variations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[random, times, monotimes]
from std/math import sqrt

proc main3 =
  var s: array[64 * 1024, float]
  var res: float
  for i in 0 .. s.high:
    s[i] = rand(100.0)
  let start = getMonoTime()
  for i in 0 .. s.high:
    res += sqrt(s[i])
  let stop = getMonoTime()
  echo stop - start
  echo res

proc main4 =
  var s: array[64 * 1024, float]
  var res: float
  for i in 0 .. s.high:
    s[i] = rand(100.0)
  let start = cpuTime()
  for i in 0 .. s.high:
    res += sqrt(s[i])
  let stop = cpuTime()
  echo stop - start
  echo res

randomize()
main3()
main4()</code></pre>
</div>
</div>
<div class="paragraph">
<p>For this example program, we first fill an array with 64k random <span class="type">float</span> numbers and then sum the square root of these numbers.
As the total running time of our loops is not that tiny, we do not need a special warm up
function which is executed in front of the timed code. The output of our program show that
both timing functions match well for longer time periods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./t2
112 microseconds and 701 nanoseconds
436909.89897942
0.0001135580000000001 # 114 microseconds
437222.3001038401</pre>
</div>
</div>
<div class="paragraph">
<p>The float result in line 4 is 114 microseconds, which matches well with the 112 microseconds
from line two. When you run this program multiple times, you may notice that you may
get sometimes much lager results for both or for only one of the two values. That is not
surprising, as the computer is processing not only our program but many more, and due to task
switching our program may be suspended for some time. When we divide that 114 microseconds
by the number of loop iterations (64 * 1024) we get 1.7 nanoseconds, which is really surprising fast
for a square root calculation. The concrete value is for a modern Intel I7 CPU. Of course, these 1.7
nanoseconds is not only the time needed for the square root calculation, but it includes
the operations with the loop counter and the time needed to fetch and to access the actual array elements.</p>
</div>
<div class="paragraph">
<p>As timing code segments is not an uncommon use case, there exists some external package which
improve or simplify these operations, like the criterion or benchy package. A related task is profiling
our program to find the part which takes the most CPU time, so that we can concentrate on these parts
to improve the total performance of our program. For profiling, various tools like the Linux perf tool
are available, which we will discuss in more detail later in this book.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/LemonBoy/criterion.nim" class="bare">https://github.com/LemonBoy/criterion.nim</a></p>
</li>
<li>
<p><a href="https://github.com/disruptek/criterion" class="bare">https://github.com/disruptek/criterion</a></p>
</li>
<li>
<p><a href="https://github.com/treeform/benchy" class="bare">https://github.com/treeform/benchy</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hash_tables">Hash Tables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A common task in computer programming is the storing and retrieving of
data records. The situation is very easy whenever each data record is directly
mapped to
continuous integer number n0, n0&#43;1, n0&#43;2, &#8230;&#8203;, n0&#43;M. In that case we can
use that numbers as index keys to access the data records and store the data as objects
or references to objects in a sequence, or maybe when the data set in small and the maximal
number of entries is known at compile time in an array.</p>
</div>
<div class="paragraph">
<p>In the past, it was a common practice to give hardware parts in a shop and even customers
a unique ID number from a continues range, so that storing and fast access in indexed containers
is possible. This works well when we really use the numbers as keys. But actually we typically
work with data which is already labeled by names expressed as sequences of ASCII character:
Customers in a hardware store, food in a super marked. Assigning ID numbers to people is possible, but generally
people do not like to have to remember the assigned ID number when they want to buy something
in an online shop.</p>
</div>
<div class="paragraph">
<p>So let us investigate how we can store and retrieve data objects without the use of continues
numbers as key. Assume we have a customer database</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Customer = object
    lastName: string
    firstName: string
    age: int
    postalAdress: string
    phone: string
    credit: float</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, we can store the customers just in a seq, and do a linear search when we want to
access a person by name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">customers: seq[Customer]

# ...

var found = false
for c in customers:
  if c.lastName == queryName:
    found = true
    echo "Person ", queryName, " has a credit limit of ", c.credit
if not found:
  echo queryName,  "not found"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a plain linear search is not very fast, of course. An obvious improvement would
be to sort the customers by names, as we can do a so-called binary search in that case
as we did long time ago in printed telephone registers: Open the telephone book somewhere
in the middle, and when the names on that page are all greater than our friend&#8217;s name, then continue the
search in the first half of the book, otherwise in the last half. We continue the halving strategy
until we find the name. As we halve the data set in each step this way, we say that the algorithm has
log2(N) cost, where log2 is the logarithm with base two and N is the size of the data set.</p>
</div>
<div class="paragraph">
<p>A similar solution would be to use some form of an ordered binary tree, which has also
log2(N) costs for retrieving operations. We will learn more about sorting sequences,
doing a binary search in a sorted seq and about tree structures later in the book.</p>
</div>
<div class="paragraph">
<p>A hash table, called only table in Nim, is a homogeneous resizable container that behaves similar
to the Nim sequences, but releases the restriction that for direct accessing an element its position in
the sequence has to be known.</p>
</div>
<div class="paragraph">
<p>The idea of a hash table is to use an arbitrary data type to directly access
objects stored in a container in a similar way as we can do it for arrays and
sequences with integer keys. The first step is to use a so-called hash function to
map key objects, which are not already of integer type, to the integer type.
We would try to use a hash function which can be evaluated fast and which
maps our data to integer values distributed to the whole integer value space
without clustering. The integers generated by a hash function look in some way like
random numbers, they are distributed over the full integer value range without
an obvious order or systematic. Mapping arbitrary objects to integers is generally not
difficult. For a string, a first attempt would be to use the characters of a string
in the same way as we calculate the value of a number literal by summing up
the digits each multiplied with powers of ten given by the position. For
a string that may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">intVal = uint(s[0]) * 256^0 + uint(s[1]) * 256^1 + uint(s[2]) * 256^2 + ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>We multiply with powers of 256 as we have 256 different ASCII characters.</p>
</div>
<div class="paragraph">
<p>That would be not really a good hash function, as all short strings would be mapped
to low integer values, not distributed over the full value range. But similar, smarter
has functions are available.</p>
</div>
<div class="paragraph">
<p>So a hash function can map arbitrary data types to integers. But what we really want
is a sequence of continues integer values, which the hash functions does not provide
by design. But that is no real problem: In the same way as we can do a range reduction
for a random number generator function generating random numbers using the full
integer range by just applying a modulo operation, we can apply the modulo
operation on the value returned by a hash function.</p>
</div>
<div class="paragraph">
<p>Range reduction by modulo gives us smaller integer numbers, which may
already be some form of index values for an array or a seq. With two
restrictions: Index collisions can occur, as applying the hash function and the modulo range reduction on
different <span class="str">strings</span> may give us the same index value. And some index values may be never generated.
The latter is not that serious, some positions in the container would remain unpopulated.
Collisions are much more serious of course, we have to handle them somehow. One solution
is, that we make each storage location in our container again a sequence, which can store
all the colliding data sets. That way, our hash table would be a sequence, where each element is again
a short sequence containing all the colliding data record. For a data retrieving operation, applying
the hash function with modulo data reduction would give us the position in the larger seq, and we
then would have to check all the elements in the short seq to find the actual record. In the best case
the short seq contains only one entry, when no collision has occurred. For a customer database
this strategy may be indeed the best solution, as in rare cases multiple different customers
may have exactly the same name. So it would be nice if for query operations in that case
a list of all customers with exactly that name is returned.</p>
</div>
<div class="paragraph">
<p>In practice, often a modified strategy is applied preventing the seq in seq container type: We use
only one loosely populated seq, and whenever a collision occur, we just put the colliding data
record at some free index position after the position determined by the hash index value.
That way data retrieving starts by the position given by the hash key and then checks the data record
at that position and the following positions, until a matching record or an empty position is
found, the later case indicates that the queried data record is not contained in the database.
Storing data records works similar: When the position given by the hash key is void, then the
new entry is stored at that position. If the index position is already occupied, then following
positions are examined until a void one is found and the data is stored there.</p>
</div>
<div class="paragraph">
<p>Hash tables work well generally when they are not too dense populated. Typically
we make the number of available index position double the size of the number
of expected entries. Then the chance of collisions is not too large, and when a collision
occurs, then chances are high that one of the next positions are still unpopulated.</p>
</div>
<div class="paragraph">
<p>When by inserting more and more data records the population density becomes too high, then typically
a new, larger table is allocated, and the data records are moved from the old to the new table, similarly
as it is done for plain sequences when all capacity is occupied.</p>
</div>
<div class="paragraph">
<p>Now let us see how we can use the <span class="mod">tables</span> module of the Nim standard library to store the customer
record we introduced above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/tables

type
  Customer = object
    lastName: string
    firstName: string
    yearOfBirth: int
    postalAdress: string
    phone: string
    credit: float

var customers: Table[string, Customer]

proc addNewCustomers =
  var c: Customer
  c = Customer(lastName: "Turing", firstName: "Alan")
  c.postalAdress = "England"
  c.yearOfBirth = 1912
  customers["Turing, Alan"] = c

  c = Customer(lastName: "Zuse", firstName: "Konrad")
  c.postalAdress = "Germany"
  c.yearOfBirth = 1910
  customers["Zuse, Konrad"] = c

proc queryCustomer(key: string) =
  if customers.hasKey(key):
    echo "known customer:"
    echo customers[key]
  else:
    echo "customer key not found in data base"

addNewCustomers()

queryCustomer("Zuse, Konrad")
queryCustomer("Gates, Bill")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic usage of Nim tables is very similar to the use of sequences. While we have to specify only the
base type for a Nim <span class="type">seq</span>, we have to specify the type of the key and the type of the stored entities
for a hash <span class="type">Table</span>. The line <span class="code">var customers: Table[string, Customer]</span> defines a variable with a generic <span class="type">Table</span> type.
The table uses <span class="str">strings</span> as keys and stores <span class="type">Customer</span> objects. We can then use the <span class="op">[]</span> subscript operator
to store <span class="type">Customer</span> objects in the <span class="type">Table</span>. As we created a <span class="type">Table</span> with <span class="str">string</span> key type, we have to specify <span class="type">strings</span>
when we use the subscript operator or other functions to access entries of our table. For the query operation,
we first call the function <span class="func">hasKey()</span> to check if the customer with that name is contained in the database and
then use again the subscript operator to access the data record.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">tables</span> module of the Nim standard library provides many more functions for interacting with <span class="type">Tables</span>.
Most are easy to understand and use. When you inspect the API docs of the <span class="mod">tables</span> module, you will
discover that beside the <span class="type">Table</span> data type also a <span class="type">TableRef</span> exists. The <span class="type">Table</span> type has value semantics, that
is if you copy a whole table instance, then the whole content is copied. <span class="type">TableRef</span> instances have reference semantics,
the content is not copied when you assign one instance of a <span class="type">TableRef</span> to another variable.</p>
</div>
<div class="paragraph">
<p>In the example above, we called <span class="func">hasKey()</span> to check if a data record is available before we accessed that record.
Access with the subscript operator <span class="op">[]</span> would raise an exception when an entity is not available in the table.
<span class="func">HasKey()</span> and <span class="op">[]</span> both would have to locate the data record. A faster way to access data record when we are not sure
if they exist in the table is the <span class="func">getOrDefault()</span> <span class="proc">proc</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">let dummy = Customer()
let query = customers.getOrDefault(name, dummy)
if query.lastName.len == 0: # we know all entries in the database have a lastName, so we got the dummy default value
  echo name, "not found"
else:
  process(query)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A useful variant of the <span class="type">Table</span> data type is the <span class="type">CountTable</span>, which we can use to count data object, maybe words in a text:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tables
var ct: CountTable[string]
ct.inc("Nim")
ct.inc("Rust")
ct.inc("Nim")

echo ct["Nim"]
for k, v in ct:
  echo k, ": ", v</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will give an extended example for the use of a CountTable for counting words in a text file below, see <a href="#_counttable">CountTable</a>.</p>
</div>
<div class="paragraph">
<p>A <span class="type">Table</span> instance stores entries not in the order of insertion. When we iterate over the <span class="var">table</span>,
we get the results not back in the order of insertion. If we really should need to preserve
the insertion order, we may use the <span class="type">OrderedTable</span> variant. Note that an <span class="type">OrderedTable</span>
does not sort its entries, it remembers insertion order. Ordered <span class="type">Tables</span> have some internal
overhead, so we should use them only when necessary.</p>
</div>
<div class="paragraph">
<p>For all the various table variants we can use <span class="proc">procs</span> like <span class="func">clear()</span>, <span class="func">len()</span> or <span class="func">del()</span> to remove all entries
from a table, to check for the number of entries or to delete entries. Note that some functions
may throw exceptions when we try to access entries that are not available. And note that
the subscript operator <span class="op">=[]</span> overwrites already existing entries.</p>
</div>
<div class="paragraph">
<p>For our initial customer database the current table implementation may still be not optimal, as
it is not clear how to handle different customers with the same name. But customer databases
are really special cases, in most cases different things have different names.</p>
</div>
<div class="sect2">
<h3 id="_user_defined_hash_values">User defined hash values</h3>
<div class="paragraph">
<p>The <span class="mod">tables</span> module uses the <span class="mod">hashes</span> module to calculate the hash value for the keys that
we use to access table content. For many data types, the <span class="mod">hashes</span> module already defines
a hash function. When we would like to use <span class="type">tuples</span> or <span class="key">object</span> data types as keys for table access, then we would have to
define a hash function for that key objects first. The API documentation of the <span class="mod">tables</span> module
contains an example for this, where as key an object data type with firstName and lastName fields is used
to store salary entries in the table. While firstName and lastName are strings, and for single <span class="str">strings</span> a predefined
hash function is available, we have to declare another hash function for objects with two strings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tables, hashes

type
  Person = object
    firstName, lastName: string

proc hash(x: Person): Hash =
  ## Piggyback on the already available string hash proc.
  ##
  ## Without this proc nothing works!
  result = x.firstName.hash !&amp; x.lastName.hash
  result = !$result

var
  salaries = initTable[Person, int]()
  p1, p2: Person

p1.firstName = "Jon"
p1.lastName = "Ross"
salaries[p1] = 30_000</code></pre>
</div>
</div>
<div class="paragraph">
<p>The hash generation is a bit cryptic: First we mix various existing hash values using the <span class="op">!&amp;</span> operator, and finally
we use the <span class="var">!$</span> operator to generate the final hash value. For details, please see the API documentation of the <span class="mod">hashes</span> module.</p>
</div>
<div class="paragraph">
<p>Hash tables can be seen as a way to attach arbitrary data to other data. The above example attaches a "salary" to
a person object. In most cases, we would just create one more object field when we have to store more data, but sometimes
that is not easily possible. One example is when we use a low level C library, which gives us some C objects back. Maybe
we use an advanced C or C++ math library like CGAL, and we get some abstract low level objects from it, maybe circles
with center coordinate and diameter. As that objects are not Nim object, but C or C++ entities, we can not easily subclass
them to attach more properties like a color attribute. But as each entity has a unique address, we can just use a
table with key type address and all the needed values like color as data. That would be some overhead of course, as
each color lookup would mean a table access, but it is a simple solution.</p>
</div>
<div class="paragraph">
<p>We can even attach properties to plain data types this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tables

var t: Table[float, string]

let PI = 3.1415
t[PI] = "Pi"
t[2.0] = "two"

echo t[PI]
echo t[2.0]
echo t[5.0 - 3.0]</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <span class="type">floats</span>, a predefined hash function is available, so the code above should work. But <span class="type">floats</span> as keys are a bit fragile due
to the fact that <span class="type">float</span> math is not really exact. So the last line in the above code may raise an exception due to
access of a non-existent entry, as the difference <span class="lit">5.0 - 3.0</span> may not exactly be identical to the value <span class="lit">2.0</span>.</p>
</div>
<div class="paragraph">
<p>Hash tables can be even useful containers, when we already have numeric data as possible keys for indices in a
sequence: In mathematics we could have a two-dimensional array, that is an <span class="type">array</span> of <span class="type">array</span> in Nim, to store matrices.
This is OK when the matrix is really populated, that is, most entries have meaningful non-trivial values. But for
very large, loosely populated matrices, with mostly just zero or one entry, storing the complete matrix
as a table using a row, column tuple as key, may save a lot of RAM.</p>
</div>
</div>
<div class="sect2">
<h3 id="_equality_and_identity">Equality and Identity</h3>
<div class="paragraph">
<p>When we use objects or references to objects as keys for tables, we have to remember
how Nim compares value and reference types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tables, hashes

type

  O = object
    i: int

  R = ref object
    j: int

proc hash(o: O): Hash = hash(o.i)

proc hash(r: R): Hash = hash(cast[int](addr(r[])))

var o1 = O(i: 7)
var o2 = O(i: 7)
var r1 = R(j: 13)
var r2 = R(j: 13)

echo o1 == o2
echo r1 == r2

var t1: Table[O, float]
t1[o1] = 3.1415
echo t1.hasKey(o2)

var t2: Table[R, float]
t2[r1] = 2.7
echo t2.hasKey(r2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the above program is</p>
</div>
<div class="listingblock">
<div class="content">
<pre>true
false
true
false</pre>
</div>
</div>
<div class="paragraph">
<p>By default, the <span class="op">==</span> operator compares content for value <span class="key">objects</span>, but the instance addresses for references.
Because of this, it makes sense to define hash functions for <span class="key">object</span> types and <span class="key">ref</span> <span class="key">object</span> types
in a compatible way: We use the hash value of the single integer field of our value object as the hash result
for the entire object, and we use the address of the instance for the hash value of the reference object.
As different instances of <span class="key">ref</span> objects have always different addresses, the hasKey() does return false
when we use as argument a different instance variable, independent of the content of its fields.</p>
</div>
<div class="paragraph">
<p>For special use cases we may redefine the <span class="op">==</span> operator, but we have to ensure that the defined hash function
matches the <span class="op">==</span> operator: When <span class="var">a == b</span> is true, then <span class="func">hash(a)</span> has to be identical to <span class="func">hash(b)</span>! The reason is,
that tables first compare the hash value of the query key with the key of entities in the table, and only for a matching
hash value do the comparison of the actual data content.</p>
</div>
</div>
<div class="sect2">
<h3 id="_performance">Performance</h3>
<div class="paragraph">
<p>Hash table lookup is fast. We say that hash table lookup is a O(1) operation, which shall indicate that
the time needed for doing a table lookup does not depend on the total number of entries stored in the table.
The reason for that is that for a lookup it is necessary to calculate the hash value, do the modulo operation and
access the table content and potentially a few of the following table entries in the case that the first entry is not a match.
Storing data is also an O(1) operation, as it works very similar, as long as the table is not already too dense populated
so that a recreation is necessary. In that case that single storing operation is obviously very slow, but that
occurs very rarely, and maybe not at all when we use a large enough table from the beginning.
Still, small tables are much faster than larger tables due to cache effects. For small tables
all data may fit into the caches of the CPU, while for large tables most data is located outside of caches in RAM, and RAM
access is magnitudes slower than cache access.</p>
</div>
<div class="paragraph">
<p>And hash table lookup is slower than <span class="type">array</span> or <span class="type">seq</span> access. To access an element from an <span class="type">array</span> or <span class="type">seq</span>,
we have only to multiply the index value with the byte size of the stored elements type and potentially
to add an offset when the <span class="type">array</span> does not start at index <span class="lit">0</span>. For tables, we have to calculate the hash value,
do the modulo operation, access some elements at the calculated position, and most importantly, to compare
the content at that positions with the actual key data. If the key is a <span class="str">string</span>, a few <span class="str">string</span> comparisons (at least one) are necessary
to determine if the query element is available in the table. So while <span class="type">array</span> access may take less than a nanosecond on modern hardware,
table lookup may take a few dozens of nanoseconds. Lookup with <span class="str">string</span> keys is generally slower than for
other key types likes integer, as for string comparison it may be necessary to compare many characters to get a result
and because strings generates some memory indirection by the fact that string content is stored somewhere in the heap
outside any cache.</p>
</div>
</div>
<div class="sect2">
<h3 id="_tuples_or_other_containers_as_keys">Tuples or other containers as Keys</h3>
<div class="paragraph">
<p>At the end of our introduction to hash tables we will present a very useful, but perhaps not
that obvious property of hash tables: The keys used for table access don&#8217;t have to be simple data types,
but can be container types like <span class="type">tuples</span> or <span class="type">arrays</span>. Imagine you have a map in 2d with a set of points on that
map each presented by an <span class="var">x</span>, <span class="var">y</span> coordinate pair. That points could be cities, and some cities may have a direct connection
by a road. So how can we test if two cities are directly connected and get the distance between the two cities?
With a hash table using a tuple of two city coordinates as key, it is easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import tables, math

const
  InvalidFloat = 1e30 # arbitrary marker that in not a valid value
  InvalidCoord = (InvalidFloat, InvalidFloat)

type
  Coord = tuple
    x: float
    y: float

  Cities = Table[string, Coord]
  Distances = Table[(Coord, Coord), float]

var cities: Cities
var distances: Distances

proc insertCity(name: string; coord: Coord) =
  cities[name] = coord

proc insertDist(a, b: string) =
  var (a, b) = (a, b)
  if a &gt; b: swap(a, b)
  let ca = cities[a] # caution, will raise an exception if name is not a know city
  let cb = cities[b]
  distances[(ca, cb)] = math.hypot(ca.x - cb.x, ca.y - cb.y)

proc checkDirectConnection(a, b: string): float =
  var (a, b) = (a, b)
  if a &gt; b: swap(a, b)
  let ca = cities.getOrDefault(a, InvalidCoord)
  let cb = cities.getOrDefault(b, InvalidCoord)
  if ca == InvalidCoord or cb == InvalidCoord:
    return -1 # marker when cities are unknown
  result = distances.getOrDefault((ca, cb), InvalidFloat)

insertCity("aTown", (2.0, 7.0))
insertCity("bTown", (2.0, 11.0))
insertCity("cTown", (17.0, 23.0))

insertDist("aTown", "bTown")

var d = checkDirectConnection("aTown", "bTown")
if d == -1:
  echo "query for unknown town"
elif d == InvalidFloat:
  echo "Cities have no direct connection"
else:
  echo "Distance: ", d

echo checkDirectConnection("bTown", "aTown") # 4, same as above
echo checkDirectConnection("aTown", "cTown") # 1e30
echo checkDirectConnection("aTown", "xTown") # -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the <span class="proc">procs</span> <span class="func">insertDist()</span> and <span class="func">checkDirectConnection()</span> we use a trick to get the same
results when we exchange the names: We sort the names alphabetically when we insert
the distances and also when we query the distances. So we get the same result.
Of course, we could insert the tuple also twice instead, but as the distance is the same
in both directions, sorting and inserting only ones makes some sense. Note that
we used tuples for the coordinate pairs in the distances tables. Maybe the more obvious
data type would be an <span class="type">array</span> with two entries, as the <span class="type">array</span> type is a container for
homogeneous data, while a <span class="type">tuple</span> can also contain different data types. But currently
Nim supports tuples better in some situations, e.g. for automatic <span class="type">tuple</span> unpacking.
So often we use <span class="type">tuples</span> when <span class="type">array</span> would be the first choice, maybe. <span class="type">array</span> type would have
the benefit of iteration over elements at runtime, while tuples have the benefit
that we can access elements by names and by an integer constant. For performance, <span class="type">array</span>
or <span class="type">tuple</span> should make no difference here.</p>
</div>
</div>
<div class="sect2">
<h3 id="_counttable">CountTable</h3>
<div class="paragraph">
<p>We mentioned this data type already very briefly in one of the preceding sections,
but as it really can be very useful sometimes, we should show an extended example.
The <span class="type">CountTable</span> data type is a variant of the ordinary <span class="type">Table</span> type, that is used to
count instances of arbitrary data types, most often strings or integer numbers.
The <span class="type">CountTable</span> can use as keys the same data types as the ordinary <span class="type">Table</span>, but its
value type is always an integer. And instead of using operators like <span class="op">[]=</span> to insert
values into the table, we use the <span class="func">inc()</span> procedure to increase the occurrence counter
for the key.
Actually, the first call of <span class="func">inc()</span> adds the key to the table instance and sets it counter to one, and each subsequent
call of <span class="func">inc()</span> with the same key increases the counter by one.
A typical use case for <span class="type">CountTables</span> is to count the occurrences of words
in a text file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/tables

from strutils import split

proc main =
  const FileName = "t.nim"

  var t: CountTable[string]

  for l in FileName.lines:
    for w in l.split:
      t.inc(w)

  for k, v in pairs(t):
    echo k, " ", v

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run the above program, we get for that source code this output:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Click to see it</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre> 30
main() 1
t.inc(w) 1
proc 1
split 1
const 1
main 1
var 1
in 3
strutils 1
from 1
v 2
", 1
FileName.lines: 1
= 2
import 2
t: 1
w 1
CountTable[string] 1
"t.nim" 1
FileName 1
l 1
pairs(t): 1
k, 2
" 1
for 3
l.split: 1
std/tables 1
echo 1</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Counting words in text files can help us find rare spelling errors and words that we use too frequently, like
"generally", "problem" or "course" in this book. But for that application we would have to extend
the code from the above so that it ignores punctuation characters, and sorts the output. You should be already
able to add that functionality yourself.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/tables.html" class="bare">https://nim-lang.org/docs/tables.html</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/hashes.html" class="bare">https://nim-lang.org/docs/hashes.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hash_sets">Hash Sets</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <span class="mod">sets</span> module provides the generic <span class="type">HashSet[T]</span> data type and the related procedures and functions.
<span class="type">HashSets</span> behave similar to Nim&#8217;s built-in <span class="type">set</span> type,
but while the base types of the built-in <span class="type">set</span> type is restricted to ordinal data types of 8 or 16 bit size, there is no such restriction
for <span class="type">HashSets</span>.
That is, <span class="type">HashSets</span> can be used like hash <span class="type">Tables</span> for most of Nim&#8217;s data types, including
user defined types like <span class="key">objects</span>. From the implementation, <span class="type">HashSets</span> are very similar to hash <span class="type">Tables</span>&#8201;&#8212;&#8201;while
a hash <span class="type">Table</span> uses a key entity to access a value instance, <span class="type">HashSets</span> uses only the key, e.g. to test if the key is
contained in the set. A typical use of <span class="type">HashSets</span> is to test if a <span class="str">string</span> in contained
in a collection of <span class="str">strings</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/sets

var s: HashSet[string] = toHashSet(["var", "type", "const", "while"])

var v = stdin.readLine

if v in s:
  echo v, " is a Nim keyword"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The functions and procedures provided by the <span class="mod">sets</span> module are used similar to
the ones of the <span class="mod">tables</span> module&#8201;&#8212;&#8201;we have <span class="func">excl()</span> and <span class="func">incl()</span> to remove or add elements
to a set instance, and operations to create the union, intersection or difference of
two <span class="type">HashSets</span>. As the basic behavior of <span class="type">HashSets</span> is so similar to hash <span class="type">Tables</span>, we will
not try to explain the available functions&#8201;&#8212;&#8201;whenever you may have a concrete use case
for Nim&#8217;s <span class="type">HashSets</span>, you can consult the module documentation. Remember, that as
for hash <span class="type">Tables</span>, for data types used as keys, a <span class="func">hash()</span> function and the <span class="op">==</span> operator must have been defined.</p>
</div>
<div class="paragraph">
<p>A more interesting point is, when you should use Nim&#8217;s built-in <span class="type">set</span> type, and when
the <span class="type">HashSet</span>. Well, Nim&#8217;s built-in <span class="type">set</span> type is restricted to ordinal types of 8 or 16 byte size as base type, that
is byte, int8, uint8, bool, char, enum, int16 and uint16. For other base types, we have to use
the <span class="type">HashSet</span>. So why do we not always use <span class="type">HashSets</span> only? The reason is, that the implementation
is different. The built-in <span class="type">set</span> type is internally a bit vector. To store a <span class="type">set</span> with an 8-bit base type,
256 bits are needed, that is 10 bytes. For this data type, operations like union, intersection or difference
map well to basic CPU instructions like <span class="func">bitor</span> and <span class="func">bitand</span>, and are very efficient. The same is true
for the <span class="func">incl()</span> and <span class="func">excl()</span> operations, which map well to fast CPU instructions. So whenever
we can use the built-in <span class="type">set</span> type with a 8-bit base type, then we should use that, and not a <span class="type">HashSet</span>.
For a 16-bit base type, the set requires already 8192 bytes&#8201;&#8212;&#8201;for a union, intersection or difference
all these bytes have to be combined in some way. The <span class="func">incl()</span> and <span class="func">excl()</span> operations should be still really fast&#8201;&#8212;&#8201;a few math operations (div 8) gives the byte location, and then a CPU instruction tests if a bit is set or sets
a bit. So the built-in <span class="type">set</span> type should work still fine with a 16-bit base types, and for dense populated
<span class="type">sets</span> the built-in type should be the best option in most cases. Here, dense populated means, that
most of the provided bits are really needed and used. For sparse populated <span class="type">sets</span>, the situation
is different. Imagine you have a few numbers, all smaller than <span class="lit">int16.high+1</span>, but some larger than
<span class="lit">int8.high</span>. For this use case, a <span class="type">HashSet[int16]</span> should consume less storage, and may offer
comparable performance. Just test it yourself!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operating_system_services">Operating system services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <span class="mod">os</span> module supports basic interactions with the operating system,
like accessing the file system,
reading command line arguments,
executing  shell commands and external processes
or retrieving environment variables.
The abstractions of the <span class="mod">os</span> module allows us to write programs
that may interact with the OS but still can be compiled and run unchanged on various operating systems
including Windows, macOS and Linux.</p>
</div>
<div class="paragraph">
<p>This module is quite large, and it would make no sense to
introduce many of its content here. When you have the feeling
that you may need some functionality that is related to OS services,
you just should consult the API documentation of the <span class="mod">os</span> module.</p>
</div>
<div class="paragraph">
<p>We have already used some functions of the <span class="mod">os</span> module in earlier
section of the book, for example the <span class="func">paramCount()</span> and <span class="func">paramStr()</span> functions
to process command line arguments, and the <span class="func">fileExists()</span> and <span class="func">getFileSize()</span>
functions to test if a file already exists, and to get the file size in bytes.
Whenever we intend to access the file system, we have to take into account the fact that
the three major operating systems uses different separator characters for file paths, and different
paths for folders like the user&#8217;s home directory. Functions like <span class="func">getHomeDir()</span> or  <span class="func">getAppDir()</span>
makes it easier to navigate in the file system structure, and functions like  <span class="func">joinPath()</span>
or <span class="func">addFileExt()</span> helps us to construct file or folder names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/os
const FileName = "data"
const FileExt = "txt"
var path = getAppDir()
path = joinPath(path, FileName)
path = addFileExt(path, FileExt)
echo path
if fileExists(path):
  echo "File: ", path, " already exist."
else:
  path.writeFile("Testing the os module.\n")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The iterator <span class="func">envPairs()</span> can be used to list all the environment variables, and
<span class="func">getEnv()</span> to get the value of a specific variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/os

for k, v in envPairs():
  echo k, ": ", v

echo getEnv("USERNAME")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or we may use the <span class="func">walkDir()</span> iterator to iterate over the content of a folder:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/os

for k, p in walkDir(getAppDir()):
  echo k, ": ", p</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="func">WalkDir()</span> returns a <span class="type">tuple</span>&#8201;&#8212;&#8201;the <span class="type">PathComponent</span> enumeration like <span class="lit">pcFile</span> or <span class="lit">pcDir</span>,
which gives us the type of the directory entry,  and the path as a string.</p>
</div>
<div class="paragraph">
<p>The function <span class="func">execProcess()</span> to run a shell command is provided by the <span class="mod">osproc</span> module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/osproc

when defined(windows):
  # var output = execProcess("cmd.exe /c ipconfig")
  var output = execProcess("cmd.exe /c ipconfig" , options={poUsePath, poStdErrToStdOut, poEvalCommand, poDaemon})
else:
  var output = execProcess("ifconfig")
  echo output</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we used <span class="code">when defined(windows):</span> to test if the code has been compiled for windows or for Linux/macOS, so that we can use
the correct command string. For windows, flashing of the console window may be an issue, see
<a href="https://forum.nim-lang.org/t/7320#46431" class="bare">https://forum.nim-lang.org/t/7320#46431</a>.</p>
</div>
<div class="paragraph">
<p>Other functions of the <span class="mod">os</span> module that can sometimes be useful are <span class="func">sleep()</span> to delay the program execution for
a time period specified in milliseconds, and <span class="func">parseCmdLine()</span> which splits the  command line argument <span class="type">string</span>
into several components. But in the next section we will present the <span class="mod">parseopt</span> module, which is an advanced command line parser,
and in part V of the book, we will present the external <span class="var">cligen</span> package which is even more powerful.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_command_line_parsing"><span class="new">Command line parsing</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>For Linux users, it is not uncommon to use a <span class="italic">terminal window</span> or <span class="italic">shell</span> to launch programs by
typing in textual commands instead of clicking on icons or pictograms. In the introducing
sections of the book, we said, that one way to launch the Nim compiler is to
type a command like <span class="term">nim c --gc:arc test1.nim</span> in a terminal window.</p>
</div>
<div class="paragraph">
<p>Pure Windows users, who never use terminal windows to interact with the computer, may
skip this section. For the others, we will give a short introduction to the structure of
command line arguments, and how we can process them with the <span class="mod">parseopt</span> module
of Nim&#8217;s standard library.</p>
</div>
<div class="paragraph">
<p>Working from within a terminal window can have some benefits in some scenarios,
and some simple tools may have no graphical user interface at all, so that you can
only use them from the terminal.
From within a terminal window, we can type in command names like <span class="term">ls</span> or <span class="term">df</span>, and press the return
key to just execute a program with that name. Or we can pass additional options and arguments to these programs,
e.g. the command <span class="term">ls -l /tmp</span>  would list the directory entries of the <span class="var">/tmp</span> folder displayed as one entry per line.
Here <span class="term">ls</span> is the command or program name, <span class="lit">-l</span> is an option, indicating that we desire an output format
with only one entry per line, and <span class="var">/tmp</span> is the actual argument, which is the <span class="var">/tmp</span> folder. Don&#8217;t get confused by
the slash character in front of the <span class="var">tmp</span> directory name&#8201;&#8212;&#8201;the slash has no special relevance for the argument parsing,
it is just that on Linux systems <span class="lit">/</span> is the name of the upmost level of the file system, called the file system <span class="italic">root</span>,
so <span class="var">/tmp</span> is the folder named <span class="var">tmp</span> at the file system root.</p>
</div>
<div class="paragraph">
<p>We said that in the <span class="term">ls</span> command above,  <span class="term">-l</span> was an option. That option indicates for the <span class="term">ls</span> command that we want the output
with only one entry per line. For the <span class="term">ls</span> command, some other options can be specified in a short and in a long form:
The notations <span class="term">-s</span> and <span class="term">--size</span> can both be used to tell <span class="term">ls</span> to print the file size.
Short options are always introduced by a single <span class="italic">minus</span> character,
and each following single character then stands for a distinct option, e.g. <span class="term">-lt</span> ask for a single
entry per line output which included the modification time for the entry. For the long options, which
starts with two <span class="italic">minus</span> signs, only a single option name like "size" can be specified.</p>
</div>
<div class="paragraph">
<p>Additional to these plain short and long options, there exist also options with <span class="italic">values</span>. The values are
separated from the option name with a colon or an equal sign. Imagine that we have a command called "fancyPrint"
which can print out text documents, and allows us to specify single pages to print instead of the whole
document. That may be done with the short and long options <span class="term">p</span> and <span class="term">page</span>, each requiring a numeric value like
<span class="term">fancyPrint -p:17 mydoc.pdf</span> or <span class="term">fancyPrint --page:17 mydoc.pdf</span>.</p>
</div>
<div class="paragraph">
<p>In principle, it is possible to mix short and long options with and without values and arguments
freely, which can make the evaluation of command line strings difficult. Usually options have to be specified
in front of arguments, but some programs relax this, e.g. <span class="term">ls /tmp -l</span> works also. And some (older)
programs recognize options without a leading minus sign, e.g. <span class="term">tar cf hhh.tar hhh/</span>
specifies that the archiving tool  should create (c) a file (f) named <span class="term">hhh.tar</span> with the content
of folder <span class="term">hhh</span>. Here the single letter <span class="term">c</span> without a leading minus sign is interpreted as some form of command,
<span class="term">c</span> stands for <span class="italic">create</span>. In a similar way, the Nim compiler interprets the first single letter as a command&#8201;&#8212;&#8201;<span class="term">c</span>  for compiling
with the C backend.</p>
</div>
<div class="paragraph">
<p>After this short introduction to command line options, we will investigate how we can use Nim&#8217;s
<span class="mod">parseopt</span> module to process the command line string and extract the various options and parameters.</p>
</div>
<div class="paragraph">
<p>Let us start with this simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/parseopt

var p = initOptParser()
while true:
  p.next
  case p.kind
  of cmdEnd:
    break
  of cmdLongOption:
    echo p.key, ": ", p.val
  of cmdShortOption:
    echo p.key, ": ", p.val
  of cmdArgument:
    echo "Arg: ", p.key, p.val</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you compile and run this code in a terminal window, you can pass various combinations of
short and long options, with and without values, and one or more arguments like file names.
This call</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./t -a=3 --verbose h.txt</pre>
</div>
</div>
<div class="paragraph">
<p>would generate this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a: 3
verbose:
Arg: h.txt</pre>
</div>
</div>
<div class="paragraph">
<p>The first option with key <span class="term">a</span> has value <span class="lit">3</span>, <span class="term">verbose</span> is a long option without a value, and <span class="term">h.txt</span>
is recognized as argument, which may be a file name in this case.</p>
</div>
<div class="paragraph">
<p>Our program starts with a call of <span class="func">initOptParser()</span>, which returns an <span class="type">OptParser</span> <span class="key">object</span>.
We call <span class="func">initOptParser()</span> without any parameter&#8201;&#8212;&#8201;in this case, the function construct the
command line <span class="str">string</span> itself by a series of <span class="func">commandStr()</span> calls of the <span class="mod">os</span> module.
In the <span class="code">while true:</span> loop, we have to call <span class="func">p.next</span> to get the next option. Then we can
access the <span class="var">kind</span> field, which is an enumeration type with the possible values <span class="lit">cmdEnd</span>,
<span class="lit">cmdShortOption</span>, <span class="lit">cmdLongOption</span> or <span class="lit">cmdArgument</span>. This kind field tells us
of what kind the current option is, and the <span class="var">key</span> and <span class="var">val</span> fields of the <span class="type">OptParser</span>
instance gives us the actual option name and the value when available.</p>
</div>
<div class="paragraph">
<p>Instead of this explicit <span class="key">while</span> loop, we can also use the <span class="func">getopt()</span> <span class="key">iterator</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/parseopt

var p = initOptParser()
for kind, key, val in getopt(p):
  case kind
  of cmdEnd:
    assert false # break
  of cmdLongOption:
    echo key, ": ", val
  of cmdShortOption:
    echo key, ": ", val
  of cmdArgument:
    echo "Arg: ", key, val</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we use this <span class="key">iterator</span>, we do not actually get the kind value of <span class="lit">cmdEnd</span>, but we still need
that <span class="key">case</span> label or an <span class="code">else: discard</span> branch of the <span class="key">case</span> statement to cover all possible cases, otherwise
the code would not compile.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">parseopt</span> module supports additional to pass option values without the need to separate the option name
and the option value with a <span class="term">:</span> or a <span class="term">=</span>, e.g. a command line like <span class="term">-a3</span>. To make that work, we have to tell
the parser which options  have values and which do not:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/parseopt

var p = initOptParser(shortNoVal = {'h', 'v'}, longNoVal = @["help", "verbose"])
for kind, key, val in getopt(p):
  case kind
  of cmdEnd:
    assert false
  of cmdLongOption:
    echo key, ": ", val
  of cmdShortOption:
    echo key, ": ", val
  of cmdArgument:
    echo "Arg: ", key, val</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can call our program like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./t -p13 --quality low --verbose report.pdf</pre>
</div>
</div>
<div class="paragraph">
<p>and get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>p: 13
quality: low
verbose:
Arg: report.pdf</pre>
</div>
</div>
<div class="paragraph">
<p>We specified for <span class="func">initOptParser()</span> that the short options <span class="term">h</span>, <span class="term">v</span> and the long options <span class="term">help</span>, <span class="term">verbose</span>
have no values, but work just like a plain switch. These specifications tells that function, on the other hand,
that all other options do use values, so the numeric value <span class="lit">13</span> after the <span class="term">p</span> options is recognized as value, as well
as the <span class="lit">low</span> value that follows after <span class="term">quality</span>. As the <span class="term">verbose</span> option has no value, <span class="term">report.pdf</span> is recognized as argument.</p>
</div>
<div class="paragraph">
<p>You may still wonder if the <span class="mod">parseopt</span> module supports command, as used in <span class="term">nim c --gc:arc mycode.nim</span>?
Yes this works, we would get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>./t c --gc:arc mycode.nim
Arg: c
gc: arc
Arg: mycode.nim</pre>
</div>
</div>
<div class="paragraph">
<p>The command <span class="term">c</span> is recognized as argument, and in our program we would have to
detect that an argument called just "c" is a command name and not a file name.
To avoid ambiguity, we may have to care not only for the value of arguments, but
also for its position in the command <span class="str">string</span>, maybe by use of an additional
position counter, or maybe we call <span class="func">paramStr(1)</span> to get the first
parameter directly.</p>
</div>
<div class="paragraph">
<p>Note that all the option values are <span class="str">strings</span>, you have to validate these <span class="str">strings</span> yourself, and you may have to convert them
to integers or other data types when required.</p>
</div>
<div class="paragraph">
<p>At the end of this section, we will sketch how an actual program may use the <span class="mod">parseopt</span> module.
We assume that we want to create a tool that can print a single PDF file&#8201;&#8212;&#8201;the complete content
or just a specified page, with a selectable print quality. So the base structure of our program may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/parseopt

proc print =

  var
    pages = "all" # default values
    quality = "medium"
    verbose = false
    filename = ""
    argcount = 0

  var p = initOptParser(shortNoVal = {'h', 'v'}, longNoVal = @["help", "verbose"])
  for kind, key, val in getopt(p):
    case kind
    of cmdLongOption:
      case key
      of "help":
        echo "This tool ...."
        quit(0)
      of "verbose":
        verbose = true
      of "pages":
        pages = val
      of "quality":
        quality = val
      else:
        echo "Invalid long option:", key, " with value ", val
    of cmdShortOption:
      echo key, ": ", val
    of cmdArgument:
      inc(argcount)
      if argcount &gt; 1:
        echo "Too many arguments"
        quit(1)
      filename = key
    else:
      discard

  if argcount == 0:
    echo "missing filename"
    quit(0)
  echo "Printing file: ", filename
  echo "pages: ", pages
  echo "quality:", quality
  echo "verbose mode: ", verbose

print()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we left out the interpretation for the short options, which
should be processed similarly as the long ones. You see that the actual use of the
<span class="mod">parseopt</span> module still requires a lot of code for validation and interpretation
of options and arguments. In part V of the book, we will present the external
cligen package, which further simplifies the command line parsing.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_regular_expressions"><span class="new">Regular Expressions</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <span class="ndef">regular expression</span>, shortened as <span class="ndef">regex</span> or <span class="ndef">regexp</span>, is a
sequence of characters that specifies a search pattern, which is used to find or
replace parts of a string or of a whole text document, or just to validate it. It is
a technique developed in theoretical computer science and formal language theory,
introduced in the 1950s, when the American mathematician Stephen Cole Kleene
formalized the description of a regular language. The use of regular expressions
became popular with Unix text-processing utilities like <span class="ndef">sed</span>, <span class="ndef">grep</span>
and <span class="ndef">awk</span>, were used in early text editors like <span class="ndef">vi</span> and <span class="ndef">emacs</span>
for pattern matching, and are commonly used in modern text editors and word
processing programs in <span class="ndef">find</span> and <span class="ndef">find and replace</span> dialogs.
Different syntaxes for writing regular expressions have existed since the 1980s, one
being the POSIX standard and another, widely used, being the Perl syntax.</p>
</div>
<div class="paragraph">
<p>To demonstrate a first simple example for the usefulness of regular expressions, we
will start with a <span class="var">sed</span> call that can be used to replace all snake case symbols
in a text file with camel case, e.g. convert the symbolic name <span class="var">line_width</span> into
<span class="var">lineWidth</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>sed -i -E 's/_([a-z])/\U\1/g' myfile.txt</pre>
</div>
</div>
<div class="paragraph">
<p>Here the option <span class="var">-E</span> tells the <span class="var">sed</span> program to use the <span class="ndef">extended
regular expressions</span> rather than basic regular expressions, and option <span class="var">-i</span>
specifies to work in place, instead to just print the modified text in the terminal
window. The pattern <span class="code">s/a/b</span> tells it to substitute pattern <span class="var">a</span> by
expression <span class="var">b</span>, and the final <span class="code">/g</span> stands for <span class="ndef">global</span> and tells
<span class="var">sed</span> to do substitutions in the whole file. The actual interesting part is
the search pattern <span class="code">_[a-z]</span>, which specifies the actual underscore character
followed by a single lower case letter. Whenever such a pattern is found, it is
replaced with a capitalized version of the found letter. The <span class="code">/U</span> tells
<span class="var">sed</span> to convert to upper case, and <span class="code">\1</span> refers to the captured text
segment. You may still wonder why <span class="var">[a-z]</span> is enclosed in braces&#8201;&#8212;&#8201;well matches
enclosed in braces are actually captured, so we can refer to the captured letter
later, in this case we refer to the first captured match with <span class="code">/1</span> and apply
<span class="code">/U</span> on it to convert it to upper case.</p>
</div>
<div class="paragraph">
<p>As you see, regular expressions are useful, but difficult to understand and to
remember.</p>
</div>
<div class="paragraph">
<p>Some programming languages like Perl or Ruby have built in support for regular
expressions, and others use external libraries. For interpreted languages like Perl,
Python or Ruby it makes a lot of sense to use regular expressions for parsing strings,
as the regex engines of these languages are generally written in C language, which
leads to the fact that even for very basic string operations like spitting strings
into single tokens or doing simple character replacements, the use of regexes can be
faster than doing it with multiple statements in the interpreted program code. For
compiled languages like Nim, the situation is very different&#8201;&#8212;&#8201;using regexes is fast,
but doing simple things directly in the compiled languages is still much faster. And
Nim provides many other libraries like <span class="var">strscans</span> or <span class="var">parseutils</span>, which
can do even advanced string operations much faster than by use of regular
expressions.</p>
</div>
<div class="paragraph">
<p>So actually the use of regular expressions in Nim is very limited, in most cases
there exists other, simpler and faster solutions. As learning the use of regexes is
not that easy, and it is hard to remember all the details, we may hesitate to try it
at all. But actually for text processing tools like <span class="ndef">sed</span> and <span class="ndef">grep</span>,
and for the use in text editors and word processors regexes are very useful, so it
makes some sense to learn at least the basic use of regular expressions. And when we
learn to use regexes at all, then we can use them in Nim as well.</p>
</div>
<div class="paragraph">
<p>Each character in a regular expression (that is, each character in the string
describing its pattern) is either a
metacharacter,<sup class="footnote">[<a id="_footnoteref_40" class="footnote" href="#_footnotedef_40" title="View footnote.">40</a>]</sup> having a special
meaning, or a regular character that has a literal meaning. For example, in the
regex <span class="code">b.</span>, <span class="var">b</span> is a literal character that matches just 'b', while
<span class="code">.</span> is a metacharacter that matches every character except a newline.
Therefore, this regex matches, for example, <span class="var">b%</span>, or <span class="var">bx</span>, or <span class="var">b5</span>.
Together, metacharacters and literal characters can be used to identify text of a
given pattern or process a number of instances of it. Pattern matches may vary from a
precise equality to a very general similarity, as controlled by the metacharacters.
For example, <span class="code">.</span> is a very general pattern, <span class="code">[a-z]</span> (match all lower
case letters from 'a' to 'z') is less general and <span class="code">b</span> is a precise pattern
(matches just 'b'). The metacharacter syntax is designed specifically to represent
prescribed targets in a concise and flexible way to direct the automation of text
processing of a variety of input data, in a form easy to type using a standard ASCII
keyboard.<sup class="footnote">[<a id="_footnoteref_41" class="footnote" href="#_footnotedef_41" title="View footnote.">41</a>]</sup></p>
</div>
<div class="paragraph">
<p>In this section we will not try to explain all the details of the syntax and semantic
of regular expressions, but only show you how the <span class="mod">regex</span> module is used in principle,
and give a few examples for its use. For details, you should consult the API
documentation of the <span class="mod">regex</span> module, and for concrete use cases you may
additionally consult the Wikipedia article and the various internet resources.</p>
</div>
<div class="paragraph">
<p>The Nim standard library provides two modules for the use of regular expressions,
called <span class="mod">re</span> and <span class="mod">nre</span>, which both are wrappers for the <span class="ndef">PCRE</span>
<span class="ndef">(Perl Compatible Regular Expressions)</span> C library. Additionally, a module called
<span class="mod">regex</span> is available as an external package, which is fully written in Nim
language. These three modules are similar, but their API is different. When you
intend to use <span class="var">re</span> and <span class="var">nre</span> you have to ensure that the PCRE C library
is also installed on your computer. As the external <span class="mod">regex</span> module is written
in pure Nim and is of high quality, we will actually use that one for our examples&#8201;&#8212;&#8201;actually if using one of the two others, it would be not easy to decide which to use.
You may wonder why we present the <span class="mod">regex</span> module already here, as it is not part of the
Nim standard library? Well, a regex library is am important part of each programming
languages, and <span class="var">re</span> and <span class="var">nre</span> are actually included in Nim&#8217;s standard
library. Due to Nim&#8217;s package managers like nimble, using external packages is very
easy, we just have to execute</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install regex</pre>
</div>
</div>
<div class="paragraph">
<p>We will start to demonstrate the use of the <span class="mod">regex</span> module with a very simple example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import regex

let r: Regex = re"\w\d"
let t1: string = "a1"
let t2 = "nim"
var m: RegexMatch
if match(t1, r, m):
  echo "match t1"

if match(t2, r, m):
  echo "match t2"</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the <span class="func">re()</span> function with the search pattern as argument to generate an
instance of a <span class="type">Regex</span> variable. Then we can use the <span class="func">match()</span> function
to match a textual string against this regex. The last argument of the match function
is a variable of <span class="type">RegexMatch</span> type, which captures the matched terms, so that
we can use them later.</p>
</div>
<div class="paragraph">
<p>In our pattern <span class="var">"\w\d"</span> the <span class="var">\w</span> stand for a word character which
includes upper and lower case ASCII letters, and the <span class="var">\d</span> stands for a decimal
digit. So the string <span class="var">t1</span> matches that pattern, but the string <span class="var">t2</span> does
not, as there is no decimal digit following the first letter. In the example from
above, we actually check only if a string matches the pattern, but we do not capture
the matches. So we do not need the RegexMatch variable <span class="var">m</span> at all and could
call the <span class="func">match()</span> function without that parameter. To actually capture a
match, we would have to enclose the subpattern in braces like "\w(\d)" to capture the
digit in case of a successful match.</p>
</div>
<div class="paragraph">
<p>As the next simple example, let us match a string starting with the capital letter A,
followed by an arbitrary number of letters, followed by an integer number. We want to
capture the integer in case of a match:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import regex

let r: Regex = re"A[a-z, A-Z]*(\d+)"
let t1: string = "Alex77"
let t2 = "nim"
var m: RegexMatch
if match(t1, r, m):
  echo "captured: ", m.group(0, t1)

if match(t2, r, m):
  echo "captured: ", m.group(0, t2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To understand the regex pattern, we have to know that we can use <span class="var">*</span>
to specify an arbitrary number of repetitions, and <span class="var">&#43;</span> to specify one or
more repetitions. The initial <span class="lit">A</span> is not a metacharacter and stand for the
literal <span class="lit">A</span>. The content of the square brackets specifies a character class,
<span class="var">a-z</span> specifies the range of lower case letters, <span class="var">A-Z</span> the range of upper
case letters, and the following <span class="var">*</span> indicates an arbitrary number of
repetitions. Finally, the <span class="var">\d</span> stands for a decimal digit, and <span class="var">&#43;</span>
specifies one or more repetitions. As we enclosed the last subpattern in braces, that
group is captured. For a successful match, we can access the capture with the
<span class="func">group()</span> function(, where we have to specify the index number of the capture,
and the actual text string that was used for the match. The fact that we have to
specify the initial text may look a bit strange indeed. For string <span class="var">t1</span>, we get
a successful capture with the result @["7"]. So our actual captured string is
contained in a seq, which is useful when multiple (nested) strings are captured. In
the code from above, we could have used <span class="func">groupFirstCapture()</span> instead to get
directly the first captured string.</p>
</div>
<div class="sect2">
<h3 id="_greedy_matching">Greedy matching</h3>
<div class="paragraph">
<p>Whenever we create regex patterns, we have to care for the fact if sub-matches should
be greedy or not. In most cases, greedy is the default, and we have to take some care
when we need none-greedy behavior. Greedy means just, that the regex engine captures
as many characters as possible, while none-greedy capturing stops the capturing
process early. Indeed, these greedy/none-greedy capturing can be one of the most
demanding tasks when we create larger and complicated patterns. Imagine that for our
above example, we would have used the pattern re"A\w*(\d&#43;)". For the same string
"Alex77" we would then get the output @["7"]. The reason for that is, that
<span class="var">\w*</span> does a greedy processing, eating all but the last decimal digit, which it
left to satisfy <span class="var">/d&#43;</span>. From the API documentation of the <span class="mod">regex</span> module,
we learn that we can specify <span class="var">\w*?</span> instead to get a none-greedy processing, so
both digits are left for <span class="var">\d&#43;</span> and we get again @["77"] as output.</p>
</div>
</div>
<div class="sect2">
<h3 id="_escape_sequences">Escape sequences</h3>
<div class="paragraph">
<p>The use of escape sequences in regex patterns is another difficulty for beginners.
The first problem can be that the Nim compiler may process the escape sequences
already itself, while we intend to left them for the regex engine. We can avoid that
when we use Nim&#8217;s raw strings, e.g. we can use triple quotes when we construct the
pattern from individual strings, as done in our next example. In a regex, we can use
escape sequences to specify special literal characters, we may use <span class="var">\t</span> for a
literal tabulator for example. And finally, we may have to escape some punctuation
characters like <span class="var">*</span>, <span class="var">&#43;</span> or <span class="var">?</span> that have a special meaning for the
regex engine when we intend to use that character as an ordinary literal. For
example, to match a letter followed by a question mark, we have to use a pattern like
<span class="code">"[a-z]\?"</span> or <span class="code">"[a-z][?]"</span>. Inside of a square bracket, we can use the
punctuation characters without the need to escape them.</p>
</div>
<div class="paragraph">
<p>As next example, let us assume that we have to process a text file in which all
lines starts with a name consisting of lower case letters, followed by three decimal numbers.
The name and the three numbers can be separated by spaces, or by commas or
semicolons:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import regex

let h = """\s*[,;]?\s*(\d+)"""
let r: Regex = re("[a-z]+" &amp; h &amp; h &amp; h)
let t1: string = "nim 12;8  ,   17"

var m: RegexMatch
if match(t1, r, m):
  echo "captured: ", m.group(0, t1), " ", m.group(1, t1), m.group(2, t1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To understand the pattern that we use in the above code, we have to know that we can
use <span class="var">\s</span> for a white-space character, so <span class="var">\s</span> matches a single space or a
tabular character. We could have used just a space literal instead, or the [ ]
character class containing just a single space. And we have to know that we can use
<span class="var">?</span> to specify an optional entity. We have split the total pattern into two
parts, where the variable called <span class="var">h</span> stands for the sequence of any number of
white-space, followed optionally by a single comma or a single semicolon, followed
again by any amount of white-space, that is finally followed by at least one decimal
digit. As we want to capture the decimal numbers, the sequence of decimal digits is
enclosed in round brackets. The total regex pattern is constructed by the
subexpression <span class="code">[a-z]</span> for at least one letter, followed three times by the
integer pattern with the allowed separators. Note that we allow any amount of spaces
or tabulators, but only a single comma or semicolon between the different entities.
Note that the <span class="func">match()</span> function of the <span class="mod">regex</span> module always does a full match,
so a single space at the beginning or end of the text string would make the match
fail. We could compensate for that by starting and ending the regex pattern with
"\s*". Or we could use instead of <span class="func">match()</span> the <span class="func">find()</span> function,
which search through the string looking for the first location where there is a
match. When we use <span class="func">find()</span>, we may use the special characters <span class="var">^</span> and
<span class="var">$</span> to match the start or end of the string, that is with <span class="func">find()</span> and
<span class="code">re"\s&#43;$"</span> we could find all strings which have trailing white-space. Note
that <span class="func">find(text, re"^regex$", m)</span> is the equivalent to the <span class="func">match()</span>
function.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">regex</span> module provides us also with two <span class="func">replace()</span> functions,
which we can use to replace matched patterns with literal strings or captured and
modified strings. The first <span class="func">replace()</span> function uses as third argument a
string, which is used for replacements and in which we can refer to captured groups
with the symbols <span class="var">$N</span>, where <span class="var">N</span> is the index of the captured group
starting at one. The second <span class="func">replace()</span> function uses a function as third
argument, that function gets an instance of the <span class="type">RegexMatch</span> type as first
parameter and returns the string replacement. We will use both variants of the
<span class="func">replace()</span> function to create a tiny app that we can use to fix typos in
program and text files: Text files can contain typing errors, which includes two or
more spaces between adjacent words, unneeded trailing white-space at the end of
lines, and the use of <span class="lit">a</span> instead of <span class="lit">an</span> in front of words starting with
a vocal. And program source code may use snake case for names instead of camelCase,
e.g. <span class="var">line_counter</span> instead of <span class="var">lineCounter</span>. We will create a tool that
can fix these four issues&#8201;&#8212;&#8201;ignoring the fact that an actual <span class="lit">a/an</span>
replacement may corrupt program source code. To demonstrate the four issues, we have
created this small test file&#8201;&#8212;&#8201;line three contains two unneeded spaces, and the last
line has some unwanted trailing white space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre># this is a example
var   line_width:  int

echo        line_width</pre>
</div>
</div>
<div class="paragraph">
<p>We will fix these four issues independent of each other, so we will try to find a
regex that matches for each issue, and then use the <span class="func">replace()</span> function to
fix it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import regex, strutils
let fileName = "test.nim"
let trail = re"\s+$"
let aan = re"a(\s+[AEIOUaeiou])"
let space = re"(\S\s)\s+(\S)"
let snake = re"_([a-z])"

proc toUpper(m: RegexMatch, s: string): string =
  when defined(debugThis):
    echo "a: ", s
    echo "b: ", m.group(0)
    echo "c: ", m.group(0)[0]
    echo "d: ", s[m.group(0)[0]]
    echo "e: ", strutils.toUpperAscii(s[m.group(0)[0]])
  return strutils.toUpperAscii(s[m.group(0)[0]])

for l in filename.lines:
  var h = l.replace(trail, "")
  h = h.replace(aan, "an$1") # caution, this is for text files!
  h = h.replace(space, "$1$2")
  h = h.replace(snake, toUpper)
  echo h</code></pre>
</div>
</div>
<div class="paragraph">
<p>We process our file with the issues line by line, using the <span class="func">lines()</span> iterator,
to which we pass a file name and which gives us the individual lines of the file. We
will start with the simplest task, that is removing trailing white-space. The search
pattern for this issue is obviously <span class="code">"\s&#43;$"</span>, that is at least one white-space
at the line end, which we have to replace with an empty string. So we pass this regex
pattern called <span class="var">trail</span> and an empty string literal to the <span class="func">replace()</span>
function. Replacing <span class="lit">a</span> by <span class="lit">an</span> is also easy&#8201;&#8212;&#8201;we search for an
<span class="lit">a</span> followed by white-space and a vocal, for which the regex pattern is the
<span class="var">aan</span> variable in the above code. In this case, we have to preserve the actual
white-space and the vocal, so we enclose these in brackets to capture it. The
replacing string is <span class="code">"an$1"</span>, where <span class="var">$1</span> stands for the captured
white-space and the captured vocal. Replacing too much inter-word space is a bit
more difficult. The actual issue is one white-space followed by one or more
white-space, for which a possible match pattern is "\s\s&#43;". But actually, we do not
want to remove all white-space consisting of more than one character, but only
white-space between words. So multiple white-space at the beginning of a line should
be preserved. One solution is, that we use the metacharacter <span class="var">\S</span>, which
matches all none-white-space characters, and then use this search pattern:
<span class="code">"(\S\s)\s&#43;(\S)"</span>. The pattern starts with a none white-space character,
followed by a white-space, then at least one more whites-space character, and finally
a none white-space character. We capture the two first characters, and the last one.
This way we can replace the whole match with the two captures, and we are done.
Finally, we have to replace underscore characters followed by a lowercase letter with
the capitalized letter. Some tools like <span class="ndef">sed</span> provides the <span class="var">\U</span> to
capitalize a capture, but this is not available for the <span class="mod">regex</span> module. So we
use the <span class="func">replace()</span> variant which uses a <span class="proc">proc</span> as last parameter&#8201;&#8212;&#8201;to that
proc the capture and the original string is passed, and that function should return
the replacement string. The capture which we have to use to catch a snake element is
obvious, just "_([a-z])". We call the converter <span class="proc">proc</span> <span class="func">toUpper()</span>, its
parameters and its return type is specified by the <span class="var">regex</span> API docs. But
unfortunately, the actual structure of the passed <span class="type">RegexMatch</span> instance is not
that detailed described. So we created some conditional <span class="func">echo()</span> statements
inside the body of our <span class="func">toUpper()</span> <span class="proc">proc</span> to show us the structure of the
parameters. When we compile our program with the <span class="term">-d:debugThis</span> option, and
run it, we get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nim c -d:debugThis t.nim

$ ./t test.nim
# this is an example
a: var line_width: int
b: @[9 .. 9]
c: 9 .. 9
d: w
e: W
var lineWidth: int

a: echo line_width
b: @[10 .. 10]
c: 10 .. 10
d: w
e: W
echo lineWidth</pre>
</div>
</div>
<div class="paragraph">
<p>So the last string parameter is always the whole string that was passed as first
argument to <span class="func">replace()</span>, and <span class="var">m.group(0)</span> is a sequence of slices for
the first capture. We need only the first element of this seq, as we have only one
capture, and we use that slice to extract the captured sub-string by use of
<span class="code">s[m.group(0)[0]]</span>. Finally, we apply <span class="func">strutils.toUpperAscii()</span> on this
sub-string to capitalize it, and return that result.</p>
</div>
<div class="paragraph">
<p>When you run the above program, you should get a text file with all issues fixed. You
may redirect the output to a file with <span class="term">"\.t test.nim &gt; newtest.nim"</span> and load
<span class="var">newtest.nim</span> into an editor to prove that the trailing white-space is removed
as well.</p>
</div>
</div>
<div class="sect2">
<h3 id="_final_remarks">Final remarks</h3>
<div class="paragraph">
<p>The use of regular expressions is not that easy, and makes in most cases not much
sense in Nim. Perhaps the largest problem of regular expressions is, that it is hard
to understand patterns that we created some years ago, or that have been created by
other people. And it is difficult to modify that patterns later. Maybe you should
play a bit with regexes yourself now, and come back to this topic when you think that
you need them. In this book, we were only able to give a tiny introduction into the
stuff&#8201;&#8212;&#8201;you will have to carefully study the API docs of the <span class="mod">regex</span> module
and a lot of other resources on the Internet when you should intend to seriously use
them. We should also mention, that while regexes are very powerful, for some tasks
they work not that well, e.g. parsing math expressions with nested braces, or just
skipping nested comments in some source code can be very difficult or even
impossible.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Regular_expression" class="bare">https://en.wikipedia.org/wiki/Regular_expression</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions" class="bare">https://en.wikipedia.org/wiki/Perl_Compatible_Regular_Expressions</a></p>
</li>
<li>
<p><a href="https://www.regular-expressions.info/pcre.html" class="bare">https://www.regular-expressions.info/pcre.html</a></p>
</li>
<li>
<p><a href="https://nitely.github.io/nim-regex/regex.html" class="bare">https://nitely.github.io/nim-regex/regex.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<h1 id="_part_iv_some_programming_tasks" class="sect0">Part IV: Some Programming Tasks</h1>
<div class="openblock partintro">
<div class="content">
In this section, we will present a few simple programming exercises.
</div>
</div>
<div class="sect1">
<h2 id="_sorting">Sorting</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Sorting a sequence or an <span class="type">array</span> of numbers is typically a component of
each computer programming course. While we would not really
code some sorting algorithm for the actual software that we write, but use
the generic sorting algorithm from the standard library, sorting
algorithm can teach us some basic programming skills. When we
sort a small number of items manually, we would typically use selection or
insertion sort intuitively: For selection sort we pick the smallest element and
move it at position one, then pick the next smallest item and move it at position two.
This strategy is easy to implement and works not bad for small quantities. For larger
containers, an algorithm like quicksort or mergesort gives better performance.</p>
</div>
<div class="sect2">
<h3 id="_selection_sort">Selection Sort</h3>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">#[ &lt;--s.len
5
7 &lt;-- i
4 &lt;-- k, x == 4
6 &lt;-- j
3
2 first three entries are already sorted
1
]#

proc selectionSort(s: var seq[int]) =
  var i: int # used to step through the still unsorted range
  var j = 0 # lower bound for still unsorted range
  var k: int # position of currently smallest candidate
  var x: int # and its value

  while j &lt; s.len: # while there is an unsorted section left
    i = j # start with i one above the already sorted range
    x = s[i]; k = i # assume first element is the smallest
    inc(i) # continue with next one in the still unsoprted range
    while i &lt; s.len: # while there are unchecked candidates
      if s[i] &lt; x: # that one is smaller than current candidate
        x = s[i] # remember its value
        k = i # and remember its position
      inc(i) # examine next candidate
    swap(s[j], s[k]) # exchange smallest value with the one currently at position k
    inc(j) # sorted range increased by one

import random
proc main =
  var s: seq[int]
  for i in 0 .. 9:
    s.add(rand(100))
  s.selectionSort
  echo s

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The comment on the top of the above example shows a partly sorted list of <span class="lit">7</span> integer
numbers. The lowest three positions already contains the sorted numbers <span class="lit">1</span> to <span class="lit">3</span>. The
next four positions are still unsorted. For the sorting process we need the three indices
<span class="var">i</span>, <span class="var">j</span>, <span class="var">k</span> and the variable <span class="var">x</span> to store an actual value for the comparison. The index <span class="var">j</span>
is the lower bound for the still unsorted range, <span class="var">j</span> starts at zero, obviously.
The variable <span class="var">x</span> stores the currently smallest value of the still unsorted range, and <span class="var">k</span> is
the index position of that value. Finally, <span class="var">i</span> is a counter that is used to step through all
the values of the unsorted range. The outer loop is executed as long as <span class="var">j</span> is smaller than the length of
the sequence that we want to sort. We set <span class="var">i</span> to the value of <span class="var">j</span>, <span class="var">k</span> to the same value and assume initially
that <span class="var">s[i]</span> is the smallest value from the still unsorted range. That value is stored in <span class="var">x</span>.
Then we execute the inner while loop until we have processed all elements of the
still unsorted range. Whenever we find an element that is smaller than <span class="var">x</span>, we store that position
in <span class="var">k</span> and the value in <span class="var">x</span>. When the inner loop has finished, we exchange the smallest value
with the first element of the still unsorted range. This way, the sorted range increases, and the unsorted
range decreases by one.</p>
</div>
<div class="paragraph">
<p>To test our sorting procedure we generate some random numbers, sort them and print the result.
Selection sort is said to be of order O(n^2), with <span class="var">n</span> being the number of values to sort. So the effort
increases quadratic with the number of values. This is because we have to test all the still unsorted
values just to increase the number of sorted values by one. Selection sort has a natural behavior,
that is, for an already sorted array the test <span class="code">s[i] &lt; x</span> would be always false, and we would have
to do no movement of values in that case. So performance is best for an already sorted or partly sorted list,
and the sorting is stable in the sense that we do not move elements when it is not really necessary.
In one of the following sections, we will discuss the quicksort algorithm, which is not a
stable sorting method: Elements with equal value may be moved with quicksort. For plain
numbers, that does not really matter for the result, as numbers are indistinguishable. But
when we sort objects, maybe persons by age, persons of same age would be exchanged
by quicksort, which may not be desired.</p>
</div>
<div class="paragraph">
<p>Note that the code above is not really optimized for performance yet. One possible improvement
may be to iterate the two loops not from zero to <span class="func">s.len</span>, but in the opposite direction.
In that way, comparison of loop indices with a constant value, zero in this case, could
be used to terminate the loop. Comparison with constants can be faster than comparison with
actual variables, and comparison with zero is generally fastest. Note that we compared indices with <span class="func">s.len()</span>
in above code, which is not that bad, as <span class="func">len()</span> is a field in the <span class="type">seq</span> data structure, so the compiler should be smart
and replace <span class="func">s.len</span> with just a field access without <span class="proc">proc</span> call overhead.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>We started this section with thinking about how we would sort a small quantity of items
lying on the table manually. This strategy is often a good one. Sometimes
it can even help to ask how a child would solve a problem to find a way how to
do it with the computer.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_insertion_sort">Insertion Sort</h3>
<div class="paragraph">
<p>Insertion sort is another simple sorting method, which some
card players like to use:
They hold two sets of cards in their hand, one unsorted set, and one sorted which
is initially empty. They pick one card from the unsorted set and insert it at the right
position in the already sorted set. That action is repeated until the unsorted set is empty.
For our next example we sort our data not in place as we did it in the previous
example, but we generate a new sorted copy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">#[
unsorted     sorted
&lt;-- k
4
7                     3 &lt;-- result.high
5                     2
6                     1
]#

proc insertionSort(s: seq[int]): seq[int] =
  var j: int # current position in the new, sorted range
  var k = s.len # index one above the still unprocessed range
  var x: int # the value we have to insert next
  while k &gt; 0: # as long as we have still unprocessed entries
    dec(k)
    x = s[k]
    j = result.high # top of sorted range
    result.setLen(result.len + 1) # reserve space for one more entry
    while j &gt;= 0 and x &lt; result[j]: # move the already sorted entries up
      result[j + 1] = result[j]
      dec(j)
    result[j + 1] = x # insert x

import random
proc main =
  var s: seq[int]
  for i in 0 .. 9:
    s.add(rand(100))
  echo s.insertionSort

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The commented code in front of the above program code shows at the left the
still unsorted numbers and at the right <span class="lit">3</span> already sorted numbers. For the sorting
process we need two index variables <span class="var">j</span> and <span class="var">k</span>, and one variable to store the actual value that we have to
insert called <span class="var">x</span>. The variable <span class="var">k</span> is used as the index of the top entry of the still unsorted range.
To insert the value <span class="var">x</span> in the already sorted result, we first reserve space for one more entry by
calling <span class="func">setLen()</span> and then iterate over the sorted values and move them one place to the top.
We do that, moving to the top as long as we have not already reached the bottom of the sorted range
and as long as the current entry is larger than the value <span class="var">x</span> which we want to insert.
We take the values from the top of the unsorted range, as that is convenient, but of course we could pick
an arbitrary element from the unsorted range.</p>
</div>
<div class="paragraph">
<p>Insertion sort has O(n^2) cost, as for each element that we take from the unsorted range we have to
iterate over the sorted range to insert it. As we have to move elements before we can insert an element, insertion
sort is slow for larger containers. Selection sort, which is also of O(n^2) should be faster, as it does not
use an expensive shift of many elements.</p>
</div>
<div class="paragraph">
<p>When you look at the example code, you may immediately find two possible improvements:
We do not really need the variable <span class="var">x</span>, as we can just use <span class="var">s[k]</span> instead. The compiler should optimize the
code so that the subscript operator is not executed multiple time for the same index <span class="var">k</span>, so use of <span class="var">s[k]</span> or <span class="var">x</span>
should make no difference for performance. And we call <span class="func">setLen()</span> in the outer loop to increase the
capacity of the result sequence by one each. Of course, setting capacity only one time to the value
of <span class="var">s</span> would suffer, as obviously the result has the same length as our input data. Another possible optimization would be to
take advantage of the fact that the destination sequence is sorted, so that we would not have to do a linear search to find
the insertion position, but we could use a binary search. But that would be more complicated and the benefit would be
not large.</p>
</div>
</div>
<div class="sect2">
<h3 id="_quick_sort">Quick Sort</h3>
<div class="paragraph">
<p>As the name implies, this sorting method is one of the fastest. We will explain it in
some detail with various variants, as it can teach us two important concepts:
Recursion and avoiding recursion by use of a stack container.</p>
</div>
<div class="paragraph">
<p>The idea of the QuickSort algorithm is simple, and the code is also simple and short, but we have to care for some details
like exact index stop positions. Generally sorting seems to be a O(n^2) operation, at least from the two traditional
sorting methods, Insertion- and Selection-Sort it seems to be the case. So doubling the container size seems to increase
the needed sorting time by a factor of four, which is really bad for large <span class="type">arrays</span> or sequences. The trick
of QuickSort is, that instead of sorting a container with <span class="var">n</span> elements, we just sort the first half and the second
half separately, each with approx <span class="var">n / 2</span> entries. This would be faster, as <span class="code">2 * (n/2)^2</span> is only half of <span class="code">(n)^2</span>. And we
do apply this trick in a recursive manner on each halved range, until the range is reduced to only one
or two entries. But to make this work we have to partition the full range in the first half <span class="var">r1</span> so that all
entries of range <span class="var">r1</span> are smaller or equal to a median value <span class="var">x</span>, and so that all entries in the second half
<span class="var">r2</span> are all greater or equal to the median <span class="var">x</span>. Let us consider an example with six numbers:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>5 3 2 8 1 7
1 3 2 8 5 7</pre>
</div>
</div>
<div class="paragraph">
<p>To partition that set of numbers, we have only to exchange the numbers <span class="var">5</span> and <span class="var">1</span>, with the value <span class="var">5</span> or <span class="var">4</span>
being a possible median. Exchanging numbers in an <span class="type">array</span> or a <span class="type">seq</span> is a fast O(n) operation, we
have to iterate the container only once. The problem is finding the median. For picking a perfect
median we would need a sorted container so that we could pick the center entry. But of course,
our container is unsorted, if it would be sorted our work would be done already. Note that
even summing up all entries and dividing by <span class="var">n</span> would give only the average value, not the median.
Average and median can be very different, e.g. for many small numbers and a few very large ones.
But in practice picking an estimation for the median, maybe picking one by random from the full
range or picking the center entry is good enough. That choice will not really halve the whole
range in each step, but on average it splits the range in two parts with not too different size.
This works really well when the input data looks like random numbers, but it may work bad
in some unlikely cases when all the input numbers are equal or are already sorted.
Already sorted can indeed occur&#8201;&#8212;&#8201;for that case, picking the center elements of the range gives
the perfect median, so we will choose that strategy.</p>
</div>
<div class="paragraph">
<p>Partitioning the full range is basically very simple: We move from the left to right with index <span class="var">i</span> and stop
when we find a value <span class="var">s[i]</span> that is not smaller than our median <span class="var">x</span>. And we do the same from the right to the
left with index <span class="var">j</span> until we find a value that is not greater than median <span class="var">x</span>. After we have done that,
we can just exchange the values at <span class="var">s[i]</span> and <span class="var">s[j]</span> and continue. We continue until <span class="var">i</span> is close to <span class="var">j</span>. The difficult part
is to handle this terminating condition exactly, that is, to stop exactly at the right position so
that the first half really contains all entries with value less or equal to median <span class="var">x</span>, and that the second half contains only
entries with value equal or greater than median <span class="var">x</span>. To make it more clear: Such a partition decouples the two
ranges. Sorting the whole range would result in the same state as sorting first and second range on its own.</p>
</div>
<div class="paragraph">
<p>For writing our actual sorting function we use the fact that Nim like most modern programming languages support
recursion, that is, a function can call itself again. We saw at the beginning of the book a few examples of that.
So we can pass our function the initial full container, then the function can partition the container in
first and second half and call itself again on the two parts. This way the actual size of the ranges to sort
decreases, and finally recursion stops when the range contains only one or two elements. For size one
we have to do nothing at all, but for size two we may have to exchange the two elements if the order is wrong.</p>
</div>
<div class="paragraph">
<p>A naive implementation may create for each function call two new sequences for the two parts, partition
the initial sequence by inserting the values in one of the new shorter sequences, call itself
on both parts and finally join the parts and return it&#8201;&#8212;&#8201;as result or as var parameter.
But that would be really slow. A much simpler and faster solution is, when we work all the
time on the same container, and just tell the function which range the function has to work on.
So we pass to the function the whole sequence and two integers <span class="var">a</span> and <span class="var">b</span> which tell it the range to process:
s[a], s[a &#43;1] .. s[b].</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from algorithm import isSorted, sort
import std/monotimes

proc qsort(s: var seq[int]; a, b: int) =
  assert a &gt;= 0 # a .. b is the range that we have to sort
  assert b &lt; s.len
  assert b - a &gt; 1 # it may work for smaller intervals, but this is the intended use case
  let x = s[(a + b) div 2] # use element from center of range
  # var x = s[a] div 2 + s[b] div 2 # bad, x may be smaller than smallest entry in range
  # x = s[a .. b].min # worst case test!
  var i = a
  var j = b
  while true:
    while s[i] &lt; x:
      inc(i)
    while s[j] &gt; x:
      dec(j)
    if i &lt; j:
      swap(s[i], s[j])
      inc(i)
      dec(j)
    else:
      break
  dec(i)
  inc(j)
  assert i &gt;= a
  assert j &lt;= b
  if i - a &gt; 1: # still more than 2 entries
    qsort(s, a, i)
  elif i - a &gt; 0: # two entries
    if s[i] &lt; s[a]: # wrong order
      swap(s[i], s[a])
  if b - j &gt; 1: # and the same for the other half
    qsort(s, j, b)
  elif b - j &gt; 0:
    if s[b] &lt; s[j]:
      swap(s[b], s[j])

proc quickSort(s: var seq[int]) =
  if s.len == 2 and s[0] &gt; s[1]: swap(s[0], s[1])
  if s.len &gt; 2:
    qsort(s, 0, s.high)

import random
proc main =
  var s: seq[int]
  var start: MonoTime
  randomize() # give us different random numbers for each program run
  for i in 0 .. 1e5.int:
    s.add(rand(1e8.int))
  for i in 0 .. 9:
    s.shuffle
    s.quickSort
    assert(isSorted(s))
  for i in 0 .. 1e7.int:
    s.add(rand(1e8.int))
  start = getMonotime()
  s.quickSort
  echo getMonotime() - start
  assert(isSorted(s))
  s.shuffle
  start = getMonotime()
  s.sort()
  echo getMonotime() - start
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The function <span class="func">qsort()</span> does the entire work. It is called from the function <span class="func">quicksort()</span>
passing it the whole sequence and the interval to sort. For the first
call, the interval is the complete content of the <span class="type">seq</span>, from <span class="func">s.low</span> to <span class="func">s.high</span>.
Function <span class="func">qsort()</span> first asserts that the range is valid, that is that
<span class="var">b &gt; a</span> and that both indices are valid positions in the sequence s. That
check makes it easier to find stupid errors, the assert is automatically
removed when we compile finally with -d:release.
We set the iterating indices <span class="var">i</span> and <span class="var">j</span> to the interval boundaries <span class="var">a</span> and <span class="var">b</span> and
enter an outer loop. In that outer loop, we let run <span class="var">i</span> and <span class="var">j</span> to the center of the interval
as long as the actual entry at the position <span class="var">i</span> or <span class="var">j</span> belongs in the range. If both
inner loops have stopped, we swap the entries at position <span class="var">i</span> and <span class="var">j</span>. As
positions <span class="var">i</span> and <span class="var">j</span> contain now again valid entries, we can move both indices
one step further to the center. If <span class="var">i</span> and <span class="var">j</span> becomes the same, we are done.
Unfortunately, both may stop too late, so we move both one position back
after the outer loop has terminated.
You may create a small example with pen and paper to recognize
how the indices behave in detail and why fixing by one is necessary.
The remainder of the <span class="func">qsort()</span> <span class="proc">proc</span> is really easy: For both partitions we check if the interval size is
still larger than two entries, in that case we call <span class="func">qsort()</span> again to continue with
partition and sorting. But if the size is two entries, then we just <span class="func">swap()</span> them if the order is
wrong. If the size of the range is just one, we have nothing to do at all.</p>
</div>
<div class="paragraph">
<p>We test our <span class="func">quicksort()</span> <span class="proc">proc</span> by calling it from another <span class="proc">proc</span> called <span class="func">main()</span>.
In that <span class="func">main()</span> we fill a <span class="type">seq</span> with random integer values, and <span class="func">shuffle()</span>
and <span class="func">sort()</span> it a few times. <span class="func">Shuffle()</span> reorders the entries by random. After our call
of <span class="func">quicksort()</span> we call <span class="func">isSorted()</span> from Nim&#8217;s standard library to check the success
of our sorting. After these tests, which does some warm up of the CPU for us, we
add more random entries and again sort and test it, while we record the needed time
with module <span class="mod">monotimes</span> as we did before in the Timers section. To get a feeling
about the performance of our sorting <span class="proc">proc</span> we <span class="func">shuffle()</span> again and sort this time
with the <span class="func">sort()</span> <span class="proc">proc</span> from Nim&#8217;s <span class="mod">algorithm</span> module. <span class="func">Sort()</span> from <span class="mod">algorithm</span> module
uses currently another sorting method called merge sort, which has the advantage that
it is a stable sorting algorithm, but it may be a bit slower than quicksort. And <span class="func">sort()</span>
from algorithm may pass a <span class="func">cmp()</span> <span class="proc">proc</span> around, which may cost some performance, while
our plain, non-generic <span class="proc">proc</span> compares entries directly with &lt; and &gt; operators. So it is not
surprising that our <span class="proc">proc</span> is a bit faster.</p>
</div>
<div class="paragraph">
<p>You may wonder if it is really necessary to pass the sequence <span class="var">s</span> for each call of <span class="func">qsort()</span>, as
for all time the same <span class="type">seq</span> is used. Indeed, Nim support nested <span class="proc">procs</span>, so we could just make
<span class="func">qsort()</span> <span class="proc">proc</span> local to <span class="func">quicksort()</span> <span class="proc">proc</span> and let <span class="func">qsort()</span> work (as a closure) on the s variable
of <span class="proc">proc</span> <span class="func">quicksort()</span>. But this does not compile currently, sequences can not be used by
closure <span class="proc">procs</span>. But actually passing the sequence to <span class="proc">proc</span> <span class="func">qsort()</span> should be only a minimal overhead.</p>
</div>
<div class="paragraph">
<p>One general concern of QuickSort is that the sort is not stable. When we sort an already sorted
sequence again, entries with same value may move. For plain numbers that is not really an issue,
we do not really notice it, as we can&#8217;t mark a number in some way, plain numbers are
indistinguishable just as elementary particles like electrons and protons are. But when we sort a container
with objects by some field, then we notice that objects with same value for sorting may move.
The other concern of QuickSort is a general problem of recursive algorithm: Each new call of a
proc generates some stack usage, as <span class="proc">proc</span> parameters may be passed on the stack and because
the <span class="proc">proc</span> may allocate its local data variables on the stack. So many nested calls may need a very
large stack, the program may fail with a stack overflow error. Typically, we have no real troubles with
stack overflow, as for each partition the size of the two new partition is nearly halved, so
that process stops soon. But imagine someone prepares a special data set for our sort <span class="proc">proc</span>. That
data may be prepared in such a fashion that at the center of each range, where we pick the estimated median value from,
always an extreme values is stored. So our partition would work very badly, in each step we would get a new range with only
one element, and one with <span class="var">n - 1</span> elements. So the recursion dept would go very deep, and the performance would
be very bad also. Preparing such a data set would be difficult, but possible in theory. One way to protect
us from that attack would be to select the median by random. But unfortunately all strategies different from
picking the leftmost, the center, or the rightmost entry as median are not very fast and
make the whole sorting significantly slower. Note that the strategy of not picking a single element
as median, but calculating a median value, works generally, but has some shortcomings:
<span class="code">s[a] div 2 &#43; s[b] div 2</span> would not work when both values are odd, as we then would get a value
that can be smaller than all of our entries and our function would fail. We would have to add
one to the average value when both summands are odd, and that fix cost performance again.
And calculating the average by <span class="code">(s[a] &#43; s[b]) div 2</span> could generate an overflow when both summands are large.</p>
</div>
<div class="paragraph">
<p>Because of the stack size restrictions, we have a good motivation to show how we can
replace recursion with plain iteration, when we provide a "buffer" variable that acts as a data stack.
For each new partition of our data, we have to put only the two bounds <span class="var">a</span> and <span class="var">b</span> on that data stack, which
is not that much as a recursive <span class="proc">proc</span> would put on the real computer stack. The modifications to our code
from above are tiny:<sup class="footnote">[<a id="_footnoteref_42" class="footnote" href="#_footnotedef_42" title="View footnote.">42</a>]</sup></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from algorithm import isSorted, sort
import std/monotimes

proc qsort(s: var seq[int]) =
  var stack: seq[(int, int)]
  var maxStackLen: int
  stack.add((s.low, s.high))
  while stack.len &gt; 0:
    if stack.len &gt; maxStackLen:
      maxStackLen = stack.len
    var (a, b) = stack.pop
    assert(a &gt;= 0 and b &lt; s.len and b - a &gt; 1)
    let x = s[(a + b) div 2]
    var (i, j) = (a, b)
    while true:
      while s[i] &lt; x:
        inc(i)
      while s[j] &gt; x:
        dec(j)
      if i &lt; j:
        swap(s[i], s[j])
        inc(i) ; dec(j)
      else:
        break
    dec(i); inc(j)
    # assert(i &gt;= a and j &lt;= b) caution, this is not always true!
    if i - a &gt; 1:
      stack.add((a, i))
    elif i - a &gt; 0:
      if s[i] &lt; s[a]:
        swap(s[i], s[a])
    if b - j &gt; 1:
      stack.add((j, b))
    elif b - j &gt; 0:
      if s[b] &lt; s[j]:
        swap(s[b], s[j])
  echo "Max Stack Length: ", maxStackLen

proc quickSort(s: var seq[int]) =
  if s.len == 2 and s[0] &gt; s[1]: swap(s[0], s[1])
  if s.len &gt; 2:
    qsort(s)

import random
proc main =
  var s: seq[int]
  var start: MonoTime
  randomize()
  for i in 0 .. 1e5.int:
    s.add(rand(1e8.int))
  for i in 0 .. 9:
    s.shuffle
    s.quickSort
    assert(isSorted(s))
  for i in 0 .. 1e7.int:
    s.add(rand(1e8.int))
  start = getMonotime()
  s.quickSort
  echo getMonotime() - start
  assert(isSorted(s))
  s.shuffle
  start = getMonotime()
  s.sort()
  echo getMonotime() - start
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We added a variable called <span class="var">stack</span>, which is a <span class="type">seq</span> which stores integer <span class="type">tuples</span>.
The <span class="func">qsort()</span> <span class="proc">proc</span> first stores the borders of the whole <span class="type">seq</span> on the <span class="var">stack</span>,
and then executes a loop which takes in each iteration a set of two
borders from the <span class="var">stack</span> and processes that range. It may sound a bit strange that we
start by putting the entire range onto the stack and then took it from the <span class="var">stack</span>
immediately at the start of the loop. But that makes more sense when we look at the
bottom of the <span class="func">qsort()</span> <span class="proc">proc</span>. Instead of recursively calling <span class="func">qsort()</span> again, we just put
the borders of the two new partitions on the stack and continue. The whole process
terminates when the stack becomes empty, as then all partitions are processed.
Note that the actual partition code and the <span class="func">main()</span> <span class="proc">proc</span> are still unchanged.
We added a <span class="var">maxStackLen</span> variable to get a feeling how large our stack has to be.
Actually, not that large, as the partition size shrinks in a logarithmic way.
So we could replace the <span class="type">seq</span> that we use now as a stack with a plain <span class="type">array</span>, as
sequences have the same overhead and the <span class="func">add()</span> is slower than plain index access.
But how can we prepare for worst case attacks? Indeed, there exists a simple
solution: Worst case occurs, when first we put a tiny one element range on the <span class="var">stack</span> and then
the large one, as we would continue with the large one in the same way in the next loop
iteration. The other way round would be fine. If we put the tiny range on the stack last, next iteration would pick that
one and iteration would stop immediately or at least very soon, as ranges drops to two or one entry.
When an iteration for a range stops, all ranges pushed to the <span class="var">stack</span> are removed already again, so
total <span class="var">stack</span> size will never become large. So the trick is to just sort the partitions in a way that we
put the larger partition first on the stack, and the smaller partition second. So next
iteration picks the smaller one and the whole process stops soon. This way a stack <span class="type">array</span>
of <span class="lit">64</span> entries should be enough, as max needed <span class="var">stack</span> size should be <span class="code">log2(2^64)</span> to sort
a <span class="type">seq</span> with <span class="lit">2^64</span> entries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from algorithm import isSorted, sort
import std/monotimes

proc qsort(s: var seq[int]) =
  var stack: array[64, (int, int)]
  var stackPtr: int
  var maxStackLen: int
  stack[0] = (s.low, s.high)
  while stackPtr &gt;= 0:
    if stackPtr &gt; maxStackLen:
      maxStackLen = stackPtr
    let (a, b) = stack[stackPtr]; dec(stackPtr)
    assert(a &gt;= 0 and b &lt; s.len and b - a &gt; 1)
    let x = s[(a + b) div 2]
    var (i, j) = (a, b)
    while true:
      while s[i] &lt; x:
        inc(i)
      while s[j] &gt; x:
        dec(j)
      if i &lt; j:
        swap(s[i], s[j])
        inc(i); dec(j)
      else:
        break
    dec(i); inc(j)
    # assert(i &gt;= a and j &lt;= b) caution, this is not always true!
    var c, d: int
    for u in 0 .. 1:
      if (i - a &gt; b - j) == (u == 0):
        (c, d) = (a, i)
      else:
        (c, d) = (j, b)
      if d - c &gt; 1:
        inc(stackPtr) # inc before push!
        stack[stackPtr] = (c, d)
      elif d - c &gt; 0:
        if s[c] &gt; s[d]:
          swap(s[c], s[d])
  echo "Max Stack Length: ", maxStackLen

proc quickSort(s: var seq[int]) =
  if s.len == 2 and s[0] &gt; s[1]: swap(s[0], s[1])
  if s.len &gt; 2:
    qsort(s)

import random
proc main =
  var s: seq[int]
  var start: MonoTime
  randomize()
  for i in 0 .. 1e5.int:
    s.add(rand(1e8.int))
  for i in 0 .. 9:
    s.shuffle
    s.quickSort
    assert(isSorted(s))
  for i in 0 .. 1e7.int:
    s.add(rand(1e8.int))
  start = getMonotime()
  s.quickSort
  echo getMonotime() - start
  assert(isSorted(s))
  s.shuffle
  start = getMonotime()
  s.sort()
  echo getMonotime() - start
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of processing the two new partitions at the end of the
<span class="func">qsort()</span> <span class="proc">proc</span> each, we apply only one processing code block
now, which we execute in a loop that is executed two times.
At the start of that loop, we assign the actual interval boundaries
to the variables <span class="var">c</span> and <span class="var">d</span>. That assignment depends on the actual loop index <span class="var">u</span>,
so that we push the larger range always first on the stack.
You may modify the condition <span class="code">u == 0</span> to <span class="code">u != 0</span> and observe what happens
to the maximum used stack dept. We could write that condition also with
a boolean loop variable and a <span class="op">xor</span> operator like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">    for u in [false, true]:
      if (i - a &gt; b - j) xor u:</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_we_should_not_believe_all_what_we_think">We should not believe all what we think</h4>
<div class="paragraph">
<p>And what seems to be correct. Our non-recursive function seems to be fine, and indeed inverting the
<span class="code">== (u == 0)</span> condition makes a difference for random data, so it is correct?
Well, when we think about it again the next day we may get some doubts. The outer loop
pops one entry from the stack, but in the loop we may push two new entries. Pushing the
smaller interval helps, as we continue with the smaller interval in the next iteration
and remove it so from the stack. But the net effect is still that we push one interval
onto the stack for each iteration, and for the worst case that interval shrinks only by one
in each iteration. So it should still not work.</p>
</div>
<div class="paragraph">
<p>But well, there are rumors that solutions exists. When we think about it, we may ask
our self if we can just continue with one interval in a loop and push only the other one
on the <span class="var">stack</span>. And indeed, that is possible, and this time we did testing for worst case
scenario:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">from algorithm import isSorted, sort
import std/monotimes

proc qsort(s: var seq[int]) =
  var stack: array[64, (int, int)]
  var stackPtr: int = -1 # empty
  var maxStackLen: int
  var a = s.low
  var b = s.high
  while true:
    if b - a == 1: # done with actual interval, but we may have to swap()
      if s[a] &gt; s[b]:
        swap(s[a], s[b])
    if b - a &gt; 1: # interval has still more than two entries, so continue
      discard
    elif stackPtr &gt;= 0: # get next interval from stack
      (a, b) = stack[stackPtr]; dec(stackPtr)
    else:
      break # all done
    if stackPtr &gt; maxStackLen:
      maxStackLen = stackPtr
    assert(a &gt;= 0 and b &lt; s.len and b - a &gt; 1)
    let x = s[(a + b) div 2]
    # let x = s[a .. b].max # worst case test! Slow, test with smaller container size.
    var (i, j) = (a, b)
    while true:
      while s[i] &lt; x:
        inc(i)
      while s[j] &gt; x:
        dec(j)
      if i &lt; j:
        swap(s[i], s[j])
        inc(i); dec(j)
      else:
        break
    dec(i); inc(j)
    # assert(i &gt;= a and j &lt;= b) caution, this is not always true!
    if (i - a &lt; b - j): # put large interval on stack and cont. directly with the small
      swap(i, b)
      swap(a, j)
    if i - a &gt; 1: # interval has more than two entries, needs further processing
      inc(stackPtr) # inc before push!
      stack[stackPtr] = (a, i)
    elif i - a &gt; 0: # two entries, we may have to swap()
      if s[a] &gt; s[i]:
        swap(s[a], s[i])
    (a, b) = (j, b) # the smaller interval, we continue with that one
  echo "Max Stack Length: ", maxStackLen

proc quickSort(s: var seq[int]) =
  if s.len == 2 and s[0] &gt; s[1]: swap(s[0], s[1])
  if s.len &gt; 2:
    qsort(s)

import random
proc main =
  var s: seq[int]
  var start: MonoTime
  randomize()
  for i in 0 .. 1e5.int:
    s.add(rand(1e8.int))
  for i in 0 .. 9:
    s.shuffle
    s.quickSort
    assert(isSorted(s))
  for i in 0 .. 1e7.int:
    s.add(rand(1e8.int))
  start = getMonotime()
  s.quickSort
  echo getMonotime() - start
  assert(isSorted(s))
  s.shuffle
  start = getMonotime()
  s.sort()
  echo getMonotime() - start
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The modifications to the code are again tiny. We use an outer <span class="code">while true:</span> loop, which
continues with interval <span class="code">a .. b</span> until its size is less than three entries. Then it
<span class="func">pops()</span> a new interval from the stack.
At the end of that outer loop, we put only one interval on the stack and directly
continue with the other interval. But which interval should we push on the stack, and which
one should we process directly further in the outer loop?
The solution is to process the smaller interval in the outer loop further, as we are soon
done with it. For processing that smaller interval, we may push some more ranges
onto the <span class="var">stack</span>, but we come to interval sizes of less than three soon, and then we start popping
intervals from the <span class="var">stack</span>. And when we are done with that, we pop
the larger interval again from the <span class="var">stack</span>. This way the worst case, where we pick each time a
min or max value as median, has the smallest <span class="var">stack</span> consumption, that is one entry.
We push the large interval with size <span class="var">n - 1</span> on the stack, continue with the tiny one entry
range, which signals that we are done with that interval in the next loop iteration and
so the just pushed <span class="var">n - 1</span> interval is popped from the stack again. This continues in this way. Slow, but
minimal stack consumption.</p>
</div>
<div class="paragraph">
<p>From the above code it becomes clear that for our initial recursive <span class="func">qsort()</span> function,
changing the order in which we process the partitions would not really help, as
we continue the recursion until all is processed. There is no intermediate <span class="func">pop()</span>
involved.</p>
</div>
<div class="paragraph">
<p>Perhaps you still wonder why the tiny inner loops use the conditions
<span class="code">while s[i] &lt; x:</span> and not <span class="code">while s[i] &lt;= x:</span> as we said that both partitions
are allowed to contain the median element. Well, with &lt;= there would be no guaranteed
stop condition for the interval, so indices could run out of the interval. Using
an additional condition like <span class="code">and i &lt;= b</span> would make it slower. Another possible modification
would be to not use inner while loops at all. Tiny while loops with only one simple
termination condition are fast, but the inner while loops would always terminate fast for random data.
So we may try instead something like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">    while true:
      if s[i] &lt; x:
        inc(i)
      elif s[j] &gt; x:
        dec(j)
      else:
        if i &lt; j:
          swap(s[i], s[j])
          inc(i); dec(j)
        else:
          break
    dec(i); inc(j)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may try that variant yourself, or maybe look for other variants in internet sources or
textbooks. Our intention in this section was not to present a perfect sorting function,
but to teach you some basic coding strategies and related traps.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_merge_sort">Merge Sort</h3>
<div class="paragraph">
<p>Initially we did not intend to discuss the actual MergeSort algorithm at all, as it is a bit more complicated and
whenever we may have seen a sketch of it somewhere, it is generally
not easy to remember details.<sup class="footnote">[<a id="_footnoteref_43" class="footnote" href="#_footnotedef_43" title="View footnote.">43</a>]</sup>
But MergeSort is indeed an important algorithm, it is used by default in Nim&#8217;s standard library
and as we have discussed QuickSort already in some detail, we should be prepared for
MergeSort now. When we regard the name Merge, which is some form of joining multiple sources to one destination,
we may begin to remember the idea of MergeSort: The trick of QuickSort was, that we tried to split
in a recursive manner the set of all container elements into two subsets, which we can process separately.
That improves performance, as sorting is basically an O(n^2) process, and <span class="code">2 * (n/2)^2</span> is only half of <span class="var">n^2</span>.
For QuickSort we partitioned the initial range into two ranges <span class="var">a</span> and <span class="var">b</span>, where all elements of range <span class="var">a</span> are
less or equal to a median element <span class="var">x</span>, and all elements of range <span class="var">b</span> are greater or equal to the median <span class="var">x</span>.
That way we decoupled the two ranges, we can sort <span class="var">a</span> and <span class="var">b</span> independently and get a fully sorted range.
MergeSort starts also with splitting the full range into two parts, but it really only splits, without
any form of rearrangement. Then it continues with sorting each part independently.
That sounds strange at first, as we get two sorted parts <span class="var">a</span> and <span class="var">b</span>, but of course we can not
simply append one to the other. The idea of the whole algorithm become clear immediately
when we think about how we can find the smallest elements of the joined content from <span class="var">a</span> and <span class="var">b</span>.
That one is obviously the smallest value of <span class="var">a</span>, or the smallest value of <span class="var">b</span>, <span class="code">min(a, b) = min(min(a), min(b))</span>.
But when <span class="var">a</span> and <span class="var">b</span> are already sorted, then the minimal value of each is the first element, and so
one of these elements at index position zero is the smallest one for <span class="var">a</span> and <span class="var">b</span> joined. And this condition
holds even when we pick and remove the smallest element from <span class="var">a</span> or <span class="var">b</span>.</p>
</div>
<div class="paragraph">
<p>So the basic algorithm is this: Split the entire container in parts <span class="var">a</span> and <span class="var">b</span>, sort them separately. Then create a new, sorted
container by iterative picking the first elements from <span class="var">a</span> or <span class="var">b</span>, which ever is actually the smaller one.</p>
</div>
<div class="paragraph">
<p>Unfortunately it seems to be impossible to sort the initial container in place in this way, as
we would always take elements from the front from both and put them at the front of the destination, so
that newly inserted elements could overwrite still unprocessed elements. So we will
try to give a sketch of a very slow unoptimized algorithm which creates and returns a new sorted container first
to lean the fundamental idea of the algorithm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc msort(s: seq[int]; a, b: int): seq[int] =
  assert(b - a &gt;= 0)
  if b - a == 0:
    result.add(s[a])
    return
  elif b - a == 1:
    var (a, b) = (s[a], s[b])
    if a &gt; b:
      swap(a, b)
    result.add(a)
    result.add(b)
    return
  result = newSeq[int](b - a + 1)
  var sl = result.len
  assert b - a &gt; 1
  var m = (a + b) div 2
  assert m &gt;= a
  assert m &lt; b
  var s1, s2: seq[int]
  s1 = msort(s, a, m)
  var (i, j) = (a, m)
  s2 = msort(s, m + 1, b)
  assert s1.len + s2.len == result.len
  var (k, l) = (m + 1, b)
  var l1 = s1.high
  var l2 = s2.high
  while sl &gt; 0:
    dec(sl)
    if l1 &gt;= 0 and l2 &gt;= 0: # merge
      if s1[l1] &gt; s2[l2]:
        result[sl] = s1[l1]
        dec(l1)
      else:
        result[sl] = s2[l2]
        dec(l2)
    else: # plain copy
      while l1 &gt;= 0:
        result[sl] = s1[l1]
        dec(sl); dec(l1)
      while l2 &gt;= 0:
        result[sl] = s2[l2]
        dec(sl); dec(l2)

proc mergeSort(s: seq[int]): seq[int] =
  if s.len &lt; 2:
    return s
  msort(s, s.low, s.high)

import random, algorithm
proc main =
  var s, st: seq[int]
  randomize()
  for i in 0 .. 9:
    s.add(rand(100))
  st = s
  echo s.mergeSort
  assert(s.mergeSort == st.sorted)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above is indeed not very complicated, the most daunting task is
to get all the indices right. Due to the involved recursion and the fact that we
have to do the sorting of the two parts first, before we can join them, debugging
would be not easy. So we added many asserts to early find stupid errors.</p>
</div>
<div class="paragraph">
<p>The function <span class="func">mSort()</span> starts by checking if the range to sort has only one or two
entries, and handles this simple case directly. Then we allocate the result
sequence, find the center position <span class="var">m</span> of the interval <span class="var">a</span> and <span class="var">b</span> and sort
the intervals <span class="code">a .. m</span> and <span class="code">m &#43; 1 .. b</span> each into a new sequence <span class="var">s1</span> and <span class="var">s2</span>.
We have decided that we will do the merging of <span class="var">s1</span> and <span class="var">s2</span> into the result
sequence from the back, starting with the largest elements. This way, we can
count down to zero, which is a bit faster and simpler. We do an actual merging as long as
<span class="var">s1</span> and <span class="var">s2</span> have still elements left. As we do the merge from end to start, we have to always pick the largest
element from <span class="var">s1</span> or <span class="var">s2</span>. If we have used all the elements from at least one of the
sequences <span class="var">s1</span> or <span class="var">s2</span>, then there is nothing more to merge, we can just copy
the remaining elements from the other <span class="type">seq</span> that has elements left.
Of course, the above example is very slow, as we allocate the result
and additional the sequences <span class="var">s1</span> and <span class="var">s2</span>, and as we have to copy many elements.</p>
</div>
<div class="paragraph">
<p>When we now think again about the problem, we get the feeling
that allocating three sequences is really too much. When we regard
both, in place sorting and sorting with a return value, we may discover
that in place sorting allows us to partly reuse the passed container, and we have
only to allocate one additional <span class="type">seq</span> with half the size of the passed container.
We copy the second half of the passed container into a newly allocated <span class="type">seq</span>, and then can merge
values from the new <span class="type">seq</span> and from the first half of the passed <span class="type">seq</span> to positions starting at the end
of the passed <span class="type">seq</span>, without overwriting values that we still have to process.</p>
</div>
<div class="paragraph">
<p>This way our code becomes even shorter and basically simpler&#8201;&#8212;&#8201;we have only to
care very exactly to use the right index positions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc msort(s: var seq[int]; a, b: int) =
  assert(b - a &gt;= 0)
  if b - a == 0:
    return
  elif b - a == 1:
    if s[a] &gt; s[b]:
      swap(s[a], s[b])
    return
  var m = (a + b) div 2
  assert(m &gt;= a and m &lt; b and b - a &gt; 1)
  var sh: seq[int] = s[(m + 1) .. b]
  var ls = b + 1
  msort(s, a, m)
  msort(sh, sh.low, sh.high)
  var lh = sh.high
  var lm = m
  while ls &gt; a:
    dec(ls)
    if lh &lt; 0:
      assert ls == lm
      break
    elif  lm &lt; a:
      while lh &gt;= 0:
        s[ls] = sh[lh]
        dec(ls); dec(lh)
    else:
      if sh[lh] &gt; s[lm]:
        s[ls] = sh[lh]
        dec(lh)
      else:
        s[ls] = s[lm]
        dec(lm)

proc mergeSort(s: var seq[int]) =
  msort(s, s.low, s.high)

import random, algorithm, std/monotimes
proc main =
  var s: seq[int]
  var start: MonoTime
  randomize()
  for i in 0 .. 1e5.int:
    s.add(rand(1e8.int))
  for i in 0 .. 9:
    s.shuffle
    s.mergeSort
    assert(isSorted(s))
  for i in 0 .. 1e7.int:
    s.add(rand(1e8.int))
  var st = s
  start = getMonotime()
  s.mergeSort
  echo getMonotime() - start
  start = getMonotime()
  st.sort()
  echo getMonotime() - start
  assert s == st
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the merging process, we
first test if one of the source areas is already exhausted. If all entries
from the newly allocated <span class="type">seq</span> <span class="var">sh</span> are consumed, then we can just stop, as
continuing would only copy elements of the passed container with
equal index positions. And if all elements from the first half of the passed container are
consumed, we can just copy the elements from <span class="var">sh</span> into the passed <span class="key">var</span> container.
Only if both sources have elements to process left, we have to do the actual
merging.</p>
</div>
<div class="paragraph">
<p>When we run the program above, we may find that it is about 50% slower
than our QuickSort functions. The reason for that may be that we have to
allocate the temporary <span class="type">seq</span> <span class="var">sh</span>, fill it with values, and merge it back.
And the total memory consumption is high, our recursive function calls consumes
for the buffers <span class="var">sh</span> totally the same amount as the initial container. The advantage of MergeSort is, that
there is no worst case as for QuickSort, as we have not to select a median but
can split the range just at the center, and that the sort is stable, that is
merging does not exchange the position of elements with same value.footnote[
Well to ensure this, we may have to check the actual merge condition, do we have
to test for &lt; or &lt;=. Currently, we do not really care for that, but it is clear
and well known that merge sort can be stable.]</p>
</div>
<div class="paragraph">
<p>When we think a bit more about the algorithm above and maybe try to
sketch the recursive steps for a short sequence with pencil and paper we
get the strong feeling that the additional buffer <span class="var">sh</span> is only needed for the
merging step, and as the merging process occurs from bottom to top
(containers with only one or two entries are returned immediately, which
are merged to a larger section, and these larger section is again merged &#8230;&#8203;)
one single buffer could be used. So we have modified our example again.
Now the <span class="func">quicksort()</span> <span class="proc">proc</span> allocates the buffer <span class="type">seq</span> with half the size of the actual
data container, and we pass that buffer recursively to the <span class="func">qsort()</span> <span class="proc">proc</span> and
use it for the merging only. We call recursively <span class="func">qsort()</span> on the first and second half
of the full range that we have to sort, then copy the sorted second half into
the buffer and merge the first half and the buffer into the final
location.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc msort(s, sh: var openArray[int]; a, b: int) =
  assert(b - a &gt;= 0)
  if b - a == 0:
    return
  elif b - a == 1:
    if s[a] &gt; s[b]:
      swap(s[a], s[b])
    return
  var m = (a + b) div 2
  assert (m &gt;= a and m &lt; b and b - a &gt; 1)
  msort(s, sh, a, m)
  msort(s, sh, m + 1, b)

  var ls = b + 1
  var lh = b - m - 1
  var lm = m
  #sh[sh.low .. lh] = s[m + 1 .. b]
  for i in 0 .. lh: # a bit faster
    sh[i] = s[m + 1 + i]
  while ls &gt; a:
    dec(ls)
    if lh &lt; 0:
      assert ls == lm
      break
    elif  lm &lt; a:
      while lh &gt;= 0:
        s[ls] = sh[lh]
        dec(ls); dec(lh)
    else:
      if sh[lh] &gt; s[lm]:
        s[ls] = sh[lh]
        dec(lh)
      else:
        s[ls] = s[lm]
        dec(lm)

proc mergeSort(s: var seq[int]) =
  if s.len == 0: return
  var sh = newSeq[int](s.len div 2)
  msort(s, sh, s.low, s.high)

import random, algorithm, std/monotimes
proc main =
  var s: seq[int]
  var start: MonoTime
  randomize()
  for i in 0 .. 1e5.int:
    s.add(rand(1e8.int))
  for i in 0 .. 9:
    s.shuffle
    s.mergeSort
    assert(isSorted(s))
  for i in 0 .. 1e7.int:
    s.add(rand(1e8.int))
  var st = s
  start = getMonotime()
  s.mergeSort
  echo getMonotime() - start
  start = getMonotime()
  st.sort()
  echo getMonotime() - start
  assert s == st
main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>An additional tiny performance improvement results from the fact that we now pass the <span class="type">seq</span> <span class="var">s</span>
and the buffer <span class="var">sh</span> as <span class="type">openArrays</span>. This is generally a good idea, as we can so sort
<span class="type">arrays</span> also with the same sorting <span class="proc">proc</span>, and it improves performance, as
this way the actual data buffer is directly passed to the <span class="func">qsort()</span> <span class="proc">proc</span>, while passing
a <span class="type">seq</span> means that we pass the opaque <span class="type">seq</span> structure which contains a pointer to the
actual data. In the example above, we do not only call <span class="func">isSorted()</span> to prove
our result, but we really sort a copy of our data with a sorting routine from Nim&#8217;s standard lib
to ensure that our result is not only sorted data, but that it is indeed based on the
actual values. That is a good idea, because although the algorithm is simple, getting
some indices wrong may give us wrong results.</p>
</div>
<div class="paragraph">
<p>Our recursive merge sort routine is really not that bad. It does a fast, stable sort and
needs only a single buffer of half the size of our actual data. As the interval
size is halved in each recursion step, the max recursion depth should be only <span class="lit">64</span>
for a gigantic container with <span class="lit">2^64</span> elements. As the recursion occurs in a dept first
fashion, that is <span class="func">msort()</span> calls itself until range size is only one or two elements, then
recursion continues in other branches of the whole sorting three, there should be
never more than <span class="func">log2(n)</span> actual recursion steps stored on the CPU stack.
Non-recursive, iterative merge sort algorithm exists, but converting the
recursive algorithm in an iterative one is not that simple as for the QuickSort case.
The reason is that <span class="func">qsort()</span> has first to partition the input range, then call
<span class="func">msort()</span> on both subranges and finally do the merging. We will not try
to present in this book an iterative <span class="func">msort()</span>, which you may find in textbooks or somewhere on the Internet,
as that would be a bit too much for an introducing course.</p>
</div>
<div class="paragraph">
<p>We did the QuickSort and the MergeSort in a top-down fashion, that is we split
the initial container in two subpartitions and continue in this way until
we have only ranges with one or two entries, and then do the merging from bottom
to top. For MergeSort we could just start from the bottom joining single adjacent elements
to sorted tuples of two entries, when done with that merging the tuples of two to sorted tuples of <span class="lit">4</span> and
so on. This would work really well when the initial number of elements in our container is
a power of two, and it would work well iterative without recursion. Unfortunately, in most
cases the container size is not a power of two, so such a bottom up merge sort needs
some math to get all the ranges sizes right. But the bottom up process has a big disadvantage
on modern hardware, as it has no locality for element access operations: We would iterate
repeatedly over all the container entries in sequential order, so the CPU cache can
not support our element access operation that well.</p>
</div>
<div class="paragraph">
<p>Other known sorting algorithms are
the easy, funny and slow BubbleSort, or Shell- and Shaker-Sort. But these are not used
in practice. As an exercise, you can try to make our QuickSort or MergeSort generic and pass a <span class="func">cmp()</span>
proc, and make it work for sorting in ascending and descending order. Or, you may
try to fall back to selection sort when the partitions become small. In theory
SelectionSort is faster for ranges of only a few dozen elements, but when we
have to do a decision which one to use inside the <span class="func">qsort()</span> or <span class="func">msort()</span> <span class="proc">proc</span>, then this decision
compensates generally the advantages again, so that the net benefit is tiny.
Of course, we would have to test all of our sorting <span class="proc">procs</span> for special cases, that is
for <span class="type">seqs</span> of length <span class="lit">0</span>, <span class="lit">1</span> or two, and for sequences with all entries equal, all inversely sorted
or presorted. And we would have to check how performance is when we sort not containers containing plain data
like numbers, but containers which elements are <span class="key">objects</span>, <span class="str">strings</span> or again <span class="type">arrays</span> or sequences.
<span class="str">String</span> sorting is special for various reasons: <span class="str">strings</span> in Nim
are an opaque <span class="key">object</span> with a pointer to the actual data. This is some indirection, and the actual data
can be located somewhere in the RAM in a cache unfriendly manner, so the actual comparison process
can be slow. Swapping of strings is also special, as <span class="func">swap()</span> generally just does a pointer exchange for
the data areas, and does not have to copy the actual data. For sorting containers where each entry is
an <span class="type">array</span> (of characters), swap would have to copy the data content.</p>
</div>
<div class="paragraph">
<p>Finally, we should mention that the Python language uses a complicated sorting algorithm
called TimSort which is a smart mix of various sorting algorithm.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Timsort" class="bare">https://en.wikipedia.org/wiki/Timsort</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_some_small_exercises"><span class="recent">Some small exercises</span></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_removing_adjacent_duplicates">Removing adjacent duplicates</h3>
<div class="paragraph">
<p>Removing duplicates from containers is a common programming task.
When we know in advance, that we do not want to store the same data value
more than once, and that the order of the stored values does not matter, then
we may consider using some form of <span class="type">sets</span> or hash <span class="type">sets</span>. If insertion order matters, then
the standard library may provide some form of ordered or sorted <span class="type">sets</span> for us. But for this exercise we  will assume
that we have values stored in a sequence, and we want to remove the adjacent duplicates.
A typical use case for that is when we have stored a path of 2D or 3D positions. When we insert, move or
delete a position value, it may occur that we get duplicates, with zero spatial distance between the two
neighbored positions. In that case, it is generally desired to remove the duplicate. A similar use case
may be a text file stored as a sequence of words, where adjacent duplicated words may indicate
a typo. To keep our example short and simple, we will use as data type a <span class="type">seq</span>[int]. Using other data
types or creating a generic <span class="proc">proc</span> should be not difficult for the reader.</p>
</div>
<div class="listingblock">
<div class="content">
<pre># [1, 4, 4, 2, 5, 5, 5, 1] ==&gt; [1, 4, 2, 5, 1]</pre>
</div>
</div>
<div class="paragraph">
<p>Before you continue looking at our provided example code, you may think about this task yourself,
perhaps take a piece of paper and a pencil and sketch the algorithm. It is really not difficult, maybe too
easy for you when you have carefully studied the preceding sections of the book or when you have already
some programming experience. When we create a <span class="proc">proc</span> for this task, we have to decide first if the <span class="proc">proc</span> should work on the
passed in <span class="type">seq</span> in-place or if it should return the processed result and leave the original data unchanged.
Often returning a copy is easier, but for our task the common use case seems to be more an algorithm that works in place.
So we will provide the in place algorithm here and leave the version returning a processed result as an optional
exercise to the reader. Note that returning a processed copy needs to allocate the <span class="type">seq</span> for the result, and potentially later the memory management system has to free
the result data again, which is some additional effort. So we may guess that the in-place <span class="proc">proc</span> is faster, as long as we do not really need
the copy. When needed, we can use the <span class="func">dup()</span> macro of the <span class="mod">sugar</span> module to use our in place <span class="proc">proc</span> as one that works on a copy and returns this copy, without modifying the input.</p>
</div>
<div class="paragraph">
<p>The basic idea of our algorithm is that we iterate through the whole <span class="type">seq</span> and pick an element at the current location
only if it is not identical to the preceding element. For the case that our <span class="type">seq</span> is empty or contains only one single element, we have obviously noting to do
and can return immediately. So our code may look like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc deTwin(s: var seq[int]) =
  if s.len &lt; 2:
    return
  var i, d: int # d is the position where we copy the elements that we want to keep
  while i &lt; s.high:
    inc(i)
    if s[d] != s[i]:
      inc(d)
      s[d] = s[i]
  s.setLen(d + 1)

var h = @[1, 4, 4, 2, 5, 5, 5, 1]
detwin(h)
echo h # [1, 4, 2, 5, 1]</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use two positions, the actual position in the input data denoted as <span class="var">i</span>, and the destination
position <span class="var">d</span>. Both start with the default value zero. To keep full control over the iterating process,
we do not use a for iterator in this case, but a plain while loop for the index of the actual position.
In the while loop body, we compare the value at the current index position <span class="var">s[i]</span> with the value that
we picked before, which is <span class="var">s[d]</span>. If the values are not identical, we pick the current value <span class="var">s[i]</span>, otherwise
we just skip it. With picking a value, we mean that we copy it from index position <span class="var">i</span> to index position <span class="var">d</span>.
Of course, this can only work, when <span class="var">d</span> is never larger than <span class="var">i</span>, as otherwise we would destroy our
still unprocessed input data at positions <span class="var">s[i &#43; 1]</span>. The loop body is really simple, but getting the indices
right needs some care: We have to ensure that <span class="var">i</span> and <span class="var">d</span> starts at the right positions, that we increase
<span class="var">i</span> and <span class="var">d</span> when necessary, and that the loop terminates when all input data is processed. Obviously,
the first comparison should compare <span class="var">s[d == 0]</span> with <span class="var">s[i == 1]</span>. So <span class="var">d</span> and <span class="var">i</span> can get initial values zero each, when
we increase <span class="var">i</span> already each time at the start of the loop. The destination position <span class="var">d</span> starts with zero, as
we always accept the first element, and <span class="var">d</span> increases only when we have accepted one more element.
The loop is executed as long as <span class="var">i</span> is less than <span class="var">s.high</span>. Finally, we have to set the new length of <span class="var">s</span> to <span class="var">d &#43; 1</span>.
The value <span class="var">d &#43; 1</span> results from the fact that we always accept the first element, and for each more accepted
element <span class="var">d</span> is increased, so the total number of accepted elements is <span class="var">d &#43; 1</span>. The careful reader may wonder
if the first two lines of the <span class="proc">proc</span>, where we test for the trivial case, are really necessary, or if
these cases can be covered by our while loop already. Well, generally it is a good idea to avoid unnecessary tests
for trivial cases when possible, as that tests may increase code size and cost some tiny bit of performance.
But in this case we have two trivial cases&#8201;&#8212;&#8201;empty seq and seq with only one element, which can be not covered well
with a loop with only one simple termination condition. And of course, we should try to make the condition
of the while loop as simple as possible, that is, avoiding additional boolean conditions with <span class="op">and</span> or <span class="op">or</span> operators
for best performance. Further, you may wonder if our picking strategy is really optimal, as for a <span class="type">seq</span>
with no adjacent duplicates we still copy all the elements. Yes indeed, but for the general case with
duplicates we have to do the copy, and such a copy operation is really fast. And additional tests with an <span class="key">if</span>
condition should cost some performance. Maybe we could have used two loops in the <span class="proc">proc</span> body, one that
just accepts elements without a copy operation as long as no duplicates are found, and a second loop like the
one from above which then has to do copy operations to move the elements to the front. You may try that
yourself and measure the performance for various input data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_array_difference">Array difference</h3>
<div class="paragraph">
<p>The difference of two arrays or sequences A and B is the set (A - B) of values that are contained in A but not in B.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[1, 2, 5, 2, 9, 7, 0] - [7, 4, 1, 10, 7] == [2, 5, 2, 9, 0]</pre>
</div>
</div>
<div class="paragraph">
<p>Actually such difference of array or seq containers is not needed that often, that is why that function may not be provided by the
Nim standard library.<sup class="footnote">[<a id="_footnoteref_44" class="footnote" href="#_footnotedef_44" title="View footnote.">44</a>]</sup>
Building such kind of differences is much easier and faster with sets or hash sets, so whenever possible we should
use these containers from the beginning when we know in advance that we have to build differences.
But sometimes we just have arrays or sequences, and then we may notice that we require the difference. When the order of the elements does not matter,
we may just convert both containers to sets or hash sets, build the difference and then possibly convert that difference back to a
seq. But there are use cases where we really want to work with array or seq containers, maybe because we want to iterate over the container,
want that values can be contained multiple times or always keep the insertion order.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s create an algorithm to do this task. A naive strategy would be to iterate over container A and delete each element that is also contained in B.
But that would be slow, and may not work at all, as deleting elements while we iterate over the seq does generally not work at all.
We will create a <span class="proc">proc</span> called <span class="op">`-`</span> which can be used as an operator to build the difference of two arrays or sequences and which returns
the difference as a new seq, and a <span class="op">`-=`</span> <span class="proc">proc</span> which removes the elements of <span class="var">b</span> from <span class="var">a</span> in place and is also used as an operator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sets

proc `-`*[T](a, b: openArray[T]): seq[T] =
  let s = b.toHashSet
  result = newSeq[T](a.len)
  var i = 0
  for el in a:
    if el notin s:
      result[i] = el
      inc(i)
  result.setLen(i)

proc `-=`*[T](a: var seq[T]; b: openArray[T]) =
  let s = b.toHashSet
  var i, j: int # both start with default value zero
  while i &lt; a.len:
    if a[i] notin s:
      a[j] = a[i]
      inc(j)
    inc(i)
  a.setLen(j)

proc main =
  let a = [1, 2, 5, 2, 9, 7, 0]
  let b = [7, 4, 1, 10, 7]
  echo a - b # @[2, 5, 2, 9, 0]
  echo b - a # @[4, 10]

  var x = @a
  x -= b
  echo x # @[2, 5, 2, 9, 0]

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make the lookup for elements contained in <span class="var">b</span> fast, we convert <span class="var">b</span> to a <span class="type">hash set</span>, for which lookup time is in principle
independent of the size of the container, which is called O(1) in the big O notation. We make the two <span class="proc">procs</span> generic and
use the data type <span class="type">open array</span> for the two passed arguments so that our <span class="proc">procs</span> can be used for arrays as well as for sequences.
The exception is the first var parameter of the <span class="op">`-=`</span> <span class="proc">proc</span>, which has to be a seq obviously, as arrays have a fixed size and can not shrink.
For the <span class="op">`-`</span> <span class="proc">proc</span> we pre-allocate the returned <span class="var">result</span> variable with a size of <span class="var">a.len</span>, so that we can avoid re-allocations.
Then we iterate over <span class="var">a</span> with a for loop, and copy the current element to the result seq when the value in not contained
in the hash set. We use the subscript operator <span class="op">[]</span> to copy the picked elements at position <span class="var">i</span> in the <span class="var">result</span> seq, which is faster than
starting with an empty <span class="var">result</span> seq and appending the picked elements. As we initialize the <span class="var">result</span> seq with the size
of container <span class="var">a</span>, we have finally to call <span class="code">result.setLen(i)</span> to shrink the size to the number of actually picked elements.
The presented <span class="op">`-=`</span> <span class="proc">proc</span> is a bit more complicated, as we process seq <span class="var">a</span> in place. We use an approach similar
as we did in the <span class="func">deTwin()</span> <span class="proc">proc</span> in the previous section, that is, we use two index positions <span class="var">i</span> and <span class="var">j</span>, and copy elements from current position <span class="var">i</span>
to position <span class="var">j</span> if the value is not contained in the lookup set. Again, finally we have to set the size of seq <span class="var">a</span> to the
number of picked elements.</p>
</div>
<div class="paragraph">
<p>While the two presented <span class="proc">procs</span> may be actually useful in some cases, they are more presented as an exercise here.
As a smart user of the Nim forum showed us, we can get a very similar behavior by use of the <span class="func">filter()</span> <span class="proc">proc</span> in
combination with the <span class="op">=&gt;</span> operator of the <span class="mod">sugar</span> module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import sequtils, sets, sugar

let a = [1, 2, 5, 2, 9, 7, 0]
let b = [7, 4, 1, 10, 7]

let bSet = b.toHashSet()
echo a.filter((x) =&gt; x notin bSet)</code></pre>
</div>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://forum.nim-lang.org/t/7753" class="bare">https://forum.nim-lang.org/t/7753</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_binary_search">Binary search</h3>
<div class="paragraph">
<p>Maybe you can remember that some decades ago your parents have used phone books
and dictionaries build of paper sheets, filled with printed text sorted alphabetically?
Well, that alphabetically ordering was done with a purpose: When searching for a name or
a word, we could just open the book somewhere in the middle. If the name or word that we searched for
was ordered alphabetically before the content of the current page, then we continued searching
for that term in the lower half, otherwise in the upper half. That procedure was continued
until the searched entry was found, or until it was observed that it was not available at all.
This type of search in an ordered data set is called <span class="ndef">binary search</span>, <span class="ndef">half-interval search</span>, <span class="ndef">logarithmic</span> search or <span class="ndef">binary chop</span>.
As each repetition halves the remaining data set, it is much faster than a linear search in unordered
data.<sup class="footnote">[<a id="_footnoteref_45" class="footnote" href="#_footnotedef_45" title="View footnote.">45</a>]</sup></p>
</div>
<div class="paragraph">
<p>To use this type of search strategy on the computer, we store our data sorted in an array or a seq.
Creating a <span class="proc">proc</span> to do the search is basically very easy, but we have to care for some details:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"># 1 2 3 4 5 6 7 8 # search for v == 7
# a     p       b
#         a p   b
proc binarySearch(s: openArray[int]; v: int): int =
  var a, b, p: int
  a = s.low
  b = s.high
  while a &lt;= b:
    p = (a + b) div 2
    if v &gt; s[p]: # continue search in the upper partition
      a = p + 1
    elif v &lt; s[p]: # continue search in the lower partition
      b = p - 1
    else: # we have a match
      return p
  return -1 # indicate no match

var d = [1, 3, 5, 7, 11, 13]

for i in 0 .. 15:
  let res = binarySearch(d, i)
  if res &gt;= 0:
    echo "Found value ", i, " at position ", res</code></pre>
</div>
</div>
<div class="paragraph">
<p>To keep our example code as simple as possible, we do our search on an ordered array or seq of integers.
The value which we search for is passed as the second integer argument to the <span class="proc">proc</span> called <span class="func">binarySearch()</span>.
The first three lines of the example program shows some example data consisting of the ordered numbers
<span class="var">1 .. 8</span>. Here we use a consecutive sequence of numbers, but the actual numbers are fully arbitrary, as long as
the sequence is ordered by the value of the numbers in ascending order. Let <span class="var">a</span> be the index of the lowest number in the seq, and
<span class="var">b</span> be the index of the largest number. If the number we search for is contained in the seq, then that number must
be located at an index position greater or equal to <span class="var">a</span> and an index position less or equal to index position <span class="var">b</span>. For the index position <span class="var">p</span> near the
center, the obvious choice is <span class="code">(a &#43; b) mod 2</span>. For our example, we assume that we search for a value of <span class="var">7</span>. The first
index position of <span class="var">p</span> is <span class="code">(0 &#43; 7) div 2</span>, which is <span class="var">3</span> containing value <span class="var">4</span>, which is lower than the searched value <span class="var">7</span>.
So we would have to continue our search in the upper half, setting the new lower bound of the range to
search to <span class="var">p</span> or <span class="var">p&#43;1</span>. The upper boundary remains unchanged for this case, and we continue with a new value <span class="code">p = (a &#43; b) mod 2</span>.</p>
</div>
<div class="paragraph">
<p>The program code follows this strategy in a straight way.
We start with <span class="var">a == s.low</span> and <span class="var">b == s.high</span>, and the loop continues as long as
<span class="code">a &lt;= b</span>. Note that we use as new boundaries not the value of <span class="var">p</span>, but <span class="var">p &#43; 1</span> if we continue
with the upper half, and <span class="var">p - 1</span> when we continue with the lower half of our data. We can do
that offset of one, as we have investigated position <span class="var">p</span> already. This offset of one does not only speed up
things, as the new interval is smaller by one this way, but actually guarantees that the
interval size permanently shrinks and the algorithm terminates always. Without that offset, for the
case <span class="var">b == (a&#43;1)</span> we would get a value <span class="var">p == (a &#43; a &#43; 1) mod 2</span>, which is again <span class="var">a</span>, and we might set the new <span class="var">a</span> then to <span class="var">p</span>,
which is again the previous <span class="var">a</span>. So the range would not always shrink, and our algorithm would not really terminate
for some data values. You may test that yourself when you remove the offset&#8201;&#8212;&#8201;the algorithm would not terminate
for some data. And finally. you should try to make that <span class="proc">proc</span> generic, and then maybe search for a word
in an ordered list of words.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Click to see a possible solution</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc binarySearch[T](s: openArray[T]; v: T): int =
  var a, b, p: int
  a = s.low
  b = s.high
  while a &lt;= b:
    p = (a + b) div 2
    if v &gt; s[p]: # continue search in the upper partition
      a = p + 1
    elif v &lt; s[p]: # continue search in the lower partition
      b = p - 1
    else: # we have a match
      return p
  return -1 # indicate no match

var d = ["Algol", "Basic", "C", "D", "Elexir", "Erlang", "F#", "Haskell"] # sorted!

for i in ["Oberon", "Nim", "Basic", "Ada", "Erlang"]:
  let res = binarySearch(d, i)
  if res &gt;= 0:
    echo "Found value ", i, " at position ", res</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>References</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Binary_search_algorithm" class="bare">https://en.wikipedia.org/wiki/Binary_search_algorithm</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_integer_to_string_conversion">Integer to string conversion</h3>
<div class="paragraph">
<p>Have you ever asked yourself what actually is happening when we print the value of an integer
variable on the screen, perhaps by use of the <span class="func">echo()</span> procedure? Before <span class="func">echo()</span> can print the value,
the integer has to be converted to a text string somehow. Some people may think that this conversion
is trivial. But as we know already that in our computer all the data is stored in abstract binary form,
we know better. But maybe there is some magic available to do this task? Well, when we regard
the existence of C libs or the Nim standard library as that magic solution, then the answer is yes.
But in this section we will assume that we will not use a C library or a function of the Nim standard
library for the conversion of integers to strings, but do it our self. Indeed, this conversion task is an interesting
exercise, from which we can learn a lot, much more than from using a gaming lib and moving some sprites over
the screen. Even when you already know how to do it, you may learn some new.
We will start with the question, how we can convert an int <span class="var">i</span> with a numeric value <span class="code">0 &lt;= i &lt;= 9</span> to a single character
digit matching this value, and then we will present a first
procedure to convert larger integers to strings. After that we will try to improve that first procedure, we will make it
generic and will investigate which problems may occur on restricted hardware like small microcontrollers and embedded systems.</p>
</div>
<div class="paragraph">
<p>As there is no magic available, let us recall how we can print the characters <span class="lit">0 .. 9</span>: Well,
first, we have to remember that the 256 ASCII characters maps directly to the integers <span class="lit">0 .. 255</span>, e.g. the character <span class="lit">A</span> is mapped
to the integer value <span class="lit">65</span>. We can use the conversion functions <span class="func">int()</span> or <span class="func">ord()</span>, and <span class="func">char()</span> to convert between the two data types,
where these conversion functions does no real work at all, the content of the variable is just interpreted as a different type.
That is, a plain cast would do the same for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var i: int8 = 65
echo char(i)
echo cast[char](i)
var c: char = 'A'
echo ord(c)
echo int8(c)
echo cast[int8](c)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>A
A
65
65
65</pre>
</div>
</div>
<div class="paragraph">
<p>The same conversions work of course for all the 256 ASCII characters, which includes the decimal
digits <span class="lit">0 .. 9</span>. So one way to print the 10 digits is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var startPos = int('0')
var i: int
while i &lt; 10:
  stdout.write(char(startPos + i))
  inc(i)
stdout.write('\n')</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works, because the 10 decimal digits follow each other in the ASCII table. As we can not
remember the position of the digit '0' in that table, we get the position by int('0').
Note that int('0') and ord('0') are basically the same here, we have no real preference and use both alternately.
The <span class="func">ord()</span> function is generic, always returns an int and works for ordinal types, enums with holes and distinct ordinal types,
while the int() functions
have the advantage that we have them for different sizes like int8() and also for unsigned results.
We strongly hope that you know well the difference between the int value <span class="lit">0</span> and the
decimal character digit <span class="lit">'0'</span>&#8201;&#8212;&#8201;if not, you may read again the section about characters in part II
of the book, see <a href="#_characters">Characters</a>.</p>
</div>
<div class="paragraph">
<p>With these introductions, you may already have an idea how we can get the decimal digit
for the lowest decimal place of an arbitrary integer value <span class="var">v</span>: <span class="code">char(v mod 10 &#43; ord('0'))</span>.
This works, because <span class="code">v mod 10</span> is the numeric value of the lowest decimal place, that is a value
between <span class="lit">0</span> and <span class="lit">9</span>, and when we add <span class="func">ord('0')</span> we get the corresponding position in the ASCII table.
Finally, we use <span class="func">char()</span> to convert that numeric value to a char data type, which is only a plain cast,
the compiler reinterprets the bit pattern as a character. So we are mostly done. To get the following digits,
we just divide the initial integer value by ten to move all one position to the right, and then we
continue with the initial step. We repeat that until the division by ten gives zero, then we are done.
That division by ten may be still confusing for you&#8201;&#8212;&#8201;we know that in decimal notation a division by ten
is a shift right, but why does that work for a number which is stored in binary form in the computer memory?
Indeed, it is a bit confusing. The division by ten works, because it is a pure mathematical, abstract division operation,
fully independent of the actual representation of the number. Imagine you have a number in the range <span class="lit">10 .. 19</span>.
Now divide that number by ten. Independent how the number is stored, we will get a new number in the range
<span class="lit">0 .. 9</span>, and that value we can convert to a digit with the method shown above.</p>
</div>
<div class="paragraph">
<p>So following this strategy, we may get a first <span class="func">intToStr()</span> procedure that may look like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc intToStr(a: int): string =
  var v = a
  while true:
    result.add(char(v mod 10 + ord('0')))
    v = v div 10
    if v == 0:
      break

echo intToStr(0)
echo intToStr(1234)
echo intToStr(12345678901234.int)
echo intToStr(int.high)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As output, we would get</p>
</div>
<div class="listingblock">
<div class="content">
<pre>0
4321
43210987654321
7085774586302733229</pre>
</div>
</div>
<div class="paragraph">
<p>Not that bad, but unfortunately we get the digits in reversed order. And for
negative numbers it would not work yet. But that can be easily fixed.
What the above code does should be obvious from the discussion before:
We copy the passed integer argument <span class="var">a</span> into a local variable <span class="var">v</span> of the same data type, so that we can modify it,
and in the while loop body we extract the lowest digit and then divide the value by ten to shift it down to the right.
We have to use a <span class="code">while true:</span>
loop with a break statement, because we need at least one loop execution to get at least
one digit, but Nim does not support repeat loops as known from languages like Pascal.
In the loop body, we apply the discussed operation to get the digit of the lowest place, then
divide the actual value by ten and continue, as long that value is not already zero.
When it is zero, we can leave the loop, as we do not intend to print leading zeros.</p>
</div>
<div class="paragraph">
<p>Creating a <span class="proc">proc</span> that prints the digits in the correct order and that can print the minus
sign for negative values is straight forward:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc intToStr(a: int): string =
  if a == int.low:
    return "-9223372036854775808"
  var v = a.abs
  var i: int
  var res: array[20, char]
  while true:
    res[i] = char(v mod 10 + ord('0'))
    v = v div 10
    inc(i)
    if v == 0:
      break
  if a &lt; 0:
    res[i] = '-'
    inc(i)
  result = newString(i)
  let j = i - 1
  while i &gt; 0:
    dec(i)
    result[j - i] = res[i]

echo intToStr(0)
echo intToStr(1234)
echo intToStr(int.high)
echo intToStr(-0)
echo intToStr(-1234)
echo intToStr(int.low + 1)
echo intToStr(int.low)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use an array of character for temporary storing the decimal places, and finally
copy the digits into the <span class="var">result</span> string. We pre-allocate the string with the correct size, and
use the subscript operator <span class="op">[]</span> instead of <span class="func">add()</span> to insert the digits for performance reasons.
Initially we create a copy <span class="var">v</span> with positive sign of the passed integer argument <span class="var">a</span>, and when the
argument was initially negative, then we add an additional minus sign to the temporary array,
which is finally also copied to the result string. All this is not difficult, we have only to care that we get all
the indices right. A tiny problem is, that when the passed integer argument has the value <span class="func">low(int)</span>, then applying
<span class="func">abs()</span> would generate an overflow error, see section <a href="#_binary_numbers">Binary Numbers</a> in part II of the book if you forgot it. We fix for that
by returning just the correct string for that unique negative value for now.</p>
</div>
<div class="paragraph">
<p>The above <span class="proc">proc</span> looks not that bad, but maybe we can improve it, maybe we can avoid the
temporary array? The actual difficulty is, that we do not know how many total digits
the integer argument will require in advance, and so it is impossible to position
all the digits at the correct position in the result string. A possible solution is to use
a function that gives us the number of decimal places of an integer number. Indeed, we have such a function
available, it is <span class="func">math.log10()</span>. Remember, log10(1) is zero, log10(10) is one, log10(100) is two and so on.
So basically what we need. The logarithm function is not that slow on modern desktop computers, so
it should be OK to use it. At the end of this section, we will consider how we may replace it for tiny
microcontrollers which do not provide an FPU. The improved intToStr() <span class="proc">proc</span> may look like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import math

proc intToStr(a: int): string =
  if a == int.low:
    return "-9223372036854775808"
  var v = a.abs
  var i, j: int
  if v &gt; 0:
    i = math.log10(v.float).int
  if a &lt; 0:
    j = 1
    inc(i)
  result = newString(i + 1)
  result[0] = '-'
  while i &gt;= j:
    result[i] = char(v mod 10 + ord('0'))
    v = v div 10
    dec(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <span class="proc">proc</span> is very similar to the one before. We call <span class="func">log10()</span> to get a measure for
the number of needed digits. Remember that the logarithm is undefined for the
argument value zero, for that value we use the default value <span class="lit">i == 0</span>. Actually,
in all cases <span class="lit">i &#43; 1</span> is the total number of digits that we have to generate&#8201;&#8212;&#8201;for the case that we
have to generate a minus sign we increase <span class="var">i</span> by one. We pre-allocate a <span class="var">result</span> string
with <span class="var">i &#43; 1</span> positions, and put a minus sign at position zero, which is overwritten in the while
loop when the argument was not negative. As we know the total number of digits of our number,
we can use the variable <span class="var">i</span> to put the digits at the correct positions in the while loop.
The careful reader may wonder if <span class="code">log10(v.float).int</span> will really work for sure
for all integer arguments of <span class="var">v</span>, or if we better should round the argument like
<span class="code">log10(v.float &#43; 0.5).int</span>. Indeed, with that rounding, we should be safe.</p>
</div>
<div class="paragraph">
<p>The next task is to avoid the initial test for <span class="lit">int.low</span>. We really should remove that special
case when we prepare to make the <span class="proc">proc</span> generic later. A possible solution is, that we work
with <span class="type">uint64</span> instead with <span class="type">int</span> in the <span class="proc">proc</span> body, as in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import math

proc intToStr(a: int): string =
  var v: uint64
  if a == int.low:
    v = uint64(-(a + 1)) + 1
  elif a &lt; 0:
    v = uint64(-a)
  else:
    v = uint64(a)
  var i, j: int
  if v &gt; 0:
    i = math.log10(v.float + 0.5).int
  if a &lt; 0:
    j = 1
    inc(i)
  result = newString(i + 1)
  result[0] = '-'
  while i &gt;= j:
    result[i] = char(v mod 10 + ord('0'))
    v = v div 10
    dec(i)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we add 1 to int.low, then we can invert the sign, and convert the value to <span class="type">unit64</span>.
To the <span class="type">uint64</span> value, we have to add again <span class="lit">1</span> to get the initial sequence of digits.
And now we can make the <span class="proc">proc</span> generic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import math

proc intToStr(a: SomeInteger): string =
  var v: uint64
  when a is SomeSignedInt:
    if int(a) == int.low:
      v = uint64(-(a + 1)) + 1
    elif a &lt; 0:
      v = uint64(-a)
    else:
      v = uint64(a)
  else:
      v = uint64(a)
  var i, j: int
  if v &gt; 0:
    i = math.log10(v.float + 0.5).int
  when a is SomeSignedInt:
    if a &lt; 0:
      j = 1
      inc(i)
  result = newString(i + 1)
  result[0] = '-'
  while i &gt;= j:
    result[i] = char(v mod 10 + ord('0'))
    v = v div 10
    dec(i)

echo intToStr(0)
echo intToStr(1234)
echo intToStr(int.high)
echo intToStr(-0)
echo intToStr(-1234)
echo intToStr(int.low)

echo intToStr(0.uint8)
echo intToStr(123.uint8)
echo intToStr(uint8.high)

echo intToStr(0.uint64)
echo intToStr(123.uint64)
echo intToStr(uint64.high)

echo intToStr(0.uint)
echo intToStr(123.uint)
echo intToStr(uint.high)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use as parameter type <span class="type">SomeInteger</span>, which allows signed and unsigned ints
of all byte sizes, and in the <span class="proc">proc</span> we test with <span class="code">is SomeSignedInt:</span> if
we have to care for the sign and in case of value <span class="lit">int.low</span> for overflow.
The advantage of this <span class="proc">proc</span> is, that it works for all integer types, signed and unsigned.
But one disadvantage is, that always the data type <span class="type">uint64</span> is used, which may be not available
on microcontroller CPUs. Let us see how a <span class="proc">proc</span> for only unsigned types may look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import math

proc intToStr(a: SomeUnsignedInt): string =
  var i: int
  var v = a
  if v &gt; 0:
    i = math.log10(v.float + 0.5).int
  result = newString(i + 1)
  while i &gt;= 0:
    result[i] = char(v mod 10 + ord('0'))
    v = v div 10
    dec(i)

echo intToStr(0.uint8)
echo intToStr(123.uint8)
echo intToStr(uint8.high)

echo intToStr(0.uint64)
echo intToStr(123.uint64)
echo intToStr(uint64.high)

echo intToStr(0.uint)
echo intToStr(123.uint)
echo intToStr(uint.high)</code></pre>
</div>
</div>
<div class="paragraph">
<p>That one is really simple and short, so maybe it would indeed make sense to
use this one for the unsigned types. And we do not need the <span class="type">unit64</span> type, so on a system
with no native 8 byte integers that <span class="proc">proc</span> should work fine.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Remember that whenever we use generic <span class="proc">procs</span> for the first time with a new argument type, then
a new instance of the <span class="proc">proc</span> customized for that data type is instantiated. That is, when we call
<span class="func">strToInt()</span> at least two times with an <span class="var">int32</span> and an <span class="var">int8</span> data type like <span class="func">intToStr(myInt32)</span> and
<span class="func">intToStr(myInt8)</span>, then we get already two different instances. So, use of generic <span class="proc">procs</span> can increase
the code size of our final executable. To avoid that, we may use <span class="func">intToStr(myInt8.int32)</span> instead,
which would just call the instance for the <span class="type">int32</span> argument again.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>All the previous examples have used <span class="func">log10()</span> to determine the number of digits
for the passed argument value. On microcontrollers, <span class="func">log10()</span> may be not available at all, or may be
very slow. So let us investigate at the end of this section how we can replace it.
The basic idea is, that we repeatedly divide the argument by ten, until we get the result
zero, counting the number of needed divisions. An equal approach is to start with a variable
with start value one and multiply with ten, until the result is larger than our function argument.
As division is generally slower than multiplication, and on microcontrollers a native <span class="op">div</span> operation may be
not available at all, we will try to use multiply operations.
So we may start with a <span class="proc">proc</span> like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc digits0(i: int): int =
  assert i &gt;= 0
  result = 1
  var d = 10
  while d &lt;= i:
    d *= 10
    inc(result)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Can you see the problem? What will happen when we pass <span class="lit">int.high</span> as argument?</p>
</div>
<div class="paragraph">
<p>So a working <span class="proc">proc</span> is this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc digits(a: SomeInteger): int =
  assert a &gt;= 0
  var i: uint64 = a.uint64
  result = 1
  when sizeof(a) == 8:
    const c = 10
    if i &gt;= c:
      i = i div c
      result = 2
  var d: typeof(i) = 10
  while d &lt;= i:
    d *= 10
    inc(result)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We do the math with an <span class="type">uint64</span> type in the <span class="proc">proc</span>. For the case
that the argument is an 8 byte type, we may get an overflow in the
while loop, which we prevent by doing one division before the loop already. Actually,
for improved performance instead of a division by ten we may do a division
by a larger power of ten, and fix the start value for the <span class="var">result</span> accordingly.
One disadvantage of that generic <span class="proc">proc</span> is, again, that an <span class="type">uint64</span> type is
used for the math, which is fine on a desktop PC, but may work bad on
restricted hardware. So this variant seems to be a better solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc digits(a: SomeInteger): int8 =
  assert a &gt;= 0
  var i = a
  result = 1
  if i &gt;= 10:
    i = i div 10
    result = 2
  var d: typeof(i) = 10
  while d &lt;= i:
    d *= 10
    inc(result)

echo digits(0)
echo digits(9)
echo digits(10)
echo digits(99)
echo digits(int.high)

echo digits(0.int8)
echo digits(int8.high)

echo digits(0.uint8)
echo digits(uint8.high)

echo digits(0.uint)
echo digits(uint.high)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we do a single <span class="op">div</span> operation if the argument is larger than <span class="lit">9</span>, but
do all the math with the same type as the argument type.
The <span class="op">div</span> operation may be still slow on a microcontroller, but our <span class="func">intToStr()</span>
proc has also used <span class="op">div</span> operations. Indeed, doing <span class="func">intToStr()</span>
conversions on a tiny 8-bit microcontroller is not really a good idea.</p>
</div>
<div class="paragraph">
<p>For determining the number of digits of integer numbers, you will
find many more solutions on the Internet. Sometimes this is
called <span class="func">log10()</span> for integer numbers. Some functions try to use
the logarithm with base 2, which is related to finding the highest set bit of
a number, some other functions use tabular data or a sequence of <span class="key">if</span> or <span class="key">case</span>
statements. As the performance of that functions depends on the actual hardware,
there exists not really the best solution for all cases.</p>
</div>
<div class="paragraph">
<p>For the <span class="func">intToStr()</span> function, you should also find very good solutions in Nim&#8217;s standard library.
Note that it was not our goal in this section to present a perfect solution, the idea was more
to show you how such a task can be solved in principle, and how we can improve
or modify solutions, and how we can use Nim&#8217;s generics to get one function for multiple
data types. Note that the presented <span class="proc">procs</span> are only minimal tested, and are tested only on a
64-bit desktop OS. So they may not work on systems where Nim&#8217;s int type is 32 bit, or for
microcontrollers and embedded systems. But you have learned enough now, so you could fix it for that cases.</p>
</div>
<div class="paragraph">
<p>As possible exercises for the reader, we may suggest creating a similar <span class="proc">proc</span> called <span class="func">strToInt()</span>
that converts a numeric string to an integer number, or to convert between <span class="type">strings</span> and <span class="type">float</span> numbers.
The first one is easy, you would build the <span class="type">int</span> value by continuously multiplying the digit value
with its correct power of ten, matching its position in the string. The float conversion
is more difficult, in one weekend you may get some working code, but perfect solutions
like the <span class="ndef">ryu</span> or <span class="ndef">dragonbox</span> algorithm are very complicated.</p>
</div>
</div>
<div class="sect2">
<h3 id="_no_game_programming">No Game Programming?</h3>
<div class="paragraph">
<p>No, not yet. We know that for many people, game programming
is the initial motivation to start with computer programming at all,
and so a larger section about this topic would make indeed some sense.
But there are some reasons why we do not have this section currently.
The most important reason is, that we try to present in this book that stuff,
that is very fundamental and that is not presented at other freely accessible
places in a beginner-friendly fashion. And there is a lot of this, which seems to
be more essential than games. The other reason is, that for a section about
games we would have to make a lot of decisions in advance: 2D or 3D game,
action game or strategy game. Using a game engine, or only a simple
library like cairo, sdl2, raylib or gogot? When using a game engine, then the decision
which one we should use, and which Nim bindings set is not a simple decision, and
we should try to ensure that the bindings are actively developed and so should
work in a few years with Nim 2.0 still. And finally there are already some nice tutorials
for game programming available, see for example</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://hookrace.net/blog/writing-a-2d-platform-game-in-nim-with-sdl2/" class="bare">https://hookrace.net/blog/writing-a-2d-platform-game-in-nim-with-sdl2/</a></p>
</li>
<li>
<p><a href="https://github.com/Ethosa/nodesnim" class="bare">https://github.com/Ethosa/nodesnim</a></p>
</li>
<li>
<p><a href="https://github.com/paranim/paranim" class="bare">https://github.com/paranim/paranim</a></p>
</li>
<li>
<p><a href="https://github.com/jiro4989/nimtetris" class="bare">https://github.com/jiro4989/nimtetris</a></p>
</li>
<li>
<p><a href="https://github.com/jiro4989/nimothello" class="bare">https://github.com/jiro4989/nimothello</a></p>
</li>
<li>
<p><a href="https://forum.nim-lang.org/t/8080" class="bare">https://forum.nim-lang.org/t/8080</a></p>
</li>
<li>
<p><a href="https://github.com/dsrw/enu" class="bare">https://github.com/dsrw/enu</a></p>
</li>
<li>
<p><a href="https://github.com/def-/nimes" class="bare">https://github.com/def-/nimes</a></p>
</li>
<li>
<p><a href="https://vladar4.github.io/nimgame2/" class="bare">https://vladar4.github.io/nimgame2/</a></p>
</li>
<li>
<p><a href="https://github.com/greenfork/nimraylib_now" class="bare">https://github.com/greenfork/nimraylib_now</a></p>
</li>
<li>
<p><a href="https://github.com/pragmagic/godot-nim" class="bare">https://github.com/pragmagic/godot-nim</a></p>
</li>
<li>
<p><a href="https://github.com/nimgl/nimgl" class="bare">https://github.com/nimgl/nimgl</a></p>
</li>
<li>
<p><a href="https://github.com/Vladar4/sdl2_nim" class="bare">https://github.com/Vladar4/sdl2_nim</a></p>
</li>
<li>
<p><a href="https://github.com/ftsf/nico" class="bare">https://github.com/ftsf/nico</a></p>
</li>
<li>
<p><a href="https://github.com/StefanSalewski/nim-chess4" class="bare">https://github.com/StefanSalewski/nim-chess4</a></p>
</li>
<li>
<p><a href="https://github.com/planetis-m/goodluck/" class="bare">https://github.com/planetis-m/goodluck/</a></p>
</li>
<li>
<p><a href="https://forum.nim-lang.org/t/8619" class="bare">https://forum.nim-lang.org/t/8619</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Actually, game programming is not that difficult, when we have a nice library with a good tutorial
available. Game programming can be much fun, which is great, but actually we do not learn that
much when we move some sprites over the screen. On the other hand, advanced game programming,
by using a big library like Godot, doing all with basic libs like SDL2 or Raylib, or developing your
own game engine based on OpenGL or Vulkan, is a very demanding task.</p>
</div>
<div class="paragraph">
<p>So maybe we will add a section about game programming at the end, when the rest of the book
is done, or maybe when the next edition of the book is published.</p>
</div>
</div>
</div>
</div>
<h1 id="_part_v_external_packages" class="sect0"><span class="new">Part V: External Packages</span></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>In this part of the book, we will present you some external packages, which
can easily be installed with Nim&#8217;s package manager(s).</p>
</div>
<div class="paragraph">
<p>For packages registered in the <span class="name">Nimble</span> database, executing the <span class="term">nimble install</span> command</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install packageName</pre>
</div>
</div>
<div class="paragraph">
<p>is sufficient, and you can also install unregistered packages, which may be hosted at <span class="var">github.com</span>
or another platform with a command like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install https://github.com/user/packageName</pre>
</div>
</div>
<div class="paragraph">
<p>Note that we call <span class="var">nimble</span> commands like <span class="var">install</span> generally as ordinary user, not as <span class="var">admin</span> or <span class="var">root</span> with
administrator privileges.
We told you already in the introduction to this book, that we do not intend to discuss the detailed
use of <span class="var">nimble</span> in this book, at least not for the first edition. The <span class="name">Nimble</span> package manager
is described in detail in <a href="https://github.com/nim-lang/nimble" class="bare">https://github.com/nim-lang/nimble</a>, and also in the Manning book.
There you can also learn how you can create <span class="name">Nimble</span> packages yourself, and how you can register
your own packages in <span class="name">Nimble&#8217;s</span> database so that other people can find them easier. While <span class="name">Nimble</span> is
<span class="nim">Nim&#8217;s</span> default package manager which is currently used by the majority of the user base, there exist
also the alternative implementation <a href="https://github.com/disruptek/nimph" class="bare">https://github.com/disruptek/nimph</a>, and some lesser known
ones like <span class="name">Nimp</span>, <span class="name">Slim</span> or <span class="name">Nifty</span>.</p>
</div>
<div class="paragraph">
<p>We have already a few thousand external packages for <span class="nim">Nim</span>&#8201;&#8212;&#8201;you may use commands
like <span class="term">nimble list</span> or <span class="term">nimble search</span> to list all registered packages,
or to search in the database for entries, or you can use <a href="https://nimble.directory/" class="bare">https://nimble.directory/</a> or the <span class="var">GitHub</span> online search to
find more packages. You can also consult the list of curated <span class="nim">Nim</span> packages at  <a href="https://github.com/xflywind/awesome-nim" class="bare">https://github.com/xflywind/awesome-nim</a>.</p>
</div>
<div class="paragraph">
<p>While the use of external packages is really easy, there are some critical points to consider:
External packages are not audited by the <span class="nim">Nim</span> core team, so the quality of external packages can vary, and
in principle external packages can even contain malicious code which may damage your
computer when you install and use that package. Well, as we use the <span class="var">nim</span> and <span class="var">nimble</span> commands as plain user without
administrator privileges, there is no real danger that the computer OS can be damaged&#8201;&#8212;&#8201;only
our own user data may get corrupted or damaged. But as we back up all of our important data regularly,
there is not that much danger, a SSD hardware crash seems to be more likely.
A more serious issue with external
packages arises from the fact that the packages may get outdated and abandoned and may stop working
with recent versions of the <span class="nim">Nim</span> compiler, or even may get totally removed from the internet
without prior announcements. So when you should create a larger software project that depends on
external packages, then you should save a local copy of that package, or you may even consider
creating a private fork of that <span class="var">GitHub</span> package.</p>
</div>
<div class="paragraph">
<p>Some programming languages like Python are shipped already with a very large collection of
libraries, so that external packages are not that often required at all. Other languages
like C++ come basically without any packages or a language specific package manager,
so we would use the package manager provided by the operating system to install important
C++ packages like <span class="name">Boost</span> or <span class="name">CGAL</span>, or install needed libraries manually.
<span class="nim">Nim</span> is between these two extremes&#8201;&#8212;&#8201;it provides already a large collection
of modules with its standard library, but has also a lot of external packages.
Both, internal core modules, and external packages have its merits.
We mentioned already some disadvantages of external packages, but actually
they have also benefits: They may be developed, updated and improved very fast, as
they are not strongly coupled to compiler release updates, and one external package
can easily be replaced by another similar one. A large set of internal packages can
on the other hand be a large maintainment burden for the language core team&#8201;&#8212;&#8201;the
packages have to be tested and maybe fixed for each new compiler version, and
replacing or removing legacy internal core packages can lead to a lot of problems.</p>
</div>
<div class="paragraph">
<p>In this part of the book, we will present a very small set of external packages only.
This is mostly done to tell you about the existence and usefulness, and for some package
because the currently available documentation is not really beginner-friendly.</p>
</div>
<div class="paragraph">
<p>We will start with a powerful package for the use of the <span class="ndef">Parsing Expression Grammar</span> (PEG),
which is some form of an alternative to the use of <span class="ndef">regular expressions</span> for parsing tasks.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_parsing_expression_grammars">Parsing Expression Grammars</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Parsing whole text files or single strings is a common programming task, e.g. to process textual user input
or to extract data from HTML or CSV files. Traditional this is often done by the use of <span class="ndef">regular expressions</span>&#8201;&#8212;&#8201;in part III of the book we show how it can be done by use of the <span class="mod">regex</span> module.</p>
</div>
<div class="paragraph">
<p><span class="ndef">PEGs</span>, or <span class="ndef">Parsing Expression Grammars</span>, are another formalism for recognizing patterns in text by use of a set of rules.
A PEG can be used as an alternative to <span class="ndef">regular expressions</span> for parsing, pattern matching and text processing.
The  <span class="ndef">Parsing Expression Grammar</span> was introduced by Bryan Ford in 2004 and is closely related to the family of top-down parsing languages introduced in the early 1970s.
PEGs are a derivative of the <span class="ndef">Extended Backus-Naur Form</span> (EBNF) with a different interpretation, designed to represent a recursive descent parser.</p>
</div>
<div class="paragraph">
<p>PEGs are not unlike regular expressions, but offer more power and flexibility, and have fewer ambiguities.
For example, a regular expression inherently cannot find an arbitrary number of matched pairs of parentheses, because it is not recursive, but a PEG can.</p>
</div>
<div class="paragraph">
<p>As PEGs can be constructed in a hierarchical way from individual
rules, it can be easier to create or understand them compared to regular expressions.</p>
</div>
<div class="paragraph">
<p>While the use of regular expressions is very similar in different programming languages or
external tools like <span class="ndef">sed</span> and <span class="ndef">grep</span>, the API for PEG libraries can be very different, and even the actual
syntax for building parsing rules can differ.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s standard library includes already a simple <span class="mod">pegs</span> module, but we will use the more advanced external <span class="name">NPeg</span> package
of Ico Doornekamp instead.
<span class="name">NPeg</span> is a pure <span class="nim">Nim</span> library, that provides macros to compile PEGs to Nim procedures which can parse strings and collect selected parts of the input.</p>
</div>
<div class="paragraph">
<p>In this section, we will try to explain the basic concepts of the PEG use and give some examples.
For a more formal and complete description, you should refer to the linked Wikipedia article
and consult the API documentation of the <span class="mod">npeg</span> module.</p>
</div>
<div class="paragraph">
<p>Formally, a <span class="ndef">parsing expression grammar</span> consists of a starting expression, a set of parsing rules, and finite sets of terminal and nonterminal symbols.<sup class="footnote">[<a id="_footnoteref_46" class="footnote" href="#_footnotedef_46" title="View footnote.">46</a>]</sup></p>
</div>
<div class="paragraph">
<p>Each parsing rule has the form <span class="code">A &#8592; e</span>, where <span class="var">A</span> is a nonterminal symbol and <span class="var">e</span> is a parsing expression.
An (atomic) parsing expression consists of terminal or nonterminal symbols or an empty string.
New parsing expressions can be constructed from existing ones by concatenation (sequence), an ordered choice,
by repetitions (zero-or more, one-or-more, optional) of an existing expression, and by
use of the <span class="ndef">and</span> and <span class="ndef">not</span> predicate.
The <span class="ndef">and-predicate</span> expression <span class="var">&amp;e</span> invokes the sub-expression <span class="var">e</span>, and then succeeds if <span class="var">e</span> succeeds and fails
if <span class="var">e</span> fails, but in either case never consumes any input.
The <span class="var">not-predicate</span> expression <span class="var">!e</span> succeeds if <span class="var">e</span> fails and fails if <span class="var">e</span> succeeds, again consuming no input in either case.
Because these two predicates can use an arbitrarily complex sub-expression to <span class="ndef">"look ahead"</span> into the input string without actually consuming it, they provide a powerful syntactic look-ahead and disambiguation facility, in particular when reordering the alternatives cannot specify the exact parse tree desired.</p>
</div>
<div class="paragraph">
<p><span class="name">NPeg</span> is a pure <span class="nim">Nim</span> pattern matching library. It provides macros to compile patterns and grammars (PEGs)
to Nim procedures which will parse a string and collect selected parts of the input.
In this way, <span class="var">npeg</span> is an alternative to the use of the <span class="mod">regex</span> module, but <span class="var">npeg</span> does not support
the optional replacement of matched patterns.</p>
</div>
<div class="paragraph">
<p>As understanding and using the PEG is really not that easy, and as most readers may never have heard about PEG
at all, we will start with a few very simple examples. First, let us parse just a few decimal digits:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import npeg

let p = peg("str"):
  str &lt;- +{'0'..'9'}

echo p.match("123").ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="mod">npeg</span> module defines a few macros for processing PEG patterns. One of them is
the <span class="var">peg()</span> macro, to which we pass as argument a starting expression
in the form of a string, and which creates and return a <span class="type">Parser</span> object.
In the body of the <span class="var">peg()</span> macro, we have to define all the grammar rules that our PEG
is built of. For our example, we only need one simple rule that is a repetition of the
decimal digits zero to nine.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">npeg</span> module uses as terminal symbols single characters enclosed in single quotes
or strings enclosed in double quotes.</p>
</div>
<div class="paragraph">
<p>In the original PEG syntax, a pair of square brackets is used to specify character ranges
like ['a'..'z'] for the lower case letters of the alphabet, but the <span class="mod">npeg</span> module uses
curly braces instead.</p>
</div>
<div class="paragraph">
<p>So in the <span class="var">npeg</span> syntax <span class="code">{'0'..'9'}</span> stands for a single decimal digit, and the leading <span class="var">*</span> indicates
one or more repetitions. In the original PEG syntax, we would use square brackets instead and
put the <span class="var">*</span> after the closing square bracket, that is <span class="code">['0'..'9']*</span>.
We can also list the characters of a character class separated by commas, e.g. {'a', 'z'} for 'a' or 'z'.
The symbol <span class="var">&#8592;</span> assigns the parsing rule to the nonterminal symbol <span class="var">str</span>, which is already
identical with the starting expression.</p>
</div>
<div class="paragraph">
<p>The <span class="func">peg()</span> macro returns a <span class="type">Parser</span> object, which we can pass together with a
string
that should be parsed to the <span class="func">match()</span> function. The function <span class="func">match()</span> returns an instance of a <span class="type">MatchObject</span>&#8201;&#8212;&#8201;we use the <span class="var">ok</span> field of this object to check if the match was successful.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>When we intend to use the <span class="mod">npeg</span> module, we have to know that this module uses a syntax
which is not fully identical to the original PEG definition, which is used by the <span class="mod">pegs</span> module
of Nim&#8217;s standard library: Originally character classes were created by enclosing individual characters
or character ranges in square brackets, similar as done for <span class="ndef">regular expressions</span>. But the <span class="mod">npeg</span>
module uses a pair of curly braces instead. In PEG repetitions are specified by <span class="var">*</span>, <span class="var">&#43;</span> and <span class="var">?</span>
for zero or more, one or more, or one or zero, as in regular expressions. In the original
PEG design these characters were put after an expression, while for the <span class="var">npeg</span> syntax
we have to put them in front of an expression. In the original PEG syntax, sequences of expressions
are just separated by spaces, while in npeg syntax a <span class="var">*</span> is used, and for the ordered choice
<span class="var">npeg</span> syntax uses the <span class="op">|</span> instead of the original slash (<span class="op">/</span>) symbol. Like the original PEG syntax,
<span class="var">npeg</span> uses the symbols <span class="var">&amp;</span> and <span class="op">!</span> for the non-capturing <span class="var">and</span> and <span class="ndef">not</span> predicates.
Additional <span class="var">npeg</span> provides
the symbol <span class="lit">1</span> to match all, <span class="lit">0</span> to match nothing and
an infix <span class="op">-</span> operator&#8201;&#8212;&#8201;<span class="code">P1 - P2</span> matches <span class="var">P1</span> if <span class="var">P2</span> does not match.
So an expression, which for example matches all characters but a space, can be easily written as <span class="code">1 - ' '</span>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As next example, we will create a PEG pattern that can match a simple mathematical term
built from decimal digits and the two operators <span class="var">&#43;</span> and <span class="var">-</span> for addition and subtraction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import npeg

let p2 = peg("term"):
  term &lt;- dig * *(op * dig)
  dig &lt;- +{'0'..'9'}
  op &lt;- {'+', '-'}

echo p2.match("1+23").ok</code></pre>
</div>
</div>
<div class="paragraph">
<p>We said that the symbol <span class="var">*</span> is used to indicate zero or more repetitions of an expression.
But for the <span class="mod">npeg</span> module this <span class="var">*</span> is used at the same time to construct sequences of expressions,
that is, to concatenate expressions. In the code above, we pass the string "term" as the starting expression to the <span class="func">peg()</span> macro.
In the macro body we define three rules, which each assign an expression to the nonterminal symbols
<span class="var">term</span>, <span class="var">dig</span> and <span class="var">op</span>. In the expression <span class="code">dig * *(op * dig)</span> the second <span class="var">*</span>
in front of the opening brace indicates an arbitrary number of repetitions of the expression
enclosed by the round brackets, while the first and third <span class="var">*</span> indicate the sequence or concatenation
operation. The following two rules just define a sequence of one or more decimal digits, and
the operator for addition or subtraction.</p>
</div>
<div class="sect2">
<h3 id="_capturing_data">Capturing data</h3>
<div class="paragraph">
<p>The <span class="mod">npeg</span> module offers plain string captures and more flexible code block captures.</p>
</div>
<div class="sect3">
<h4 id="_string_captures">String Captures</h4>
<div class="paragraph">
<p>Let us assume that we want to split a line of text into words:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import npeg

let p = peg("line"):
  line &lt;- +(space * &gt;word)
  word &lt;- +{'a'..'z'}
  space &lt;- *' '

let m = p.match(" one   two three    ")
if m.ok:
  echo m.matchLen
  echo m.captures</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>16
@["one", "two", "three"]</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="type">MatchResult</span> returned by the <span class="func">peg()</span> macro has the exported fields <span class="var">matchLen</span> and <span class="var">captures</span>,
which we can read out in case of a successful match. <span class="var">MatchLen</span> tells us how many characters
of the string has been captured, and <span class="var">captures</span> is a <span class="type">seq[string]</span> containing the captured strings.<sup class="footnote">[<a id="_footnoteref_47" class="footnote" href="#_footnotedef_47" title="View footnote.">47</a>]</sup></p>
</div>
</div>
<div class="sect3">
<h4 id="_code_block_captures">Code Block Captures</h4>
<div class="paragraph">
<p>Code block captures offer the most flexibility for accessing matched data in NPeg. This allows you to define a grammar with embedded Nim code for handling the data during parsing.</p>
</div>
<div class="paragraph">
<p>When a grammar rule ends with a colon <span class="code">:</span>, the next indented block in the grammar is interpreted as Nim code, which gets executed when the rule has been matched. Any string captures that were made inside the rule are available to the Nim code in the injected variable <span class="var">capture[]</span> of type <span class="type">seq[Capture]</span>.
<span class="type">Capture</span> is an object with field <span class="var">s</span> containing the captured string and field <span class="var">si</span> containing the index position of the capture inside the
original string.</p>
</div>
<div class="paragraph">
<p>The total sub-string matched by the code block rule is available as <span class="var">capture[0]</span>, and the individual
captured strings are available with indices &gt; <span class="lit">0</span>. In the indented code block, we can also use <span class="var">$n</span> instead of
<span class="var">capture[n].s</span> and <span class="var">@n</span> instead of <span class="var">capture[n].si</span>.</p>
</div>
<div class="paragraph">
<p>We could use the seq of captures to print the captured strings or to copy it into some global variable.
To avoid the need for global variables, we can pass to the <span class="func">peg()</span> macro a second argument, which
is a name and a data type separated by a colon, like <span class="func">peg(name, identifier: Type)</span>.
The second parameter is then available as an ordinary variable in the code block.</p>
</div>
<div class="paragraph">
<p>For our next example, we will assume that we have written a plain CAD tool, that allows the user
to enter textual commands like <span class="term">moveTo(x, y)</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import npeg, tables

type T = Table[string, string]

let p = peg("command", t: T):
  command &lt;- &gt;com * '(' * &gt;pos * ',' * &gt;pos * ')':
    # echo $1, $2, $3
    t["action"] = $1
    t["x"] = $2
    t["y"] = $3
  com &lt;- "moveTo" | "lineTo"
  pos &lt;- +{'0'..'9'}


var input: T
if p.match("moveTo(12,20)", input).ok:
  echo input["action"], ": ", input["x"], ", ", input["y"]</code></pre>
</div>
</div>
<div class="paragraph">
<p>To keep the example simple and short, we assume that we have to process only
two different command, <span class="func">moveTo()</span> and <span class="func">lineTo()</span>, each accepting <span class="var">x</span>, <span class="var">y</span> coordinates of integer
form. We pass to the <span class="func">peg()</span> macro a second argument, which is the name and the data type
of a <span class="type">Table</span> instance. We have chosen for the key and value type of that table the <span class="type">string</span> data type,
as we want to store the command name as well as the <span class="var">x/y</span> coordinates, so an integer value
type would not work. The macro body defines three rules&#8201;&#8212;&#8201;<span class="var">command</span>, <span class="var">com</span> and <span class="var">pos</span>.
For the <span class="var">command</span> rule, we use an expression which starts with the command name, followed
in round brackets, the <span class="var">x/y</span> coordinate pair. In front of the nonterminal symbols <span class="var">com</span> and <span class="var">pos</span>
we put the <span class="op">&gt;</span> operator to capture these values. We put a colon after the command rule and
can access the captured values in the indented block, by use of the <span class="var">$N</span> symbol.
For the <span class="var">com</span> rule, we specify the literal terminal symbols <span class="lit">"moveTo"</span> or <span class="lit">"lineTo"</span> as
ordered choice with the <span class="op">|</span> operator. Finally, the expression for the <span class="var">pos</span> rule is just a
sequence of one or more decimal digits.</p>
</div>
</div>
<div class="sect3">
<h4 id="_simple_patterns">Simple patterns</h4>
<div class="paragraph">
<p>For simple patterns, it may be not necessary to define multiple parsing rules. In that case,
we can use the <span class="func">patt()</span> macro instead of <span class="func">peg()</span> and pass just a single one line pattern as argument.</p>
</div>
<div class="paragraph">
<p>For example, the pattern below splits a string by white space:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">let parser = patt *(*' ' * &gt; +(1-' '))
echo parser.match("   one two three ").captures</code></pre>
</div>
</div>
<div class="paragraph">
<p>We took this example from the <span class="var">npeg</span> API documentation verbatim. Here, the <span class="func">patt()</span> macro uses
Nim&#8217;s command invocation syntax, so there is no outer bracket after the macro name.
The innermost bracket uses the notation (1-' ') to match everything but a space, and
the content of the outer bracket starts with an arbitrary number of uncaptured spaces.</p>
</div>
</div>
<div class="sect3">
<h4 id="_look_ahead_operators">"Look ahead" operators</h4>
<div class="paragraph">
<p>The PEG syntax defines also the two non-capturing <span class="var">and</span> and <span class="var">not</span> syntactic predicates,
which uses the symbols <span class="var">&amp;</span> and <span class="var">!</span> and provide a powerful syntactic look ahead and disambiguation facility.
A common use of the <span class="var">!</span> predicate is to terminate a parsing expression with <span class="lit">!1</span>. Here the <span class="lit">1</span> matches everything, and <span class="lit">!1</span>
would only match when there is nothing left to match, that is the string end is reached.</p>
</div>
<div class="paragraph">
<p>We will end our introduction to the parsing expression grammar and the use of the <span class="mod">npeg</span> module here.
To learn all the details about PEG like restrictions, performance and memory consumption you should
consult the Wikipedia article or other dedicated literature. And for advanced uses of the <span class="mod">npeg</span> module
including the use of back references, and all the available syntax elements, you
have to study its API documentation carefully.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/zevv/npeg" class="bare">https://github.com/zevv/npeg</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" class="bare">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_cligen_a_command_line_interface_generator"><span class="new">Cligen, a Command-Line Interface generator</span></h2>
<div class="sectionbody">
<div class="paragraph">
<p>In part III of the book, we presented the module <span class="mod">parseopt</span> of Nim&#8217;s standard library, which can help
us to parse the command line <span class="str">string</span>&#8201;&#8212;&#8201;for programs launched from within a terminal
window by typing the command name followed by a set of options and arguments. There we also
explained the difference between short and long option names, and options with and without values.
If you can not remember these terms, you should read that section again, or maybe skip this
section completely, for the case that you are not interested in creating tools that are used from
within a terminal window.</p>
</div>
<div class="paragraph">
<p>In that <a href="#Command line parsing">[Command line parsing]</a> section, we said, that with the external package <span class="italic">cligen</span>
the processing of options and parameters for command line tools can be simplified a lot.
The basic idea of the <span class="italic">cligen</span> package is, that the parameter list of Nim procs
is already a valuable specification for parameters: It provides names, data types, and optional default
values for a set of parameters, in a form which is already familiar to the Nim user.
The <span class="mod">cligen</span> module allows us to just create a top level proc with a parameter list,
which can be called directly from the command line with all the
parameters passed in fully automatically. We only have to call the
<span class="func">dispatch()</span> <span class="key">macro</span> on that procedure&#8201;&#8212;&#8201;that <span class="key">macro</span> does all the magic for
us. If you want to try this package, you can install it with the
Nimble package manager with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install cligen</pre>
</div>
</div>
<div class="paragraph">
<p>At the end of section <a href="#Command line parsing">[Command line parsing]</a>, we gave the sketch of
a tool called <span class="var">fancyPrint</span> that could be used to print files. That tool
had options to select single pages to print, and to specify the print quality.
With <span class="mod">cligen</span> we only have to create the proc definition, and to call
<span class="func">dispatch()</span> on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import cligen

type
  Quality = enum
    low, medium, high

const
  AllPages = -1

proc fancyPrint(page = AllPages; quality = medium; verbose = false; files: seq[string]) =
  if files.len == 0:
    echo "Missing names of files to print!"
    quit()
  if verbose:
    if page == AllPages:
      echo "We print all the pages of the specified files!"
    else:
      echo "We print page ", $page, " only"
    echo "Print quality: ", quality
  for f in files:
    echo "Printing ", f, " ..."
    # insert the real code here!

dispatch(fancyPrint)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you have installed <span class="mod">cligen</span> already as suggested above, you can compile and run this
code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nim c fancyprint,nim
...
./fancyprint -p12 --quality:high --verbose file1.pdf file2.pdf
...

We print page 12 only
Print quality: high
Printing file1.pdf ...
Printing file2.pdf ...</pre>
</div>
</div>
<div class="paragraph">
<p>Long and short option names, with and without values are supported, you can use <span class="lit">=</span> or <span class="lit">:</span> to separate option
names from its values, and leaf out the separator as in <span class="term">-p12</span> when there is no ambiguity.
Long options can be abbreviated if there is no ambiguity, i.e. we could call our app like
<span class="term">./fancyprint --p12 --qual:high --verb file.pdf</span>.</p>
</div>
<div class="paragraph">
<p>By default, the letter for the short option is the first character of the long option name, but that
can be customized. As option values, most basic Nim data types can be used, this includes numeric types,
enumeration types and boolean types. For boolean options, instead of giving the short or long option name
without a value to activate that option, it is also possible to use values like <span class="lit">false</span>,  <span class="lit">true</span>,  <span class="lit">on</span>,
 <span class="lit">off</span>,  <span class="lit">0</span>,  <span class="lit">1</span> to switch that option off or on.
When in the proc parameter list, a value has no default value, then it will become mandatory.
We can call the tool also with  <span class="lit">-h</span> or  <span class="lit">--help</span> to get an informative overview of the intended use:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Usage:
  fancyPrint [optional-params] [files: string...]
Options:
  -h, --help                        print this cligen-erated help
  --help-syntax                     advanced: prepend,plurals,..
  -p=, --page=     int      -1      set page
  -q=, --quality=  Quality  medium  select 1 enum Quality
  -v, --verbose    bool     false   set verbose</pre>
</div>
</div>
<div class="paragraph">
<p>You can also display a summary about the  <span class="mod">cligen</span> syntax
with the parameter  <span class="lit">help-syntax</span>. The <span class="mod">cligen</span> module offers some more advanced
features, which we will not discuss here in detail: We can use
a command mode, to support app calls like <span class="term">nim c &#8230;&#8203;</span>, where the first
argument selects which command is called. Or you can specify that a different
letter than the first one of the long option name is used as short option.
Or, instead of directly calling a proc, we can use <span class="mod">cligen</span> to initialize an
<span class="key">object</span> instance, which is then passed as parameter to a proc. It is even possible to use other data
types as values than the primitive Nim types, when we define converter
procs for that data types.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/c-blake/cligen" class="bare">https://github.com/c-blake/cligen</a></p>
</li>
</ul>
</div>
</div>
</div>
<h1 id="_part_vi_advanced_nim" class="sect0">Part VI: Advanced Nim</h1>
<div class="openblock partintro">
<div class="content">
In this part of the book we will try to explain the more difficult parts of the Nim programming language:
Macros and meta-programming, asynchronous code, threading and parallel processing, and finally
the use of Nim&#8217;s concepts. We will start with macros and meta-programming, as that seems to
be a really stable part of Nim&#8217;s advanced features. Nim&#8217;s concepts just got a redesign, and for
the use of asynchronous code, threading and parallel processing there exists currently
various implementations, and all that may change again when the Nim core devs should decide
to actually use the CPS (Continuation-Passing Style) based programming style for the implementation of this.
</div>
</div>
<div class="sect1">
<h2 id="_macros_and_meta_programming">Macros and Meta-Programming</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction_2">Introduction</h3>
<div class="paragraph">
<p>In computer science, a macro (short for "macro instruction") is a rule or pattern that specifies how a certain input should be mapped to a replacement output.
Meta-programming is a programming technique in which computer programs have the ability to treat other programs as their data. It means that a program can read, generate, analyze or transform other programs, and even modify itself while running.</p>
</div>
<div class="paragraph">
<p>Legacy programming languages like C or assembly languages support already some form of macros, which typically work directly
on the textual representation of the source code.</p>
</div>
<div class="paragraph">
<p>A common use of textual macros in assembly languages was to group sequences of instructions, like
reading data from a file or from the keyboard, to make that operations easily accessible. The C programming
language uses the #define pre-processor directive to introduce textual macros. Macros in C are generally single line
text substitutions which are processed by a pre-processor program before the actual compiling process. Some examples of
common C macros are</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-c" data-lang="c">#define PI 3.1415
#define sqr(x) (x)*(x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic C macro syntax is that the first continues character sequence after the #define directive is replaced by
the C pre-processor with the rest of that line. The #define directive has some basic parameter support, which
was used for the <span class="func">sqr()</span> macro above. C macros have the purpose to support named constants and to support
simple parameterized expressions like the <span class="func">sqr()</span> from above, avoiding the need to create actual functions.
The C pre-processor would substitute each occurrence of the string <span class="const">PI</span> in the C source file with the float literal
<span class="lit">3.1415</span> and the term <span class="code">sqr(1&#43;2)</span> with <span class="code">(1&#43;2)*(1&#43;2)</span>.</p>
</div>
<div class="paragraph">
<p>A Nim macro is a function that is executed at compile-time and transforms a Nim syntax tree into a different tree.
This can be used to add custom language features and implement domain-specific languages (DSL).
While macros enable advanced compile-time code transformations, they cannot change Nim&#8217;s syntax.</p>
</div>
<div class="paragraph">
<p>The macro keyword is used similar to <span class="proc">proc</span>, func and template to define a parameterized code block which is executed at compile time
and consists of ordinary Nim code and meta-programming instructions. The meta-programming instructions are imported from the <span class="mod">macros</span>
module and are used to construct an Abstract Syntax Tree (AST) of the Nim language. This AST is created by the macro body at compile time
and is returned by the macro as untyped data type. The parameter list of macros accept ordinary (static) Nim data types and additional the data types
typed and untyped, which we already used for templates. We will explain the differences of the various possible data types
for macro parameters later in more detail, after we have given a first simple macro example. Note that Nim macros are hygienic by default, that
is, symbols defined inside the macro body are local and do not pollute the name space of the environment.
As macros are executed at compile time, the use of macros may increase the compile time, but their use
does not impact the performance of the final executable&#8201;&#8212;&#8201;in some cases the use of clever macros may even
improve the performance of our final program.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Macros are by far the most difficult part of the Nim programming language. While in languages like Lisp macros integrate very well into the language,
for Nim the meta-programming with macros is very different to the use of the language itself. Nim&#8217;s macros are very powerful&#8201;&#8212;&#8201;the current
Nim async implementation is based on Nim macros, and some advanced libraries for threading, parallel processing or data serialization
using JSON or YAML file formats make heavily use of Nim macros. And many modules of the Nim standard library provide some macros
which extends the power of the Nim core language. The famous with macro of the equality named module is only one example for the
usefulness of Nim&#8217;s macros. And some small but important parts of the high level GTK bindings are created with macros, e.g. the
code to connect GTK callback functions to GTK signals.
But this means not, that each Nim user really has to use macros. For a few use cases we really need macros, for other use
cases macros may make our code shorter, maybe even cleaner. But at the same time, the use of macros can make it for
other people harder to understand the code, at least when we use exotic or our own complicated macros. And learning advanced Nim macro
programming is not that easy. Nim macros have some similarity to the programming language C++: When we follow the explanations in a C++ text book, then the
C++ language seems to be not extremely difficult and even seems to follow a more or less logical design. But then, when we later try to write some
actual code in C++ we notice that actually using the languages is hard as long as we have not a lot of practice. For Nim macros, it is similar&#8201;&#8212;&#8201;when we follow a talk of an experienced Nim programmer about macro programming or when we read the code of an existing macro written by
the Nim core devs, then all seems to be not that hard. But when we try to create macros of our own for the first time, it can be frustrating.
Strange error messages, or even worse, no idea at all how we can solve a concrete task. So maybe the best start with macros is to read
the code of existing macros, to study the <span class="mod">macros</span> module to see what is available, and maybe to follow some of the various tutorials listed
at the end of this section. And finally you would have to ask for help in the Nim forum, on IRC or the other Nim help channels.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>To verify that macros are really executed at compile time, we will start with a tiny macro that contains only an echo statement in its body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(s: string): untyped =
  echo s

proc main =
  echo "calling macro m1"
  m1("Macro argument")

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile the above code, the compiler prints the message <span class="lit">"Macro argument"</span>, as it processes the macro body.
When we run the program, we get only the output <span class="lit">"calling macro m1"</span> from the <span class="func">main()</span> <span class="proc">proc</span>, as the macro <span class="func">m1()</span>
does return an empty AST only. The careful reader may wonder why the <span class="func">echo()</span> statement in the macro body above
works at all, as the parameter of macro <span class="func">m1()</span> is specified as ordinary <span class="str">string</span>, not as <span class="type">static[string]</span>. So the type
of <span class="var">s</span> in the macro body should be a NimNode. Well, perhaps an <span class="func">echo()</span> overload exists that can work with NimNodes,
or maybe, as we pass a <span class="str">string</span> constant to macro <span class="func">m1()</span>, in this concrete case s is indeed an ordinary string
in the macro body. Possibly we should have used <span class="code">s: static[string]</span> as parameter type, which would give
us the exact same results.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>We said that macros have to always return an <span class="type">untyped</span> result. This is true, but as <span class="type">untyped</span> is the only possible
result type, that type can currently be omitted. So you may see in the code of the Nim standard lib a few macros
which seems to return nothing. For our own macros, we really should always use <span class="type">untyped</span> as the result. And sometimes
you may even see macros where for parameters no data type is specified at all. In that case, the data type has the
default <span class="type">untyped</span> type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>As macros are executed at compile time, we can not really pass runtime variables to it. When we try, we would
expect a compiler error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(s: string): untyped =
  echo s

proc main =
  var str = "non static string"
  m1(str)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>But with the current compiler version 1.5.1 that code compiles and prints the message <span class="lit">"str"</span>, which is a bit surprising.
To fix this, we can change the parameter type to <span class="type">static[string]</span>, which guarantees that we can indeed pass only compile time constants.
Our last example would give a compile error in this case, while the one before with the
<span class="str">string</span> constant would work as expected.</p>
</div>
<div class="paragraph">
<p>Now let us create macros which actually creates an AST which is returned by the macro and executed when we run our program.
For creating an AST in the macro body, we have various options: we can use the <span class="func">parseStmt()</span> function or the <span class="code">"quote do:"</span> notation
to generate the AST from regular program code in text form, or we can create the syntax tree directly with expressions provided by the <span class="mod">macros</span> module, e.g.
by calls like <span class="func">newTree()</span> or <span class="func">newLit()</span> and such. The latter gives us the best control over the AST generation process, but is not easy for beginners. The good news
is that Nim now provides a set of helper functions like <span class="func">dumpTree()</span> or <span class="func">dumpAstGen()</span> which shows us the AST representation of a Nim source code
block as well as the commands which we can use to create that AST. This makes it for beginners much easier to learn the basic instructions necessary
to create valid syntax trees and to create useful macros.</p>
</div>
<div class="paragraph">
<p>We will start with the simple <span class="func">parseStmt()</span> function, which generates the syntax tree from the source code text string that we pass it
as argument. This seems to be very restricted, and maybe even useless, as we can write the source code just as ordinary
program text outside the macro body. That is true, but we can construct the text string argument that we pass to the
<span class="func">parseStmt()</span> function with regular Nim code at compile time. That is similar to having one program, which
generates a new source code string, saves that string to disk, and finally compiles and runs that created program. Let us check
with a fully <span class="key">static</span> string that <span class="func">parseStmt()</span> actually works:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(s: static[string]): untyped =
  result = parseStmt(s)

proc main =

  const str = "echo \"We like Nim\""
  m1(str)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run the above program, we get the output
<span class="lit">"We like Nim"</span>. The macro <span class="func">m1()</span> is called at compile time with the <span class="key">static</span>
parameter <span class="var">str</span> and returns an AST which represents the passed
program code fragment. That AST is inserted into our program at the location
of the macro call, and when we run our program, the compiled AST is executed and
produces the output.</p>
</div>
<div class="paragraph">
<p>Of course, executing a fully <span class="key">static</span> <span class="str">string</span> this way is useless, as we could have used
regular program code instead. Now let us investigate how we can construct some
program code at compile time. Let us assume that we have an <span class="key">object</span> with multiple
fields, and we want to print the field contents. A sequence of <span class="func">echo()</span> statements would do
that for us, or we may use only one <span class="func">echo()</span> statement, when we separate the field arguments each
by <span class="lit">"\n"</span>. The <span class="mod">with</span> module may further simplify our task. But as we have to print multiple fields, not
an <span class="type">array</span> or a <span class="type">seq</span>, we can not directly iterate over the values to process them. Let us see how
a simple text string based macro can solve the task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

type
  O = object
    x, y, z: float

macro m1(objName: static[string]; fields: varargs[untyped]): untyped =
  var s: string
  for x in fields:
    s.add("echo " &amp; objName &amp; "." &amp; x.repr &amp; "\n")
  echo s # verify the constructed string
  result = parseStmt(s)

proc main =
  var o = O(x: 1.0, y: 2.0, z: 3.0)
  m1("o", x, y, z)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we pass the name of our <span class="key">object</span> instance as a <span class="key">static</span> <span class="str">string</span> to the macro, while we pass
the fields not as <span class="str">string</span>, but as a list of <span class="type">untyped</span> values. The passed <span class="key">static</span> <span class="str">string</span> is indeed an ordinary Nim <span class="type">string</span>
inside the <span class="mac">macro</span>, we can apply sting operations on it. But the field names passed as <span class="type">untyped</span> parameters
appear as so called NimNodes inside the macro. We can use the <span class="func">repr()</span> function to convert the NimNodes to
ordinary <span class="type">strings</span>, so that we can use <span class="str">string</span> operations on them. We iterate with a <span class="key">for</span> loop over all the passed
field names, and generate <span class="func">echo()</span> statements from the <span class="key">object</span> instance name and the field names, each separated
by a newline character. Then all the statements are collected in a multi-line <span class="str">string</span> <span class="var">s</span> and are finally converted
to the final AST by the <span class="func">parseStmt()</span> function. In the macro body, we use the <span class="func">echo()</span> statement to verify the
content of that <span class="str">string</span>. As the <span class="mac">macro</span> is executed during compile time, we get this output
when we compile our program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>echo o.x
echo o.y
echo o.z</pre>
</div>
</div>
<div class="paragraph">
<p>And when we run it, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1.0
2.0
3.0</pre>
</div>
</div>
<div class="paragraph">
<p>Well, not a really great result for this concrete use case: We have replaced three <span class="func">echo()</span> commands with a five lines <span class="mac">macro</span>.
But at least you got a feeling what <span class="mac">macros</span> can do for use.</p>
</div>
</div>
<div class="sect2">
<h3 id="_types_of_macro_parameters">Types of macro parameters</h3>
<div class="paragraph">
<p>As Nim is a statically typed programming language, all variables and <span class="proc">proc</span> parameters have a well-defined
data type. There is some form of exception to this rule for OR-types, <span class="key">object</span> variants and <span class="key">object</span> references:
OR-types are indeed no real exception, as whenever we use an OR-type as the type of a <span class="proc">proc</span> parameter, multiple instances
of the <span class="proc">proc</span> with different parameter types are created when necessary. That is very similar to generic <span class="proc">procs</span>.
<span class="key">object</span> variants and <span class="key">object</span> references built indeed some form of exception, as instances of these types can have
different runtime types that we can query with the <span class="key">case</span> or with the <span class="key">of</span> keyword at runtime. Note that <span class="key">object</span>
variants and references (the managed pointers itself, not the actual data allocated on the heap) always occupy the same amount of RAM, independent of the actual runtime type.
(That is why we can store object variants with different content or references to objects of different runtime types using inheritance in
<span class="type">arrays</span> and sequences.)</p>
</div>
<div class="paragraph">
<p>For the C <span class="func">sqr()</span> macro from the beginning of this section, there is no real restriction for the argument data types.
The <span class="func">sqr()</span> C macro would work for all numeric types that support the multiply operation, from <span class="type">char</span> data type over
various <span class="type">int</span> types to <span class="type">float</span>, <span class="type">double</span> and <span class="type">long double</span>. This behavior is not really surprising, as C macros are only a
text substitution&#8201;&#8212;&#8201;by the * multiply operator for our <span class="func">sqr()</span> <span class="mac">macro</span>. Actually, the C pre-processor would even accept
all data types and even undefined symbols for its substitution process. But then the C compiler would complain later.</p>
</div>
<div class="paragraph">
<p>Nim <span class="mac">macros</span> and Nim <span class="key">templates</span> do also some form of code substitution, so it is not really surprising that they accept not
only well-defined data types, but also the relaxed types <span class="type">typed</span> and <span class="type">untyped</span>.</p>
</div>
<div class="paragraph">
<p>As parameters for Nim&#8217;s <span class="mac">macros</span> we can use ordinary Nim data types like <span class="type">int</span> or <span class="type">string</span>, compile time constants denoted with the
<span class="key">static</span> keyword like <span class="type">static[int]</span>, or the <span class="type">typed</span> and <span class="type">untyped</span> data types. When we call <span class="mac">macros</span>, then the data types of the parameters are used in the same way for overload resolution
as it is done for <span class="proc">procs</span> and templates. For example, if a macro defined as <span class="code">foo(arg: int)</span> is called as <span class="func">foo(x)</span>, then <span class="var">x</span> has to be of a type compatible to <span class="type">int</span>.</p>
</div>
<div class="paragraph">
<p>What may be surprising at first is, that inside the <span class="mac">macro</span> body all parameter types have not the data type of the actual
argument that we have passed to the <span class="mac">macro</span>, but the special <span class="mac">macro</span> data type <span class="type">NimNode</span> which is defined in the <span class="mod">macros</span> module.
The predefined result variable of the <span class="mac">macro</span> has the type <span class="type">NimNode</span> as well. The only exception are <span class="mac">macro</span> parameters
which are explicitly marked with the <span class="key">static</span> keyword to be compile time constants like <span class="type">static[string]</span>, these parameters
are not NimNodes in the <span class="mac">macro</span> body, but have their ordinary data types in the <span class="mac">macro</span> body.
Variables that we define inside the <span class="mac">macro</span> body have exactly that type that we give to then, e.g. when we define a
variable as <span class="code">s: string</span> then this is an ordinary Nim <span class="str">string</span> variable, for which we can use the common <span class="str">string</span> operations.
But of course, we have always to remember that <span class="mac">macros</span> are executed at compile time, and so the operations
on variables defined in the <span class="mac">macro</span> body occur at compile time, which may restrict a few operations.
Currently, <span class="mac">macros</span> are evaluated at compile time by the Nim compiler in the NimVM (Vitual Machine) and so
share all the limitations of the NimVM: <span class="mac">Macros</span> have to be implemented in pure Nim code and can currently not
call C functions except those that are built in the compiler.</p>
</div>
<div class="paragraph">
<p>In the Nim macros tutorial, the <span class="type">static</span>, <span class="type">typed</span> and <span class="type">untyped</span> <span class="mac">macro</span> parameters are described in some detail. We will
follow that description, as it is more detailed as the current description in the Nim compiler manual. As these
descriptions are very abstract, we will give some simple examples later.</p>
</div>
<div class="sect3">
<h4 id="_static_macro_parameters">Static Macro Parameters</h4>
<div class="paragraph">
<p><span class="key">Static</span> arguments are a way to pass compile time constants not as a <span class="type">NimNode</span>, but as an ordinary value to a <span class="mac">macro</span>.
These values can then be used in the <span class="mac">macro</span> body like ordinary Nim variables. For example, when we have
a <span class="mac">macro</span> defined as <span class="code">m1(num: static[int])</span>, then we can pass it constants values compatible with the
<span class="type">int</span> data type, and in the <span class="mac">macro</span> body we can use that parameter as an ordinary integer variable.</p>
</div>
</div>
<div class="sect3">
<h4 id="_untyped_macro_parameters">Untyped Macro Parameters</h4>
<div class="paragraph">
<p><span class="type">Untyped</span> <span class="mac">macro</span> arguments are passed to the <span class="mac">macro</span> before they are semantically checked. This means that the syntax tree that is passed down to the <span class="mac">macro</span> does not need
to make sense for the Nim compiler yet, the only limitation is that it needs to be parsable. Usually, the <span class="mac">macro</span> does not check the argument either, but uses it in the
transformation&#8217;s result somehow. The result of a <span class="mac">macro</span> expansion is always checked by the compiler,
so apart from weird error messages, nothing bad can happen.
The downside for an <span class="type">untyped</span> <span class="mac">macro</span> argument is that these do not play well with Nim&#8217;s overloading resolution.
The upside for <span class="type">untyped</span> arguments is that the syntax tree is quite predictable and less complex compared to its <span class="type">typed</span> counterpart.<sup class="footnote">[<a id="_footnoteref_48" class="footnote" href="#_footnotedef_48" title="View footnote.">48</a>]</sup></p>
</div>
</div>
<div class="sect3">
<h4 id="_typed_macro_parameters">Typed Macro Parameters</h4>
<div class="paragraph">
<p>For <span class="type">typed</span> arguments, the semantic checker runs on the argument and does transformations on it, before it is passed to the macro.
Here identifier nodes are resolved as symbols, implicit type conversions are visible in the tree as calls, <span class="key">templates</span> are expanded,
and probably most importantly, nodes have type information. Typed arguments can have the type <span class="type">typed</span> in the arguments list.
But all other types, such as <span class="type">int</span>, <span class="type">float</span> or <span class="type">MyObjectType</span> are typed arguments as well, and they are passed to the macro as a syntax tree.<sup class="footnote">[<a id="_footnoteref_49" class="footnote" href="#_footnotedef_49" title="View footnote.">49</a>]</sup></p>
</div>
</div>
<div class="sect3">
<h4 id="_code_blocks_as_arguments">Code Blocks as Arguments</h4>
<div class="paragraph">
<p>In Nim, it is possible to pass the last argument of a <span class="proc">proc</span>, <span class="key">template</span> or <span class="mac">macro</span> call as
an indented code block following a colon, instead of an ordinary argument enclosed
in the parentheses following the function name. For example, instead of <span class="code">echo("1 &#43; 2 = ", 1 &#43; 2)</span>
we can also write</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">echo("1 + 2 = "):
  1 + 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <span class="proc">procs</span> this notation makes not much sense, but for
<span class="mac">macros</span> this notation can be useful, as syntax trees of arbitrary complexity can be passed as arguments.</p>
</div>
<div class="paragraph">
<p>Now, let us investigate in some more detail which data types
a <span class="mac">macro</span> accepts. This way we hopefully get more comfortable with all these strange <span class="mac">macro</span> stuff.
For our test we create a few tiny <span class="mac">macros</span> with only one parameter which does noting more than
printing a short message when we compile our program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(x: static[int]): untyped =
  echo "executing macro body"

m1(3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code should compile fine and print the message <span class="lit">"executing macro body"</span> during the compile process,
and indeed it does. The next example is not that easy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(x: int): untyped =
  echo "executing macro body"
  echo x
  echo x.repr

var y: int
y = 7
m1(y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This compiles, but as the assignment <span class="code">y = 7</span> is executed at program runtime, while the <span class="mac">macro</span> body
is already executed at compile time, we should not expect that the <span class="func">echo()</span> statement in the <span class="mac">macro</span> body
prints the value <span class="lit">7</span>. Instead, we get just <span class="var">y</span> for both <span class="func">echo()</span> calls. Now let us investigate what happens when we use
<span class="type">typed</span> instead of <span class="type">int</span> for the <span class="mac">macro</span> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(x: typed): untyped =
  echo "executing macro body"
  echo x
  echo x.repr

var y: int
y = 7
m1(y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We get the same result again, both <span class="func">echo()</span> statements prints <span class="var">y</span>. The advantage of the use of <span class="type">typed</span> here is, that
we can change the data type of <span class="var">y</span> from <span class="type">int</span> to <span class="type">float</span> and our program still compiles. So the <span class="type">typed</span> parameter type
just enforces that the parameter has a well-defined type, but it does not restrict the actual data type
to a special value. The previous <span class="mac">macro</span> with <span class="type">int</span> parameter type would obviously not accept a <span class="type">float</span> value.</p>
</div>
<div class="paragraph">
<p>Now let us see what happens when we pass an undefined symbol to this <span class="mac">macro</span> with <span class="type">typed</span> parameter:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(x: typed): untyped =
  echo "executing macro body"
  echo x
  echo x.repr

m1(y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will not compile, as the <span class="mac">macro</span> expects a parameter with a well-defined type. But we can make it compile
by replacing <span class="type">typed</span> with <span class="type">untyped</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m1(x: untyped): untyped =
  echo "executing macro body"
  echo x
  echo x.repr

m1(y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>So <span class="type">untyped</span> <span class="mac">macro</span> parameters are the most flexible ones, and actually they are the most used.
But in some situations it is necessary to use <span class="type">typed</span> parameters, e.g. when we need to know
the parameter type in the <span class="mac">macro</span> body.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_quote_and_the_quote_do_construct">Quote and the quote do: construct</h3>
<div class="paragraph">
<p>In the section before, we learned about the <span class="func">parseStmt()</span> function which is used in a <span class="mac">macro</span> body to compile
Nim code represented as a multi-line <span class="type">string</span>
to an abstract syntax tree representation. <span class="mac">Macros</span> use as return type the <span class="type">"untyped"</span> data type, which is compatible with the <span class="type">NimNode</span> type
returned by the <span class="func">parseStmt()</span> function.</p>
</div>
<div class="paragraph">
<p>The <span class="func">quote()</span> function and the <span class="code">quote do:</span> construct has some similarity with the <span class="func">parseStmt()</span> function: It accepts an expression or a block of Nim code as argument
and compiles that Nim code to an abstract syntax tree representation. The advantage of <span class="func">quote()</span> is that the passed Nim code can contain <span class="type">NimNode</span> expressions from the surrounding scope.
The <span class="type">NimNode</span> expressions have to be quoted using backticks.</p>
</div>
<div class="paragraph">
<p>As a first very simple example for the use of the <span class="code">quote do:</span> construct, we will present a way to print some debugging output.</p>
</div>
<div class="paragraph">
<p>Assume we have a larger Nim program which works not in the way that we expected, so we would add some
<span class="func">echo()</span> statements like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var currentSpeed: float = calcSpeed(t)
echo "currentSpeed: ", currentSpeed</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead of the <span class="func">echo()</span> statement, we would like to just write <span class="func">show(currentSpeed)</span>
to get exactly the same output. For that, we need access not only to the actual value
of a variable, but also to its name. Nim <span class="mac">macros</span> can give us this information, and
by using the <span class="code">quote do:</span> construct it is very easy to create our desired <span class="func">showMe()</span> <span class="mac">macro</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro show(x: untyped): untyped =
  let n = x.toStrLit
  result = quote do:
    echo `n`,": ", `x`

import math
var a = 7.0
var b = 9.0
show(a * sqrt(b))</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run that code, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a * sqrt(b): 21.0</pre>
</div>
</div>
<div class="paragraph">
<p>In the <span class="mac">macro</span> body we use the <span class="proc">proc</span> <span class="func">toStrLit()</span> from the <span class="mod">macros</span> module which is
described with this comment: "Converts the AST n to the concrete Nim code and wraps that in a string literal node"
So our local variable <span class="var">n</span> in the <span class="mac">macro</span> body is a <span class="type">NimNode</span> that now contains the <span class="str">string</span> representation of the <span class="mac">macro</span>
argument <span class="var">x</span>. We use the <span class="type">NimNode</span> <span class="var">n</span> enclosed with backtics in the <span class="code">quote do:</span> construct.
It seems that writing this <span class="mac">macro</span> was indeed not that difficult, but actually it was only that easy because we have
basically copied the <span class="func">dump()</span> <span class="mac">macro</span>
from the <span class="mod">sugar</span> module of Nim&#8217;s standard library.</p>
</div>
<div class="paragraph">
<p>Let us investigate our <span class="func">show()</span> <span class="mac">macro</span> in some more detail to learn more about the inner working of
Nim <span class="mac">macros</span>. First, recall that <span class="mac">macros</span> always have a return value of data type <span class="type">untyped</span>, which is actually a <span class="type">NimNode</span>.
The <span class="code">quote do:</span> construct gives us a result which we can use as the return value of our <span class="mac">macro</span>.
Sometimes
we may see macros with no result type at all, which is currently identical to the <span class="type">untyped</span> result type.
As the macro body is executed at compile time, the <span class="code">quote do:</span> construct
is executed at compile time as well, that is that the code block which we pass to the <span class="code">quote do:</span> construct is processed
at compile time and the quoted <span class="type">NimNodes</span> in the block are interpolated at compile time. For our program from above, the
actual <span class="func">echo()</span> statement in the block is then finally executed at program runtime. To prove how this final <span class="func">echo()</span> statement looks we may
add as the last line of our <span class="mac">macro</span> the statement <span class="code">"echo result.repr"</span> and we would then get the <span class="str">string</span> "echo "a * sqrt(b)", ": ", a * sqrt(b)" when we compile our program again.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_the_ast_manually">Building the AST manually</h3>
<div class="paragraph">
<p>In the two sections before, we used the functions <span class="func">parseStmt()</span> and <span class="func">quote()</span> to build the AST from a
textual representation of Nim code. That can be convenient, but is not very flexible.
In this section, we will learn how we can build a valid AST from scratch by calling
functions of the <span class="mod">macros</span> module. That is not that easy, but this way we have the full power of
the Nim meta-programming available.</p>
</div>
<div class="paragraph">
<p>Luckily, the <span class="mod">macros</span> module provides some macros like <span class="func">dumpTree()</span> and <span class="func">dumpAstGen()</span> which can help
us get started. We will create again a macro similar to the <span class="func">show()</span> <span class="mac">macro</span> that we created before with the
<span class="code">quote do:</span> construct, but now with elementary instructions from the <span class="mod">macros</span> module. This may look a bit boring,
but this plain example is already complicated enough for the beginning, and it shows use the basics to construct much more powerful <span class="mac">macros</span> later.</p>
</div>
<div class="paragraph">
<p>The core code of our <span class="func">debug()</span> <span class="mac">macro</span> would look in textual representation like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var a, b:int
echo "a + b", ": ", a + b</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, for debugging we would like to print an expression first in its <span class="str">string</span> representation, and
divided by a colon the evaluated expression. The <span class="func">dumpTree()</span> <span class="mac">macro</span> can show us how the Nim syntax tree
for such a print debug statement should look:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

var a, b: int

dumptree:
  echo "a + b", ": ", a + b</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile this code, we get as output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> StmtList
  Command
    Ident "echo"
    StrLit "a + b"
    StrLit ": "
    Infix
      Ident "+"
      Ident "a"
      Ident "b"</pre>
</div>
</div>
<div class="paragraph">
<p>So the Nim syntax tree for the <span class="func">echo()</span> statement from above is a statement list
consisting of an <span class="func">echo()</span> command with two <span class="str">string</span> literal arguments and a last argument which
is built with the infix &#43; operator and the two arguments <span class="var">a</span> and <span class="var">b</span>. So we can see how the
AST that we would have to construct would have to look, but we still have no idea how
we could construct such an AST in detail. Well, the <span class="mod">macros</span> module would contain the functions what we
need for that, but it is not easy to find the right functions there. The <span class="func">dumpAstGen()</span> <span class="mac">macro</span>
can list us exactly the needed functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

var a, b: int

dumpAstGen:
  echo "a + b", ": ", a + b</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Compiling that code gives us:</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre> nnkStmtList.newTree(
  nnkCommand.newTree(
    newIdentNode("echo"),
    newLit("a + b"),
    newLit(": "),
    nnkInfix.newTree(
      newIdentNode("+"),
      newIdentNode("a"),
      newIdentNode("b")
    )
  )
)</pre>
</div>
</div>
<div class="paragraph">
<p>This is a nested construct. The most outer instruction constructs a new tree of Nim Nodes with the node type statement list.
The next construct creates a tree with node kind command, which again contains the ident node with name <span class="func">echo</span>,
which again contains two literals and the infix &#43; operator.</p>
</div>
<div class="paragraph">
<p>Indeed, we can use the output of the <span class="func">dumpAstGen()</span> <span class="mac">macro</span> directly to create a working Nim program:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

var a, b: int

#dumpAstGen:
#  echo "a + b", ": ", a + b

macro m(): untyped =
  nnkStmtList.newTree(
    nnkCommand.newTree(
      newIdentNode("echo"),
      newLit("a + b"),
      newLit(": "),
      nnkInfix.newTree(
        newIdentNode("+"),
        newIdentNode("a"),
        newIdentNode("b")
      )
    )
  )

m()</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run that code, we get the output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a + b: 0</pre>
</div>
</div>
<div class="paragraph">
<p>So the AST from above is fully equivalent to the one line <span class="func">echo()</span> statement.
But now we would have to investigate how we can pass an actual expression
to our <span class="mac">macro</span> and how we can use that passed argument in the <span class="mac">macro</span> body&#8201;&#8212;&#8201;first print its textual form, and then the evaluated value separated by a colon.
And there is one more problem: That nested <span class="mac">macro</span> body from above is not really useful for
our final <span class="func">dump()</span> <span class="mac">macro</span>, as we would like to be able to construct the <span class="type">NimNode</span>, that is
returned by the <span class="func">dump()</span> <span class="mac">macro</span> step wise: Add the <span class="func">echo()</span> command, then the passed expression
in <span class="str">string</span> form, and finally the evaluated expression. So let us first rewrite the above <span class="mac">macro</span> in a form
where the AST is constructed step by step. That may look difficult, but when we know that
we can call the <span class="func">newTree()</span> function with only one node kind parameter to create an empty tree
of that kind, and that we can later use the overloaded <span class="func">add()</span> <span class="proc">proc</span> to add new nodes to that tree, then
it is easy to guess how we can construct the macro body:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim"> import macros

var a, b: int

#dumpAstGen:
#  echo "a + b", ": ", a + b

macro m(): untyped =
  nnkStmtList.newTree(
    nnkCommand.newTree(
      newIdentNode("echo"),
      newLit("a + b"),
      newLit(": "),
      nnkInfix.newTree(
        newIdentNode("+"),
        newIdentNode("a"),
        newIdentNode("b")
      )
    )
  )

macro m2(): untyped =
  result = nnkStmtList.newTree()
  let c = nnkCommand.newTree()
  let i = nnkInfix.newTree()
  i.add(newIdentNode("+"))
  i.add(newIdentNode("a"))
  i.add(newIdentNode("b"))
  c.add(newIdentNode("echo"))
  c.add(newLit("a + b"))
  c.add(newLit(": "))
  c.add(i)
  result.add(c)

m2()</code></pre>
</div>
</div>
<div class="paragraph">
<p>First we create the tree empty three structures of node kinds
statement list, command and infix operator. Then we use the overloaded <span class="func">add()</span>
proc to populate the threes, using <span class="proc">procs</span> like <span class="func">newIdentNode()</span> or <span class="func">newLit()</span> to
create the nodes of matching types as before. When we run our program with the modified
<span class="mac">macro</span> version <span class="func">m2()</span> we get again the same output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a + b: 0</pre>
</div>
</div>
<div class="paragraph">
<p>The next step to create our actual <span class="func">dump()</span> macro is again easy&#8201;&#8212;&#8201;we pass the expression to <span class="func">dump()</span>
as an <span class="type">untyped</span> <span class="mac">macro</span> parameter to the <span class="mac">macro</span>, convert it to a <span class="type">NimNode</span> of <span class="str">string</span> type and use that
instead of the <span class="code">newLit("a &#43; b")</span> from above. In our second <span class="mac">macro</span>, where we used the <span class="code">quote do:</span> construct,
we applied already <span class="func">toStrLit()</span> on an <span class="type">untyped</span> <span class="mac">macro</span> parameter, so we should be able to reuse that
to get the <span class="str">string</span> <span class="type">NimNode</span>. Instead, we would have to apply the stringify operator additional
on that value. But a simpler way is to just apply <span class="func">repr()</span> on the <span class="type">untyped</span> <span class="mac">macro</span> argument to
get a <span class="type">NimNode</span> of <span class="str">string</span> type. And finally, to get the value of the evaluated expression in our <span class="func">dump()</span>
macro, we <span class="func">add()</span> the <span class="type">untyped</span> <span class="mac">macro</span> parameter directly in the command three&#8201;&#8212;&#8201;that value is
evaluated when we run the <span class="mac">macro</span> generated code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

var a, b: int

macro m2(x: untyped): untyped =
  var s = x.toStrLit
  result = nnkStmtList.newTree()
  let c = nnkCommand.newTree()
  c.add(newIdentNode("echo"))
  c.add(newLit(x.repr))
  #c.add(newLit($s))
  c.add(newLit(": "))
  c.add(x)
  result.add(c)

m2(a + b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, we get the desired output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre> a + b: 0</pre>
</div>
</div>
<div class="paragraph">
<p>So our <span class="func">dump()</span> <span class="mac">macro</span> called still <span class="func">m2()</span> is complete and can be used
to debug arbitrary expression. Note that this <span class="mac">macro</span> works for arbitrary expressions, not only
for numerical ones. We may use it like</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">m2(a + b)
let what = "macros"
m2("Nim " &amp; what &amp; " are not that easy")</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>and get the output</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>a + b: 0
"Nim " &amp; what &amp; " are not that easy": Nim macros are not that easy</pre>
</div>
</div>
<div class="paragraph">
<p>Now let us extend our <span class="func">debug()</span> <span class="mac">macro</span> so that it can accept multiple arguments.
The needed modifications are tiny, we just pass instead of a single <span class="type">untyped</span>
argument an argument of type <span class="type">varargs[untyped]</span> to the debug macro, and iterate
in the <span class="mac">macro</span> body with a <span class="key">for</span> loop over the <span class="type">varargs</span> argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import macros

macro m2(args: varargs[untyped]): untyped =
  result = nnkStmtList.newTree()
  for x in args:
    let c = nnkCommand.newTree()
    c.add(newIdentNode("echo"))
    c.add(newLit(x.repr))
    c.add(newLit(": "))
    c.add(x)
    result.add(c)

var
  a = 2
  b = 3
m2(a + b, a * b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile and run that code, we get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>a + b: 5
a * b: 6</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_assert_macro">The Assert Macro</h3>
<div class="paragraph">
<p>As one more simple example, we will show how we can create our own
<span class="func">assert()</span> <span class="mac">macro</span>. The <span class="func">assert()</span> has only one argument, which is an expression with
a boolean result. If the expression evaluates to <span class="lit">true</span> at program runtime, then
the <span class="func">assert()</span> <span class="mac">macro</span> should do nothing. But when the expression evaluates to
<span class="lit">false</span>, then this indicates a serious error and the <span class="mac">macro</span> shall print the
expression which evaluated to <span class="lit">false</span>, and then terminate the program execution.
This is basically what the <span class="func">assert()</span> <span class="mac">macro</span> in the Nim standard library already does,
and the official Nim macros tutorial contains such an <span class="func">assert()</span> <span class="mac">macro</span> as well.</p>
</div>
<div class="paragraph">
<p>Arguments for our <span class="func">assert()</span> <span class="mac">macro</span> may look like <span class="code">"x == 1 &#43;2"</span>, containing one infix
operator and one left-hand and one right-hand operand. We will show how we can use
subscript <span class="op">[]</span> operators on the <span class="type">NimNode</span> argument to access each operand.</p>
</div>
<div class="paragraph">
<p>As a first step, we use the <span class="func">treeRepr()</span> function from the <span class="mod">macros</span> module to show us the
Nim tree structure of a boolean expression with an infix operator:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/macros

macro myAssert(arg: untyped): untyped =
  echo arg.treeRepr

let a = 1
let b = 2

myAssert(a != b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we compile that program, then the output of the <span class="func">treeRepr()</span> function
shows us, that we have passed as argument an infix operator with two operands at index position 1 and 2.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Infix
  Ident "!="
  Ident "a"
  Ident "b"</pre>
</div>
</div>
<div class="paragraph">
<p>Now let us create an <span class="func">assert()</span> macro which accept such a boolean expression with
an infix operator and two operands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/macros

macro myAssert(arg: untyped): untyped =
  arg.expectKind(nnkInfix) # NimNodeKind enum value
  arg.expectLen(3)
  let op = newLit(" " &amp; arg[0].repr &amp; " ") # operator as string literal NimNode
  let lhs = arg[1] # left hand side as NimNode
  let rhs = arg[2] # right hand side as NimNode
  result = quote do:
    if not `arg`:
      raise newException(AssertionDefect,$`lhs` &amp; `op` &amp; $`rhs`)

let a = 1
let b = 2

myAssert(a != b)
myAssert(a == b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first two function calls <span class="func">expectKind()</span> and <span class="func">expectLen()</span> verify that the <span class="mac">macro</span> argument
is indeed an infix operator with two operands, that is, the total length of the argument is 3.
The symbol nnkInfix is an <span class="type">enum</span> value of the <span class="type">NimNodeKind</span> data type defined in the <span class="mod">macros</span> module&#8201;&#8212;&#8201;that
module follows the convention to prepend <span class="type">enum</span> values with a prefix, which is <span class="lit">nnk</span> for <span class="type">NimNodeType</span> in this case.
In the <span class="mac">macro</span> body, we use the subscript operator <span class="var">[0]</span> to access the operator, and then apply
<span class="func">repr()</span> on it to get its string representation. Further, we use the subscript operators <span class="op">[1]</span> and <span class="op">[2]</span>
to extract the two operands from the macro argument and store the result each in a <span class="type">NimNode</span>
<span class="var">lhs</span> and <span class="var">rhs</span>. Finally, we create the <span class="code">quote do:</span> construct with its indented multi-line
<span class="str">string</span> argument and the interpolated <span class="type">NimNode</span> values enclosed in backtics. The
block after the <span class="code">quote do:</span> construct checks if the passed <span class="var">arg</span> <span class="mac">macro</span> argument evaluates
to <span class="lit">false</span> at runtime, and raises an exception in that case, displaying the reconstructed
argument.</p>
</div>
<div class="paragraph">
<p>We have to admit that this <span class="mac">macro</span> is not really useful in real life, as it is restricted to
simple boolean expressions with a single infix operator. And what it does in its body
makes not much sense: The original <span class="mac">macro</span> argument is split in tree parts, the
infix operator and the two operands, which are then just joined again to show
the exception message. But at least we have learned how we can access the various
parts of a <span class="mac">macro</span> argument by use of subscript operators, how we can use the <span class="func">treeRepr()</span>
function from the <span class="mod">macros</span> module to inspect a <span class="mac">macros</span> argument, and how we can
ensure that the <span class="mac">macro</span> argument has the right shape for our actual <span class="mac">macro</span> by applying
functions like <span class="func">expectKind()</span> and <span class="func">expectLen()</span> early in the <span class="mac">macro</span> body.</p>
</div>
</div>
<div class="sect2">
<h3 id="_pragma_macros">Pragma Macros</h3>
<div class="paragraph">
<p>All <span class="mac">macros</span> and <span class="key">templates</span> can also be used as pragmas. They can be attached to routines (procs, iterators, etc.), type names, or type expressions.
In this section we will show a small example how a <span class="proc">proc</span> pragma can be used to print
the <span class="proc">proc</span> name whenever a <span class="proc">proc</span> annotated with that pragma is called:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/macros

dumpAstGen: # let us see how the NimNode for an echo statement has to look
  proc test(i: int) =
    var thisProcName = "test"
    echo thisProcname
    echo 2 * i

macro pm(arg: untyped): untyped = # a pragma macro
  expectKind(arg, nnkProcDef) # assert that macro is applied on a proc
  let node = nnkCommand.newTree(newIdentNode("echo"), newLit($name(arg)))
  insert(body(arg), 0, node)
  result = arg

proc myProc(i: int) {.pm.} =
  echo 2 * i

proc main =
  myProc(7)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start with the <span class="func">dumpAstGen()</span> <span class="mac">macro</span> applied to a <span class="func">test()</span> <span class="proc">proc</span> which contains an <span class="func">echo()</span> statement.
So when we compile that code, we get an initial idea how a <span class="type">NimNode</span> that shall print the
proc name should look. To use pragma macros, we annotate the <span class="proc">proc</span> with the <span class="mac">macro</span> name enclosed
in the pragma symbols {..}. The annotated <span class="proc">proc</span> is then passed to the pragma with that name in the form
of a syntax tree. Our goal is to add a <span class="type">NimNode</span> to this tree that prints the <span class="proc">proc</span> name of the passed AST.
To do that we have to know two important points: For the proc that is passed as <span class="type">untyped</span> data type to our
<span class="mac">macro</span>, we can use the function <span class="func">body()</span> to get the AST representation of the body of the passed <span class="proc">proc</span>,
and we can use <span class="func">name()</span> to get the name of that <span class="proc">proc</span>. The functions <span class="func">body()</span> and <span class="func">name()</span> are provided
by the <span class="mod">macros</span> module of Nim&#8217;s standard library. In our <span class="mac">macro</span> <span class="func">pm()</span> we first verify, that the passed
argument is really of node kind ProcDef. Then we create a new <span class="type">NimNode</span>, which calls the <span class="func">echo()</span> function
with the <span class="proc">proc</span> name as parameter. And we insert that node at position 0 into the body of the passed <span class="proc">proc</span>.
Finally, we return the modified AST.</p>
</div>
<div class="paragraph">
<p>When we run our program, we get this output in the terminal window:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./t
myProc
14</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pragma_macro_for_iterator">Pragma Macro for Iterator</h3>
<div class="paragraph">
<p>Let us assume we have an <span class="key">object</span> type which has some fields which are all sequences with the same base type, and we need
an iterator to iterate over all the container elements. Indeed, this may happen when the different <span class="type">seqs</span> contain
subclasses of the same parent class, as in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  Group = ref object of Element
    lines: seq[Line]
    circs: seq[Circ]
    texts: seq[Text]
    rects: seq[Rect]
    pads: seq[Pad]
    holes: seq[Hole]
    paths: seq[Path]
    pins: seq[Pin]
    traces: seq[Trace]

iterator items(g: Group): Element =
  for el in g.lines:
    yield el
  for el in g.rects:
    yield el
  for el in g.circs:
    yield el
  ....</code></pre>
</div>
</div>
<div class="paragraph">
<p>Maybe we do not want to write all the <span class="key">for</span> loops in the iterator body manually.
One solution is to create a pragma <span class="mac">macro</span>, which creates the for
loops in the iterator body for us:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/macros

type
  O = object
    a, b, c: seq[int]

macro addItFields(o: untyped): untyped =
  const fields = ["a", "b", "c"]
  expectKind(o, nnkIteratorDef)
  # echo o.treeRepr
  # echo o.params.treeRepr
  let objName = o.params[1][0]
  for f in fields:
    let node =
      nnkStmtList.newTree(
        nnkForStmt.newTree(
          newIdentNode("el"),
          nnkDotExpr.newTree(
            #newIdentNode("o"),
            newIdentNode($objName),
            # newIdentNode("b")
            newIdentNode(f)
          ),
          nnkStmtList.newTree(
            nnkYieldStmt.newTree(
              newIdentNode("el")
            )
          )
        )
      )
    insert(body(o), body(o).len, node)
  result = o
  #echo result.repr

iterator items(o: O): int {.addItFields.} =
  discard

#dumpAstGen:
#  iterator xitems(o: O): int =
#    for el in o.a:
#      yield el

var ox: O
ox.a.add(1)
ox.b.add(2)
ox.c = @[5, 7, 11, 13]

for l in ox.items:
  echo l</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start again with a <span class="func">dumpAstGen()</span> call, which shows us the shape of the <span class="key">for</span> loop node.
In that node, we only have to replace two <span class="func">newIdentNode()</span> calls so that the fields names can be provided
by iterating over an <span class="type">array</span> of <span class="type">strings</span>, and the <span class="key">object</span> name is taken from the iterator parameter.
To get the object name, we first use <span class="func">o.treeRepr</span> to see the whole parameter structure, and then
<span class="func">params.treeRepr</span> to get the structure of the parameters passed to our iterator. Using subscript operators,
we get the actual <span class="key">object</span> name. We insert each new node that we create in the for loop with a call of
<span class="func">insert(body(o), body(o).len, node)</span> as the new last node in the body of the iterator.
We can create a more flexible variant of our above <span class="mac">macro</span>, when we pass
the actual field names as additional parameter to the pragma <span class="mac">macro</span>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/macros

type
  O = object
    a, b, c: seq[int]

macro addItFields(fields: openArray[string]; o: untyped): untyped =
  expectKind(o, nnkIteratorDef)
  let objName = o.params[1][0]
  for f in fields:
    let node =
      nnkStmtList.newTree(nnkForStmt.newTree(newIdentNode("el"),
          nnkDotExpr.newTree(newIdentNode($objName),newIdentNode($f)),
          nnkStmtList.newTree(nnkYieldStmt.newTree(newIdentNode("el")))))
    insert(body(o), body(o).len, node)
  result = o

iterator items(o: O): int {.addItFields(["a", "b", "c"]).} =
  discard

var ox: O
ox.a.add(1)
ox.b.add(2)
ox.c = @[5, 7, 11, 13]

for l in ox.items:
  stdout.write l, ' '</code></pre>
</div>
</div>
<div class="paragraph">
<p>When we run this macro or the one before, we get</p>
</div>
<div class="listingblock">
<div class="content">
<pre>1 2 5 7 11 13</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_macros_to_generate_new_operator_symbols">Macros to generate new operator symbols</h3>
<div class="paragraph">
<p>Earlier in the book we have already learned how we can define
new <span class="proc">procs</span> and templates which can be used as operators.
In this section, we will learn how we can create a <span class="mac">macro</span> that does not
only create an operator that can work on existing variables, but that can be used
to create new variables. In Nim, we use the <span class="key">var</span> or <span class="key">let</span> keyword to
create new variables. Some other languages allow creating new variables on the fly
by using just "=", ":=" or "!=" to create new variables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/macros

dumpAstGen:
  var xxx: float

macro `!=`(n, t: untyped): untyped =
  let nn = n.repr
  let tt = t.repr
  nnkStmtList.newTree(
    nnkVarSection.newTree(
      nnkIdentDefs.newTree(
        # newIdentNode("xxx"),
        newIdentNode(nn),
        # newIdentNode("float"),
        newIdentNode(tt),
        newEmptyNode()
      )
    )
  )

proc main =
  myVar != int
  myVar = 13
  echo myVar, " ", typeof(myVar)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, <span class="func">dumpAstGen()</span> shows us the structure of the needed AST.
We use <span class="func">repr()</span> to get the <span class="str">string</span> representation of the two
<span class="mac">macro</span> arguments and replace in the <span class="func">dumpAstGen()</span> output the arguments of the <span class="func">newIdentNode()</span>
calls with that values. When we compile and run above program, we get</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ ./t
13 int</pre>
</div>
</div>
<div class="paragraph">
<p>For the case that we should really intend to use such a <span class="mac">macro</span> in our own
code, we should of course add some code to the <span class="mac">macro</span> to check that
the passed arguments have the correct content.</p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://nim-lang.org/docs/manual.html#macros" class="bare">https://nim-lang.org/docs/manual.html#macros</a></p>
</li>
<li>
<p><a href="https://nim-lang.org/docs/tut3.html" class="bare">https://nim-lang.org/docs/tut3.html</a></p>
</li>
<li>
<p><a href="https://nim-by-example.github.io/macros/" class="bare">https://nim-by-example.github.io/macros/</a></p>
</li>
<li>
<p><a href="https://hookrace.net/blog/introduction-to-metaprogramming-in-nim/" class="bare">https://hookrace.net/blog/introduction-to-metaprogramming-in-nim/</a></p>
</li>
<li>
<p><a href="https://flenniken.net/blog/nim-macros/" class="bare">https://flenniken.net/blog/nim-macros/</a></p>
</li>
<li>
<p><a href="https://dev.to/beef331/demystification-of-macros-in-nim-13n8" class="bare">https://dev.to/beef331/demystification-of-macros-in-nim-13n8</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_process_execution">Process execution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we will discuss how we can use multiple threads or Nim&#8217;s async/await
framework to avoid blocking IO (input/output) operations and to enable parallel code
execution on multiple physical CPU cores. The various forms of not strictly linear
and sequential program execution are also called multitasking or multi-threading.
Threading is generally the splitting of one path of actions into various sub-parts,
which can be processed in parallel or concurrent. On a CPU with multiple physical
cores, threads can be distributed between them, while on a CPU with only one core,
all threads have to run obviously alternating on that single core, which is called
concurrency. Parallel processing requires always dedicated physical hardware, that
is multiple CPUs, or a multicore CPU consisting of two or more independent units
called cores.</p>
</div>
<div class="paragraph">
<p>As the CPUs of recent desktop computers often have already a few dozen of cores, and
GPUs may have thousands of them, it has become more and more important to distribute
computing tasks between all these cores to gain optimal performance. Dedicated
programming languages like <span class="ndef">Chapel</span> or <span class="ndef">Pony</span> have been developed for
this task, and most modern programming languages supports it. For older languages
like C extension like <span class="ndef">OpenMP</span> for threading support have been developed.</p>
</div>
<div class="paragraph">
<p>The various forms of asynchronous operation were introduced due to the fact that some
input and output operations and network requests can be very slow compared to the
data processing rate of the CPU. It would be very wasteful when the CPU has to be
idle while a slow network data transfer or a floppy disk operation is performed.
Actually, asynchronous operation was already done long before the first multicore
CPUs were available.</p>
</div>
<div class="paragraph">
<p>While Nim has already good support for threading and asynchronous- and parallel
processing, all this is still some work in progress, so things may further improve in the
future.</p>
</div>
<div class="paragraph">
<p>When we launch a computer program on our desktop PC, then the operating system creates an
instance of a new process, sometimes also called a task, to execute the application.
Each process is strongly separated from other processes that may also be running on the
computer, each process has its own memory regions (RAM) that it may use, and when one
process should crash for some reason other processes are not concerned. Processes
can have various states defined by the OS, this includes some form of running, idle,
ready, waiting or halted. A process executes one or multiple threads, which can run
concurrent or parallel on multiple physical CPU cores. All the threads of one single
process can use common resources and access common variables, which enables data
exchange between threads, with some restrictions. Data exchange between different,
separated processes is not that easy, but it is also possible by use of
<span class="ndef">inter-process-communication</span> protocols. Early PC operating systems executed only one
process at a time, sometimes the user was able to switch between multiple launched
processes. Modern operating systems do a fast switching between all the ready processes, so that
the user gets the feeling that all of them are running in parallel, even when the CPU
has only one physical core. The fast switching between processes is called
multitasking or concurrent execution. Unfortunately, these two terms are a bit
misleading, as they seem to imply true parallel execution on multiple physical CPU
cores. But the term concurrency actually only indicates the fast switching process&#8201;&#8212;&#8201;for a few micro-second one process may be executed, then an automatic task switch occurs,
which includes saving and restoring of all the CPU registers and states, and the next
process is executed again for a few micro-second. This form of concurrency was already a big
progress for the desktop PC, as it was possible to run processes with a heavy work
load, like a compiler, while the user was still able to use his text editor or web
browser without noticing serious delays for key and mouse input or display updates.
Concurrency is typically supported by smart hardware, which can interrupt the current
work of the CPU to temporarily execute a different code segment. Hardware like disc
controllers or network cards have its own data buffers or can access parts of the RAM
directly by <span class="ndef">DMA (Direct Memory Access)</span> and notice the CPU by so-called
<span class="ndef">interrupt signals</span> when a buffer is full (or empty) or when another condition
is met, e.g. when new network data are available. This interrupt system can
drastically improve performance and throughput, as active waiting in polling busy
loops for new network or disk data can be avoided&#8201;&#8212;&#8201;the CPU is free to process one
of the other waiting processes until interrupt signals indicate filled/empty data
buffers or other conditions that require active CPU intervention.</p>
</div>
<div class="paragraph">
<p>This form of (hardware interrupt driven) concurrency needs generally some software
support, e.g. the Linux kernel may use the <span class="ndef">epoll</span> system for I/O event
notifications. Initially it was a common practice to connect so-called
<span class="ndef">callback functions</span> to interrupt driven signals, e.g. a callback function was
invoked whenever some network data package has arrived. Some C programs and system
libraries work still this way, for example the <span class="ndef">glib</span> library of the
<span class="ndef">GTK GUI</span> toolkit. But use of callbacks can become difficult and confusing for
large applications, sometimes it was called a <span class="ndef">"callback hell"</span>. So languages
like Java, JavaScript or Python introduced a framework called <span class="ndef">async/await</span> to
simplify the process of writing non-blocking asynchronous software. The async/await
framework actually hides the use of callbacks or use of system functions like epoll
from the user. This asynchronous programming style has gained some popularity due to
the fact that many programs perform a lot of network communication, where data is
transferred often slow compared to the processing power of the CPU. The Nim standard
library provides an async/await framework which can be used similarly as that
of Python, and the external Chronos package of <span class="ndef">Status corp.</span> offers one more
similar package. Additionally, there was a discussion of some Nim developers to
support or replace the async/await framework with a more flexible CPS based one. We
should mention, that async/await has its drawbacks&#8201;&#8212;&#8201;its internal working is
difficult, its usage is not always easy, and the user has to be careful when using
asynchronous and synchronous functions together. Async/await was definitely the best
option when desktop PCs had only one single CPU core, but with the arrival of
multicore CPUs the importance of asynchronous operations has become less important,
as using many threads running in parallel has become an alternative solution. It is
said that asynchronous program execution has less overhead than just using parallel
processing on multiple cores, that may be one reason why asynchronous programming is
still very popular.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Note that Nim&#8217;s async/await
framework
is not a direct component of the Nim language, but is
provided by libraries which are created by use of Nim&#8217;s
macro and meta-programming capacities.
While the async/await system of the standard library do not
support parallel execution directly, but is executed
only on a single thread, it is generally possible
to use async/await with threads running in parallel.
As an example for that, you may see <a href="https://github.com/dom96/httpbeast" class="bare">https://github.com/dom96/httpbeast</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>For Nim, we have many different ways to do parallel program execution, and for the
async/await framework of Nim&#8217;s standard library the <span class="ndef">chronos</span> alternative
implementation is available. Creating new threads, which are executed in parallel
when the CPU has multiple physical cores, is supported by the <span class="mod">threads</span> module.
Additionally the Nim standard library provides the <span class="mod">threadpool</span> module, which can
create a pool of threads, which may be used by the <span class="key">spawn</span> construct or the
<span class="key">parallel</span> keyword. Additional, external packages like <span class="var">weave</span> can be
used for high performance parallel processing. And finally, when we use the C
compiler backend, we may also use the parallel construct of the OpenMP C library.</p>
</div>
<div class="paragraph">
<p>Some other programming languages like Lua or Go offer also virtually (green) threads,
or coroutines and fibers, and some languages use the CPS system for a very flexible
parallel and asynchronous framework. Maybe Nim will support that also in the future.</p>
</div>
<div class="paragraph">
<p>The biggest problem of high performance parallel data processing is the exchange of
data between threads, which has to be performed with much care to avoid data
corruption by uncoordinated random access or race conditions. For this mutexes, locks
and atomic operations can be used to control the access of common variables, or
<span class="type">Channels</span> can be used to send data from one thread to another one. Another
problem for parallel thread execution can result from the Garbage Collector. For a
system design, where a single GC accesses all data of a process, it can be necessary
to stop all the threads of a process while the GC does its work. Nim is using for
each thread a separate heap area and a thread local GC, so other threads can continue
their work while the GC cleans up the data of one single thread. The concern of
passing data between treads still exists, but the new ARC/ORC memory management
system may further improve the situation.</p>
</div>
<div class="paragraph">
<p>In the following sections of the book, we will first demonstrate a few ways to use
multiple threads, which will run in parallel when there are more than one physical
CPU core available. After that, we will investigate basic async/await operations and
show how we can send data from one thread to another by use of the <span class="mod">channels</span> module.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Note: Whenever we intend to use threads in Nim, that is when we import the <span class="var">threadpool</span>
or the <span class="mod">threads</span> module, we have to compile our program with the option <span class="term">--threads:on</span>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_module_threadpool">Module threadpool</h3>
<div class="paragraph">
<p>Creating new threads is always some overhead, so it can make sense to create a pool
of threads, which we then can use to execute parts of our program.</p>
</div>
<div class="sect3">
<h4 id="_using_spawn_to_execute_a_proc_by_one_thread_of_the_pool">Using spawn to execute a proc by one thread of the pool</h4>
<div class="paragraph">
<p>As a first very simple example, we will show how we can use the <span class="func">spawn</span>
procedure of the <span class="mod">threadpool</span> module to request the execution of a regular
proc. This way we create not really a new thread, but we add our <span class="proc">proc</span> to a list of
<span class="proc">procs</span> to execute. When one of the threads in the pool is idle, then our <span class="proc">proc</span> is
immediately executed by a thread, otherwise the execution of our <span class="proc">proc</span> may be delayed
until a thread is ready to execute it. All the threads of the pool are distributed
among the physical cores of the CPU, so we can really execute <span class="proc">procs</span> in parallel. We
have to compile the code using <span class="func">spawn()</span> with the <span class="code">--d:threads=on</span>
option:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/threadpool
proc sum(i: int): int =
  var j = 0
  while j &lt; i:
    inc(j)
    result += j

proc main =
  var a: FlowVar[int] = spawn sum(1e7.int)
  var b = spawn sum(1e7.int)
  echo ^a , " ", ^b

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">spawn()</span> function executes an ordinary Nim function by a thread of the
pool. Note that syntactically we do not pass a function and the function&#8217;s arguments
to <span class="func">spawn</span>, but an expression, which is the actual call of the <span class="proc">proc</span>!
<span class="func">Spawn()</span> returns immediately a variable of <span class="type">FlowVar[T]</span> type, which is
a container type that can store the result of our passed function. In the example
above we used FlowVar[int] as our <span class="proc">proc</span> <span class="var">sum</span> returns an integer value, but of
course the generic <span class="type">FlowVar[T]</span> type works for other data types as well,
including sequence and object types. As the instances of <span class="type">FlowVar[T]</span> type
are returned immediately by <span class="func">spawn()</span>, these container variables may be empty
initially. We may then use functions like <span class="func">isReady()</span> from the
<span class="mod">threadpool</span> module to test if the <span class="type">FlowVar[T]</span> variable contains
already the result data, or we can do a blocking wait for the result of our <span class="proc">proc</span> with
the <span class="op">^</span> operator. The <span class="op">^</span> operator applied to the <span class="type">FlowVar[T]</span>
variable waits for the thread to finish the execution of our <span class="proc">proc</span> and then returns
the actual result. If the thread is already finished when we apply the <span class="op">^</span>
operator, we get the result immediately. As <span class="op">^</span> does a blocking wait, it may
look as there would not be much benefit, but of course we can launch a number of
threads with <span class="func">spawn</span>, which can be processed in parallel, and then we wait
with <span class="op">^</span> on all the results.</p>
</div>
<div class="paragraph">
<p>In the example above, we use a plain <span class="proc">proc</span> which sums up the first <span class="var">i</span> natural
numbers, very similar to our very first example program in part I of the book. We
use <span class="func">spawn()</span> to launch two instances of that <span class="proc">proc</span>, and then wait for the
results with the <span class="op">^</span> operator applied to the flowvar. If your PC has more than
one physical CPU core, then both <span class="proc">proc</span> instances should be running in parallel, taking
only the total time of one single run. You may compile and launch the above code with
<span class="code">nim c --threads:on t.nim; time ./t</span> to see the execution time, then comment
out the second <span class="func">spawn</span> call as well as the <span class="func">echo()</span> call for
<span class="type">Flowvar</span> <span class="var">b</span> and compile and run timed again. Times should be nearly
identical when your PC has at least two CPU cores, indicating true parallel
execution. Of course, launching multiple times the same <span class="proc">proc</span> with the same data makes
not much sense, but in real life we could launch it with different data, or we could
use different <span class="proc">procs</span>.</p>
</div>
<div class="paragraph">
<p>As one more example for the use of <span class="func">spawn()</span>, let us investigate how we can
avoid the blocking behavior of the <span class="func">readLine()</span> <span class="proc">proc</span> that we used earlier in
the book. Without special care, a call of <span class="func">readLine()</span> blocks the main thread
of our process, so our program would not be able to do some useful work or to update
the display until the user terminates his textual input request by pressing the
return key. One possible option to avoid a blocking request for user input may be
the use of the async/await framework, but that may not work well for the current Nim
implementation. So let us just use <span class="func">spawn</span> to execute <span class="func">readLine()</span> on
one of the threads of the pool:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/threadpool
from std/os import sleep
proc doSomeWork =
  echo "not really working that hard..."
  sleep(1000) # sleep 1000 ms

proc main =
  var userInput: FlowVar[string] = spawn readLine(stdin)
  while not userInput.isReady:
    doSomeWork()
  echo "You finally entered: ", ^userInput

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we use <span class="func">spawn()</span> to execute the <span class="func">readLine()</span> function
of Nim&#8217;s standard library by a thread of the <span class="mod">treadpool</span> module. We use the
function <span class="func">isReady()</span> to test if the user input is already available, and call
a worker procedure if there is no input yet. As we have no real work to do, that
proc just echos a message and calls <span class="func">os.sleep()</span> to create a delay. Note that
we use the <span class="func">echo()</span> call in <span class="func">doSomeWork()</span> only to show what is going
on&#8201;&#8212;&#8201;it is obvious that the repeated printed message would interfere with the user
input echoed by the terminal window. Actually, this example is not really that nice,
but it shows you the use of <span class="func">isReady()</span> and at least one possible way to
request user input without blocking the whole app.</p>
</div>
</div>
<div class="sect3">
<h4 id="_the_parallel_statement">The parallel statement</h4>
<div class="paragraph">
<p>With the <span class="key">parallel</span> statement, the <span class="mod">threadpool</span> module offers one more way
to use threads to process data in parallel. While the <span class="key">parallel</span> statement is
already available in Nim since many years, it was recently labeled as
<span class="ndef">experimental feature</span>, so we have to use the <span class="code">{.experimental.}</span> pragma
to use it. And the detailed description is currently only available in the
experimental section of the manual:
<a href="https://nim-lang.org/docs/manual_experimental.html#parallel-amp-spawn-parallel-statement" class="bare">https://nim-lang.org/docs/manual_experimental.html#parallel-amp-spawn-parallel-statement</a></p>
</div>
<div class="paragraph">
<p>With the <span class="key">parallel</span> statement it is easily possible to process large data, e.g.
arrays or sequences, in parallel. The compiler proves the data access for us to
avoid data races or otherwise invalid operations. As a very simple example, we will
sum up the elements of an integer <span class="type">array</span> by use of two threads running in
parallel&#8201;&#8212;&#8201;when more than one physical CPU core is available:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/threadpool
{.experimental: "parallel".}

proc sum(i, j: int; a: array[8, int]): int =
  for k in i .. j:
    result += a[k]

proc main =
  var a: array[8, int]
  for i in a.low .. a.high:
    a[i] = i

  var s1, s2: int
  parallel:
    s1 = spawn sum(0, 3, a)
    s2 = spawn sum(4, 7, a)
  echo s1, " + ", s2

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Inside the parallel block, we use again <span class="func">spawn</span> to launch a function, which is
then executed by a thread of the threadpool. The <span class="func">sum()</span> function in our
example code sums up a range of <span class="type">array</span> elements. When <span class="func">spawn()</span> is
used inside a <span class="key">parallel</span> block, then its semantic is different: Instead of a
<span class="type">FlowVar[T]</span> <span class="func">spawn()</span> now returns directly the result of the called
proc. We can save these results in ordinary variables and access them freely after
the parallel block. In the above case, we would finally sum up the individual result
to get the total sum of all the array elements.</p>
</div>
<div class="paragraph">
<p>Our example code above is kept very simple by intent to clearly show the principal
use. You may try to modify it to work on sequences with arbitrary runtime sizes
instead of a fixed sized array, and to use more than two threads. For all the details
of the <span class="mod">threadpool</span> module, you should of course consult is documentation.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_threads_module_to_create_new_threads">Using the threads module to create new threads</h3>
<div class="paragraph">
<p>When for some reason we can not use the <span class="mod">threadpool</span> module, or we need more
control over the various threads, then we can create our own treads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc sum(i: int) {.thread.} =
  var j, result: int
  while j &lt; i:
    inc(j)
    result += j
  echo result

proc main =
  var th1, th2: Thread[int]
  createThread(th1, sum, 1e7.int)
  createThread(th2, sum, 1e7.int)
  joinThreads(th1, th2)

main()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="func">createThread()</span> procedure is provided by the <span class="mod">threads</span> module,
which is part of the <span class="mod">system</span> module&#8201;&#8212;&#8201;for that reason, we do not have to
explicitly import it. The <span class="proc">proc</span> that we want to execute in its own, newly created
thread has to be annotated with the {.thread.} pragma and has to use one single
parameter. We pass the generic <span class="type">Thread[T]</span> variable, the <span class="proc">proc</span> to execute and
the <span class="proc">proc</span> parameter to <span class="func">createThread()</span>. The <span class="type">Thread</span> variable must
have the same generic type as the parameter of the <span class="proc">proc</span> that we want to execute. In
our example that parameter type is a plain integer, but of course we can use other
data types including objects, tuples or container types like sequences.</p>
</div>
<div class="paragraph">
<p>As <span class="func">createThread()</span> does not return a result, we call <span class="func">echo()</span> in our
<span class="func">sum()</span> <span class="proc">proc</span> to show what is going on. Actually calling <span class="func">echo()</span> from
within a <span class="proc">proc</span> running as a thread may be not a good idea, as multiple <span class="func">echo()</span>
calls from different threads may interfere. We may use the <span class="mod">locks</span> module to
make the output operation atomic, but to keep our example short and simple, we ignore
that problem for now. The code above creates two newly created threads, which in our
case run the same <span class="proc">proc</span> with the same data. If there is more than one CPU core
available, then the two threads should be executed in parallel by the OS. After
launching our new treads, we can use the <span class="func">joinThreads()</span> procedure to wait for
the termination of all treads&#8201;&#8212;&#8201;we should generally do that before our app
terminates itself.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_channels_for_communication_between_threads">Using Channels for communication between Threads</h3>
<div class="paragraph">
<p>When we use the <span class="var">threadpool</span> and <span class="func">spawn()</span> to execute a function by one
of the threads of the pool, we get immediately the result of the executed function
back when the work of the function is done.</p>
</div>
<div class="paragraph">
<p><span class="type">Threads</span> created with the <span class="func">createThread()</span> function of the
<span class="mod">threads</span> module do not directly return a result, but may be executed for a long
time period, often for the whole lifetime of the main process. Typically it is
necessary to exchange messages and data between these types of threads&#8201;&#8212;&#8201;among
multiple child threads themselves or among them and the process&#8217;s main thread. For
this message- and data-exchange <span class="type">Channels</span> can be used. Nim&#8217;s Channels use
internally a <span class="type">queue</span> for sending data from one thread to another thread. A
<span class="type">queue</span> is a first-in-first-out (FIFO) data structure&#8201;&#8212;&#8201;items put in first
will also be extracted first. That way, the receiving thread will receive the items
in the same order as the sending thread has sent them.</p>
</div>
<div class="paragraph">
<p>The generic <span class="type">Channel[T]</span> data type and the functions to use it are provided by
the <span class="mod">system</span> module, so we do not need to import them. Channels should be used only for
<span class="type">Threads</span> of the <span class="mod">threads</span> module, but not for the hidden threads of the
<span class="mod">threadpool</span> module. <span class="type">Channels</span> allow to send messages and data only in
one direction, for bidirectional communication we would need two separate channels.
Variables of the <span class="type">Channel</span> data type are generally defined at the global
scope, to avoid problems with the thread local garbage collector, and the generic
type of the <span class="type">Channels</span> determines the data type of the messages that we can
send through the <span class="type">Channel</span>. The sent data is deeply copied by the Channel,
which may be not that efficient for large data packages.</p>
</div>
<div class="paragraph">
<p>In the code below, we will present a very simple example for the use of one single
<span class="type">Channel</span>. The <span class="proc">proc</span> <span class="var">sum()</span> sums up again the first <span class="var">n</span> natural
integer numbers, but this time the function sums up the numbers in chunks, and send
the sum of each chunk over the <span class="type">Channel</span> to the parent thread:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var ch: Channel[int]
proc sum(i: int) {.thread.} =
  var j, res: int
  while j &lt; i:
    inc(j)
    res += j
    if j mod 4 == 0:
      ch.send(res)
      res = 0
  ch.send(res) # send the remainder
  ch.send(0) # send zero to indicate termination

proc main =
  var th: Thread[int]
  ch.open()
  createThread(th, sum, 10)
  while true:
    let r = ch.recv()
    if r == 0:
      break
    echo "Received: ", r
  joinThreads(th)
  ch.close()

main()</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre># Expected output:
Received: 10
Received: 26
Received: 19</pre>
</div>
</div>
<div class="paragraph">
<p>The <span class="proc">proc</span> <span class="func">sum()</span> sums up continuously 4 more numbers, and then sends the
partial sum into the channel. The generic <span class="type">Channel[int]</span> variable <span class="var">ch</span>
is defined in global scope. In the <span class="var">main()</span> <span class="proc">proc</span> we create the child thread,
open the <span class="type">Channel</span> and read the <span class="type">Channel</span> data with calls to
<span class="func">recv()</span> until we get a zero value as terminating condition. Finally, we call
<span class="func">joinThreads()</span> to ensure that the child thread was really terminated and call
<span class="func">close()</span> on the channel to close it. Note that in <span class="func">sum()</span> we use an
additional <span class="func">send()</span> call to send the last partial sum, which may have less than
4 sumands and so may not have been sent. Instead of this additional <span class="func">send()</span>
call in the <span class="key">while</span> loop, a condition like <span class="code">if j mod 4 == 0 or i == j:</span>
could be used of course. When we are done, we send the zero value to indicate to the
parent thread that we are done. This way, the parent thread will not wait for more
data that never got send. In the <span class="func">main()</span> <span class="proc">proc</span> we use <span class="func">recv()</span> to read
the data from the <span class="type">Channel</span>. <span class="func">Recv()</span> would block if data is not yet
available. Instead, we could use <span class="func">tryRecv()</span> with returns a tuple, with the
field dataAvailable indicating if there is already something to read available. The
<span class="func">open()</span> function accepts as a second optional argument the number of items that
can be buffered in the internal items queue of the channel. If that limit is reached,
further calls to <span class="func">send()</span> would block until the reading thread has read the
next item. If we restrict the maximum number of items in the <span class="type">Channel</span>, we
may use instead of <span class="func">send()</span> which may block when the channel is full,
<span class="func">trySend()</span> which just returns <span class="lit">false</span> for this case without blocking.</p>
</div>
<div class="paragraph">
<p>Of course, the code example from above makes not much sense, as there is no real
useful work done in parallel, and as there is no reason for <span class="func">sum()</span> to not
just sum up all the elements immediately. But the example should show you the basic
use of <span class="type">Channels</span>, including the need for having a terminating condition.</p>
</div>
</div>
<div class="sect2">
<h3 id="_race_conditions">Race conditions</h3>
<div class="paragraph">
<p>A race condition may occur when two or more threads attempt to read and write to a
shared resource at the same time. Such behavior can result in data corruption or
unpredictable results that are difficult to debug. Let us consider this tiny
example, where two threads increase the value of a global integer variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">var counter: int

proc incCounter(i: int) {.thread.} =
  for j in 0 ..&lt; i:
    var local = counter
    local += 1
    counter = local

const N = 1000

proc main =
  var th1, th2: Thread[int]
  createThread(th1, incCounter, N)
  createThread(th2, incCounter, N)
  joinThreads(th1, th2)

main()
echo N, ": ", counter</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code above, the two threads are running concurrent, and in parallel when your
CPU has at least two physical cores. Each thread increases the global counter
variable <span class="lit">N</span> times, so one may expect a final result of <span class="lit">2 * N</span>. But at
least when the threads are running in parallel, the actual result will be a random
value between <span class="lit">N</span> and <span class="lit">2 *N</span>. The problem is, that the threads do not
increase the global counter in one atomic step, but create a local copy, increase the
value of the copy and write the value back. When the other thread had modified the
global counter variable in between, that modification is overwritten. When the two
threads would run not in parallel but concurrent on only one CPU core, then the
actual result may depend on the way how the OS does the actual task switching.</p>
</div>
<div class="paragraph">
<p>These kinds of problems are sometimes called race conditions, because the actual
behavior is determined by the order in which the various threads access the data.
In the example code, the actual issue results from the copying into the local
variable and later copying the value back&#8201;&#8212;&#8201;a plain inc() executed on the global
variable may work. We used the local copy here to make the problem visible. Whenever
we would work in such an unordered way onto more complicated data like strings or
objects, we would get corrupted data. This example should raise your awareness to all
the concerns which may occur when multiple threads access global data in an
uncontrolled way.</p>
</div>
<div class="paragraph">
<p>We have already learned about Channels, which provide a way to exchange data between
threads without the use of global variables. Other methods to protect global
variables from uncontrolled access which can lead to corrupted states are locks,
mutexes or semaphores. We will give an example to do access control by use of Locks
in the next section. In the example above, we used as global data a primitive value
data type. Even more problems may occur, when we try to use global reference data
types: In the past, the Nim standard library provided special functions like
allocShared() to allocate pointer and reference data types that can be accessed from
multiple treads. But as Nim&#8217;s thread handling may change and improve in the future
further, we will not try to discuss all these details here. It should be enough that
you have a feeling for the concerns that my arise from executing multiple threads
with shared data&#8201;&#8212;&#8201;for the details, you should consult the documentation of Nim&#8217;s
standard library and the compiler manual.</p>
</div>
</div>
<div class="sect2">
<h3 id="_guards_and_locks">Guards and Locks</h3>
<div class="paragraph">
<p>While Nim&#8217;s <span class="type">Lock</span> data type and the corresponding functions are defined in
the <span class="mod">locks</span> module of the standard library, that module contains only minimal
explanations, so we have to consult the experimental section of the compiler manual.</p>
</div>
<div class="paragraph">
<p>In computer science, a lock or mutex (from mutual exclusion) is a synchronization
primitive that enforces limits on access to a resource when there are many threads of
execution. Before that resource is accessed, the lock is acquired, and after the
resource is accessed, it’s released. The simplest type of lock is a binary
semaphore. It provides exclusive access to the locked data. Following this
definition from Wikipedia, Nim&#8217;s locks seems to be actually binary semaphores.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s <span class="type">Locks</span> are generally used together with the <span class="var">guard</span> pragma, which
we can attach to a global variable that is accessed from more than one thread. With
the guard pragma attached, each thread has to first acquire the lock before it is
allowed to access that variable. If the lock is already acquired by another thread,
acquire blocks until that other thread releases the lock to indicate that it is done
with its access. Of course, these possible blocking can decrease the total
performance, so each thread should acquire the lock only when it needs really access
to the protected data and release the lock as soon as possible.</p>
</div>
<div class="paragraph">
<p>We can use the template <span class="var">withLock</span> to access the guarded global variable in a
block&#8201;&#8212;&#8201;<span class="var">withLock()</span> acquires the given lock, and releases the lock again at
the end of the block. Accessing a guarded variable outside a <span class="var">withLock()</span>
block would give a compile time error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/locks
var lock: Lock
var counter {.guard: lock}: int

proc incCounter(i: int) {.thread.} =
  for j in 0 ..&lt; i:
    withLock lock:
      var local = counter
      local += 1
      counter = local

const N = 1000

proc main =
  var th1, th2: Thread[int]
  createThread(th1, incCounter, N)
  createThread(th2, incCounter, N)
  joinThreads(th1, th2)

main()
echo N, ": ", counter</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you now run the above code, the <span class="var">counter</span> should always have the desired value
<span class="lit">2 * N</span>. Note that replacing the <span class="var">withLock</span> with a plain
<span class="func">acquire()</span> and <span class="var">release()</span> pair seems not to work for locks that are
used as guards&#8201;&#8212;&#8201;but actually there is no reason to do that, the <span class="var">withLock</span>
block is easier to use and ensures that <span class="func">acquire()</span> and <span class="var">release()</span> is
always used in matching pairs.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exceptions_in_threads">Exceptions in Threads</h3>
<div class="paragraph">
<p>Whenever a <span class="proc">proc</span> that is running as its own thread is raising an uncaught exception,
then the whole process is terminated and a stack trace with the corresponding error
message is displayed in the terminal window. This applies not only to the threads of
the <span class="mod">threads</span> module, but also when the <span class="func">spawn()</span> function is applied to
run functions by one of the threads in the pool.</p>
</div>
<div class="paragraph">
<p>References</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="http://callbackhell.com/" class="bare">http://callbackhell.com/</a></p>
</li>
<li>
<p><a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/" class="bare">https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Green_threads" class="bare">https://en.wikipedia.org/wiki/Green_threads</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Continuation-passing_style" class="bare">https://en.wikipedia.org/wiki/Continuation-passing_style</a></p>
</li>
<li>
<p><a href="https://github.com/status-im/nim-chronos" class="bare">https://github.com/status-im/nim-chronos</a></p>
</li>
<li>
<p><a href="https://github.com/mratsim/weave" class="bare">https://github.com/mratsim/weave</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Lock_(computer_science" class="bare">https://en.wikipedia.org/wiki/Lock_(computer_science</a>)</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_code_execution_with_asyncawait">Code execution with async/await</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <span class="ndef">async/await</span> framework allows asynchronous code execution by use of only
one single thread&#8201;&#8212;&#8201;the currently active thread can suspend itself when waiting for
data or other events.</p>
</div>
<div class="paragraph">
<p>Async/await is mostly used for IO bound tasks, where a significant amount of time is
spent by waiting for data to become available. In such a scenario, multi-threading,
even when the various threads run parallel on multiple physical CPU cores, would not
really help to improve the throughput or performance.</p>
</div>
<div class="paragraph">
<p>The initial idea of asynchronous operations was to avoid blocking the CPU for longer
time periods during slow network and IO (input/output) requests. Indeed, that made
much sense in times when we read data from floppy disks or magnetic tapes, and send
data with 300 baud modems. And when true parallel thread execution was not possible
at all as CPUs had only one core, and computers with more than one CPU were very
expensive and not used by ordinary people.</p>
</div>
<div class="paragraph">
<p>Today, with network data rates of up to one Gbit/s for our smartphones or home
networks, and SSD devices which have data transfer rates of multiple Gbit/s, it is
not that easy to motivate the use of asynchronous operations at all. Still for server
applications like online shops or communication platforms used by thousands of people
simultaneously, where network throughput is the limiting factor and delays have to be
avoided, the use of async/await may actually provide the best performance. And it can
be combined with threading and parallel program execution when needed.</p>
</div>
<div class="paragraph">
<p>Asynchronous program execution can work with only one thread running on a single CPU
core due to the fact that some hardware like network cards or disk controllers can
read or write small data blocks autonomously without active CPU support, using their
own data buffers or writing to parts of the system RAM by use of DMA (direct memory
access). Theis hardware can signal to the CPU when buffers are full or empty, or when
all data transfer is completed, so that the CPU may copy the buffer content or start
to process or display the data. As this way the external hardware interrupts the
current CPU work, these signals are called hardware interrupts. Operating systems
generally provide various levels of support for these interrupt-driven data transfer
operations, e.g. the epoll framework of the Linux kernel or Kqueue, the scalable
event notification interface in FreeBSD.</p>
</div>
<div class="paragraph">
<p>For user programs, one solution for doing asynchronous IO by watching for hardware
interrupt signals is to connect callback functions to these interrupt signal. That
way the program can launch an IO operation, and perform other work, until that work
is interrupted by a call of the callback function. As most programming languages
support the use of callback functions, these form of asynchronous IO is widely
supported by software libraries, e.g. the glib library of the GTK GUI toolkit. As
doing asynchronous IO with callback can get complicated when we have a lot of nested
IO operations, the async/await workflow was introduced, which allows asynchronous
code to be written in a synchronous style.</p>
</div>
<div class="paragraph">
<p>The async/await pattern is a syntactic feature of many programming languages that
allows an asynchronous, non-blocking function to be structured in a way similar to an
ordinary synchronous function. It is semantically related to the concept of a
coroutine and is often implemented using similar techniques, and is primarily
intended to provide opportunities for the program to execute other code while waiting
for a long-running, asynchronous task to complete, usually represented by promises or
similar data structures.<sup class="footnote">[<a id="_footnoteref_50" class="footnote" href="#_footnotedef_50" title="View footnote.">50</a>]</sup> The
programming language F# (pronounced F sharp) introduced asynchronous workflows with
await points already in 2007 for the version 2.0 of the language. And in 2012
Microsoft released C# in version 5 with async/await support. Later languages like
Haskell, Python, JavaScript and TypeScript, Kotlin, Dart, Julia, Zig, Swift and Rust
used the async/await pattern, and since 2020 it is also available for C++.</p>
</div>
<div class="sect2">
<h3 id="_is_asyncawait_faster_than_multi_threading">Is async/await faster than multi-threading?</h3>
<div class="paragraph">
<p>For IO-bound tasks, the use of async/await can actually have performance benefits.</p>
</div>
<div class="paragraph">
<p>The multithreaded program execution, that we described in the previous sections, is
some form of preemptive multitasking, where switching between the active threads
occurs at arbitrary time intervals controlled by the OS. But the async/await pattern
is a form of co-operative multitasking, which provides the user with full control of
the code execution. We can pause the code execution by using the <span class="key">await</span>
keyword when it really makes sense. e.g. when we have to wait for new data packets or
events, and immediately enable execution of a different code path.</p>
</div>
<div class="paragraph">
<p>As for this form of co-operative multitasking only the code execution path is
changed, but no switching between threads is necessary, additional overhead can be
avoided, and typical problems of multi-threading, like the passing of data between
different threads or race conditions do no exist.</p>
</div>
<div class="paragraph">
<p>So at least in theory the co-operative multitasking controlled by the async/await
pattern is more efficient, and for maximum performance it can be combined with
threading and parallel program execution.</p>
</div>
</div>
<div class="sect2">
<h3 id="_nims_asynchronous_dispatcher">Nim&#8217;s asynchronous dispatcher</h3>
<div class="paragraph">
<p>The core elements of Nim&#8217;s async/await framework are provided by the modules
<span class="mod">std/asyncdispatch</span> and <span class="var">std/asyncfutures</span>.</p>
</div>
<div class="paragraph">
<p>These modules provide a <span class="ndef">dispatcher</span>, a generic <span class="type">Future[T]</span> type
implementation, and the <span class="func">async</span> macro which allows asynchronous code to be
written in a synchronous style with the <span class="key">await</span> keyword.</p>
</div>
<div class="paragraph">
<p>The <span class="mod">asyncdispatch</span> module implements a global dispatcher (technically one per
thread) that is responsible for running the procedures that are registered with
it.<sup class="footnote">[<a id="_footnoteref_51" class="footnote" href="#_footnotedef_51" title="View footnote.">51</a>]</sup></p>
</div>
<div class="paragraph">
<p>Build on top of these two modules, there exists various modules for asynchronous
communication: Module <span class="mod">std/asyncnet</span> implements a high-level asynchronous
sockets API and <span class="mod">std/asynchttpserver</span> implements a high performance
asynchronous HTTP server. Some other modules like <span class="mod">std/httpclient</span> support
synchronous and asynchronous data transfers.</p>
</div>
<div class="paragraph">
<p>Nim&#8217;s async/await framework is not part of the language itself, but implemented with
macros and meta-programming and use of Nim&#8217;s iterators. The underlying
implementation is based on <span class="func">epoll</span> on Linux, IO Completion Ports on Windows
and <span class="func">select</span> on other operating systems.</p>
</div>
<div class="paragraph">
<p>Currently, Nim&#8217;s async/await uses only one single thread on its own, but applications
can combine it with multiple parallel running threads. As an alternative
implementation, we could use <a href="https://github.com/status-im/nim-chronos" class="bare">https://github.com/status-im/nim-chronos</a>, which provides
similar functionality.</p>
</div>
</div>
<div class="sect2">
<h3 id="_asynchronous_procedures">Asynchronous procedures</h3>
<div class="paragraph">
<p>Asynchronous procedures are marked by the {.async.} pragma and must return a generic
<span class="type">Future[T]</span> type or return no result at all. In the later case, a <span class="type">Future[void]</span> is assumed.
A <span class="type">Future</span>, also called <span class="type">Promise</span> in other languages, is a generic container type which holds a value
which is not yet available, but which may be available in the future.
So a <span class="type">Future</span> has some similarity with the generic <span class="type">FlowVar</span> type that we used as return types for
threads of Nim&#8217;s threadpool.</p>
</div>
<div class="paragraph">
<p>Inside asynchronous procedures, the keyword <span class="key">await</span> can be used to call other
asynchronous procedures or procedures which return a <span class="type">Future</span> type.</p>
</div>
<div class="paragraph">
<p>The <span class="key">await</span> keyword will suspend the code execution until the awaited
<span class="type">Future</span> completes. After completion, the asynchronous procedure will resume
its execution. During the period when an asynchronous procedure is suspended, other
asynchronous procedures will be run by the dispatcher.</p>
</div>
<div class="sect3">
<h4 id="_the_generic_futuret_data_type">The generic Future[T] data type</h4>
<div class="paragraph">
<p>The <span class="type">Future[T]</span> data type, which is also called <span class="ndef">Promise</span>,
<span class="ndef">Delay</span> or <span class="ndef">Deferred</span> in other programming languages, acts as a proxy
for a result that is initially unknown or unavailable.</p>
</div>
<div class="paragraph">
<p>We can think of a <span class="type">Future[T]</span> as a container; initially it’s empty, and while
it remains empty, we can’t retrieve its value. At some unknown point in time,
something is placed in the container, and it is no longer empty and we can read out
its value. That is where the name <span class="type">Future</span> comes from.</p>
</div>
<div class="paragraph">
<p>Every asynchronous operation in Nim returns a <span class="type">Future[T]</span> object, where the
<span class="type">T</span> corresponds to the type of value that the <span class="type">Future</span> promises to
store in the future. We don&#8217;t have to know that many details of the internal
structure or behavior of the <span class="type">Future[T]</span> data type, but we can easily
experiment with it without involving any actual asynchronous I/O operations. The code
below shows the behavior of a simple <span class="type">Future[string]</span> object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/asyncdispatch

proc cb(f: Future[string]) =
  echo "executing callback: ", f.read

let f1: Future[string] = newFuture[string]()
echo f1.finished

f1.callback = cb

f1.complete("Nim and its future")
#f1.fail(newException(ValueError, "Future failed"))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can create a new instance of the generic <span class="type">Future[T]</span> data type with the
<span class="func">newFuture[T]()</span> constructor, we can query if the instance variable is already
finished, and we can attach a callback function. Finally, we can call
<span class="func">complete()</span> on it to set its value, which then automatically calls the
attached callback function. Or we can call <span class="func">fail()</span> on it to set an exception,
which later is raised when someone tries to read its value.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_simple_example">Simple example</h3>
<div class="paragraph">
<p>We will start our explanations with a very simple asynchronous program, which will
not do an actual asynchronous data transfer yet, but an asynchronous sleep (wait).
The asynchronous sleep called <span class="func">sleepAsync()</span> actually behaves very similar to
the asynchronous data transfer functions, that is the execution of the actual code
path is suspended until a hardware condition is fulfilled, and the dispatcher
continues with the code execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncdispatch, times]
from std/os import sleep

let to = epochTime()

proc tick(t: string): Future[void] {.async.} =
  for i in 0 .. 1:
    os.sleep(100) # sleep 100 ms
    echo "tick ", t, ((epochTime() - to) * 1000).int, "ms"

let f1: Future[void] = tick(" AAA ")
let f2 = tick(" BBB ")

echo "total time elapsed: ", epochTime() - to</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the code example above, we import the <span class="mod">asyncdispatch</span> module and have
attached the {.async.} pragma to our <span class="func">tick()</span> procedure. As the
<span class="func">tick()</span> <span class="proc">proc</span> does not return any actual data, we use <span class="type">Future[void]</span> as
return type&#8201;&#8212;&#8201;actually, we could leave out the return type for this case. We call
<span class="func">tick()</span> two times with different <span class="type">string</span> arguments and use the
function <span class="func">epochTime()</span> to measure the total execution time of our program.
When we compile and run the code, we get this output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>tick  AAA 100ms
tick  AAA 200ms
tick  BBB 300ms
tick  BBB 400ms
total time elapsed: 0.4007678031921387</pre>
</div>
</div>
<div class="paragraph">
<p>The result is not really surprising, as for each call of <span class="proc">proc</span> <span class="func">tick()</span> the
loop in its body is executed two times, generating a <span class="lit">100 ms</span> delay for each
iteration. But the output will drastically change when we call instead of the
ordinary <span class="func">sleep()</span> function the function <span class="func">sleepAsync()</span> provided by the
<span class="mod">asyncdispatch</span> module:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncdispatch, times]
from std/os import sleep

let to = epochTime()

proc tick(t: string): Future[void] {.async.} =
  for i in 0 .. 1:
    await sleepAsync(100) # suspend code execution for 100 ms
    echo "tick ", t, ((epochTime() - to) * 1000).int, "ms"

let f1: Future[void] = tick(" AAA ")
let f2 = tick(" BBB ")

echo f1.finished, ' ', f2.finished
echo "time: ", epochTime() - to

waitFor f1
# waitFor f1 and f2 # wait for both futures to finish

echo f1.finished, ' ', f2.finished
echo "total time elapsed: ", epochTime() - to</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>false false
time: 9.72e-05
tick  AAA 100ms
tick  BBB 100ms
tick  AAA 200ms
tick  BBB 200ms
true true
total time elapsed: 0.20061</pre>
</div>
</div>
<div class="paragraph">
<p>The two calls of the <span class="func">tick()</span> <span class="proc">proc</span> each returns nearly instantly a
<span class="type">Future[void]</span> object, no waiting happens here. The use of the <span class="key">await</span>
keyword in the <span class="proc">proc</span> body causes the <span class="proc">proc</span> to suspend its execution and control flow
returns to the call site immediately. But at the same time, the asynchronous
<span class="func">tick()</span> <span class="proc">proc</span> got registered by the dispactcher loop, so that it can resume
its execution.</p>
</div>
<div class="paragraph">
<p>The returned <span class="type">Future</span> object encapsulates the actual return type of the call&#8201;&#8212;&#8201;in this case only void&#8201;&#8212;&#8201;and gives us a reference that we can use to ask the
dispatcher whether our call has completed or not.</p>
</div>
<div class="paragraph">
<p>But futures can&#8217;t get resolved by themselves, we need to actually run the dispatcher
in order for any of the code registered with it to resume its execution. Remember, all
of this is still running in a single thread of execution. There are many ways to run
the dispatcher, but in this case it is done by the <span class="func">waitFor</span> call. When we
run <span class="func">waitFor</span>, the dispatcher will run in a loop until the given future is
completed, and the <span class="proc">proc</span> which has returned that future is removed from the dispatcher
loop. <span class="func">WaitFor</span> actually calls <span class="func">poll()</span> in a loop until the future is
finished, and then returns the generic value of the future&#8201;&#8212;&#8201;in the code above,
<span class="func">waitFor</span> returns no actual result, as we used a <span class="type">Future</span> of
<span class="type">void</span> type.</p>
</div>
<div class="paragraph">
<p>We can use the operators <span class="op">and</span> or <span class="op">or</span> to combine multiple futures, in this
way we can wait until all of them or at least one of them completes. Note that the
dispatcher loops stops when waitFor() succeeds, so when we wait only for one future
and that one finished, then the dispatcher loop stops and other futures may stay
unfinished.</p>
</div>
<div class="paragraph">
<p>We can use the function <span class="func">finished()</span> to check if a future variable is already
finished. When a future is finished, it means that either the value that it holds is
now available or it holds an error instead. The latter situation occurs when the
operation to complete a future fails with an exception. We can distinguish between
the two situations with the <span class="func">failed()</span> function. Future objects can also
store a callback procedure which will be called automatically once the future
completes, see the example in the previous section.</p>
</div>
<div class="paragraph">
<p>In our example code above, we called <span class="code">waitFor f1</span>&#8201;&#8212;&#8201;this is necessary to
actually execute the dispatcher loop, and to wait for the future <span class="var">f1</span> to
complete. We could have used <span class="code">waitFor f1 and f2</span>, or <span class="code">waitFor f1 or f2</span>
to wait for completion of both futures or one of them. The result would be identical
in this case, as the <span class="proc">proc</span> that returns <span class="var">f1</span> and <span class="var">f2</span> is identical and
returns always after 2 loop iterations.</p>
</div>
<div class="paragraph">
<p>The important result of this modified code is, that the <span class="proc">proc</span> execution alternates,
and the total runtime of the program is only <span class="lit">0.2 ms</span>. The reason for this is,
as we already explained, that the use of the <span class="key">await</span> keyword in our
<span class="func">tick()</span> <span class="proc">proc</span> suspends the execution, and so immediately the next call of
<span class="func">tick()</span> with <span class="lit">"BBB"</span> as argument is executed.</p>
</div>
<div class="paragraph">
<p>As one more simple example, let us investigate this code, where two different
asynchronous <span class="proc">procs</span> are executed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncdispatch, times]

let to = epochTime()

proc numbers() {.async.} =
  for i in 1 .. 3:
    await sleepAsync(250)
    echo i, ' ', ((epochTime() - to) * 1000).int, " ms"

proc letters() {.async.} =
  for i in 'a' .. 'e':
    await sleepAsync(400)
    echo i, ' ', ((epochTime() - to) * 1000).int, " ms"

var
  n = numbers()
  l = letters()
echo "start: ", ((epochTime() - to) * 1000).int, " ms"
waitFor sleepAsync(1500)
echo "done: ", ((epochTime() - to) * 1000).int, " ms"</code></pre>
</div>
</div>
<div class="paragraph">
<p>As both asynchronous <span class="proc">procs</span> use different arguments when they call
<span class="func">sleepAsync()</span>, they are not executed strictly alternating, so the numbers 2
and 3 are printed with no letter in between:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>start: 0 ms
1 250 ms
a 400 ms
2 500 ms
3 751 ms
b 801 ms
c 1202 ms
done: 1501 ms</pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we do not call <span class="func">waitFor()</span> directly on our actual asynchronous
<span class="proc">procs</span>, but on <span class="func">sleepAsync()</span> from <span class="var">asyncdispatch</span>. As the <span class="proc">procs</span>
<span class="func">numbers()</span> and <span class="fiunc">letters()</span> got registered by the dispatcher, they are
executed by the dispatcher loop, but only as long as determined by <span class="code">waitFor
sleepAsync(1500)</span>. So the execution of the dispatcher loops stops already before
<span class="func">letters()</span> is really done, and letters <span class="lit">d</span> and <span class="lit">e</span> got never
printed. The fact that the printed time values can be a few ms larger than the
actual specified sleep times should not surprise us, as some more code is executed in
our <span class="proc">procs</span>, and as the dispatcher loop itself may need some tiny execution time. When
an exact timing should be required, we may use the <span class="mod">std/times</span> module to read
the exact time and adjust the actual delays. Also note that async/await as a
co-operative approach of multitasking also means that long-running tasks can delay
the execution of other tasks unexpectedly: Imaging that in our code above the numbers
proc would contain a lot of additional code that takes more than 250 ms to run&#8201;&#8212;&#8201;that would confuse the whole timing scheme. As async/await is most often not used to
create actual delays, but for asynchronous network and IO operations, we will not
discuss the problems of exact timing here in detail. The linked paper of P. Munch
discusses this topic in some more detail and offers some possible solutions for more
accurate timings.</p>
</div>
</div>
<div class="sect2">
<h3 id="_file_download">File download</h3>
<div class="paragraph">
<p>The module <span class="mod">std/httpclient</span> of Nim&#8217;s standard library provides procedures for
synchronous and asynchronous file transfer. Let us start with this simple synchronous
example to download two small text files from a URI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/httpclient
let client = newHttpClient()
echo client.getContent("http://ssalewski.de/tmp/texttestpage1.txt")
echo client.getContent("http://ssalewski.de/tmp/texttestpage2.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have uploaded the two plain text files to that location in advance, and when we
compile and run the above code we should get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>This is a plain two
lines test page.

This is one more two
lines test page.</pre>
</div>
</div>
<div class="paragraph">
<p>Nim&#8217;s API documentation for <span class="var">std/httpclient</span> shows us how we can do the
download in an asynchronous way&#8201;&#8212;&#8201;at least for one single file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncdispatch, httpclient]
proc asyncProc(): Future[string] {.async.} =
  let client = newAsyncHttpClient()
  return await client.getContent("http://ssalewski.de/tmp/texttestpage1.txt")
echo waitFor asyncProc()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, we use an asynchronous HTTP client, for which the overloaded <span class="proc">proc</span>
<span class="func">getContent()</span> returns a <span class="type">Future[string]</span> in this case. The call of
<span class="func">waitFor</span> waits for the download to finish and returns the actual content of
the future, which is a string containing the page content.</p>
</div>
<div class="paragraph">
<p>With the knowledge which we get from our previous example with <span class="func">sleepAsync()</span>,
we can easily modify above code to download two files asynchronous:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncdispatch, httpclient]
proc asyncProc(url: string): Future[string] {.async.} =
  return await newAsyncHttpClient().getContent(url)

let f1 = asyncProc("http://ssalewski.de/tmp/texttestpage1.txt")
let f2 = asyncProc("http://ssalewski.de/tmp/texttestpage2.txt")

waitFor f1 and f2 # this returns Future[void]
echo f1.read
echo f2.read</code></pre>
</div>
</div>
<div class="paragraph">
<p>The combination <span class="code">f1 and f2</span> actually creates a new future of void type. We use
two variables <span class="var">f1</span> and <span class="var">f2</span> of string type, and read the content with the
<span class="func">read()</span> <span class="proc">proc</span> when both futures are completed.</p>
</div>
</div>
<div class="sect2">
<h3 id="_a_chat_server_application">A chat server application</h3>
<div class="paragraph">
<p>In the API documentation of the <span class="mod">std/asyncnet</span> module, we find this example for
a very basic chat server application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncnet, asyncdispatch]

var clients {.threadvar.}: seq[AsyncSocket]

proc processClient(client: AsyncSocket) {.async.} =
  while true:
    let line = await client.recvLine()
    if line.len == 0: break
    for c in clients:
      await c.send(line &amp; "\c\L")

proc serve() {.async.} =
  clients = @[]
  var server = newAsyncSocket()
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(Port(12345))
  server.listen()

  while true:
    let client = await server.accept()
    clients.add client

    asyncCheck processClient(client)

asyncCheck serve()
runForever()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The purpose of a chat server is, that multiple clients can connect to a running
server, and then all messages that a client sends to the server got resend to all
other connected clients. So one user can talk to all the other connected users.</p>
</div>
<div class="paragraph">
<p>A chat server has to perform two primary tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Listen for new connections from potential clients</p>
</li>
<li>
<p>Listen for new messages from clients that have already connected to the server</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All the messages that the server receive will need to be sent to every other client
that is currently connected to it.</p>
</div>
<div class="paragraph">
<p>We have not a working client app yet, but in the case that you have the
<span class="ndef">telnet</span> program installed on your computer, you can already use that one to
test this server. Telnet sends messages unencrypted , so its use is generally not
recommended to send messages over the internet, but for testing purposes on the local
net we may use it. If the telnet app is not installed on your computer, you may
install it with the package manager of your OS&#8201;&#8212;&#8201;for Gentoo Linux, we would run
"emerge -av telnet-bsd". An alternative may be the use of the <span class="ndef">busybox</span> app,
which provides the telnet functionality as well.</p>
</div>
<div class="paragraph">
<p>If you have a telnet app available, you may open three terminal windows: On the first
one, you compile and run the server app&#8201;&#8212;&#8201;you will see no output in that window. In
the two other terminals, you type <span class="term">telnet localhost 12345</span> each. That should
start the telnet app, which connects to our running server. When you now type in some
text, that text is echoed to both telnet windows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ telnet localhost 12345
Trying ::1...
telnet: connect to address ::1: Connection refused
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
We use Nim.
We use Nim.

^]
telnet&gt; quit
Connection closed.</pre>
</div>
</div>
<div class="paragraph">
<p>Note that terminating the telnet app is not that simple&#8201;&#8212;&#8201;you may have to type
<span class="term">CTRL ]</span> first, then you get the telnet prompt, where you type <span class="term">quit</span>
to terminate the app.</p>
</div>
<div class="paragraph">
<p>Before we will try to explain the details of above server app, we should summarize a
few facts about network communication. Then, at the end of this section, we will
create a simple client app, which you can use instead of telnet to send messages to
the server.</p>
</div>
<div class="sect3">
<h4 id="_data_transfer_over_a_network">Data transfer over a network</h4>
<div class="paragraph">
<p>For our chat application, we will use the <span class="ndef">TCP</span> protocol, with so-called
network sockets as endpoints. The use of sockets and the TCP protocol is a common
practice in network communication. We will not try to explain any details here, so
citing some definitions from Wikipedia should be enough for now:</p>
</div>
<div class="paragraph">
<p>A computer network is a set of computers sharing resources located on or provided by
network nodes. The computers use common communication protocols over digital
interconnections to communicate with each
other.<sup class="footnote">[<a id="_footnoteref_52" class="footnote" href="#_footnotedef_52" title="View footnote.">52</a>]</sup></p>
</div>
<div class="paragraph">
<p>The <span class="ndef">Internet protocol suite</span>, commonly known as <span class="ndef">TCP/IP</span>, is the set
of communications protocols used in the Internet and similar computer networks. The
current foundational protocols in the suite are the <span class="ndef">Transmission Control
Protocol</span> (TCP) and the <span class="ndef">Internet Protocol</span> (IP). The Internet protocol suite
provides end-to-end data communication specifying how data should be packetized,
addressed, transmitted, routed, and
received.<sup class="footnote">[<a id="_footnoteref_53" class="footnote" href="#_footnotedef_53" title="View footnote.">53</a>]</sup></p>
</div>
<div class="paragraph">
<p>A <span class="ndef">network socket</span> is a software structure within a network node of a computer
network that serves as an endpoint for sending and receiving data across the
network.<sup class="footnote">[<a id="_footnoteref_54" class="footnote" href="#_footnotedef_54" title="View footnote.">54</a>]</sup></p>
</div>
<div class="paragraph">
<p>In Nim, a network socket is represented by the <span class="type">Socket</span> data type, defined in
the <span class="mod">std/net</span> module. We can create new <span class="type">Socket</span> instances with a call
of <span class="func">newSocket()</span> or <span class="func">newAsyncSocket()</span> for synchronous or asynchronous
communication.</p>
</div>
<div class="paragraph">
<p><span class="type">Sockets</span> have some similarity with file descriptors&#8201;&#8212;&#8201;instead of file
operations like read, write and open, for socket instances we have the operations
<span class="func">recv()</span>, <span class="func">send()</span>, <span class="func">connect()</span>, <span class="func">bindAddr()</span> and
<span class="func">listen()</span>. The functions <span class="func">recv()</span> and <span class="func">send()</span> are used to
receive or to send data packages.</p>
</div>
<div class="paragraph">
<p>TCP is a connection-oriented transport protocol that allows the socket to be used as
a server or as a client. A newly created TCP socket is neither until the
<span class="func">bindAddr()</span> or <span class="func">connect()</span> procedure is called. The former transforms
it into a server socket, and the latter into a client socket.</p>
</div>
<div class="paragraph">
<p>By default, the <span class="func">newSocket()</span> constructor will create a TCP socket, but we
could pass more options to the <span class="func">newSocket()</span> constructor for other socket
types or to customize the socket instance.</p>
</div>
<div class="paragraph">
<p>As we want to create a non-blocking, asynchronous server app, we create our socket
instance with a call to <span class="func">newAsyncSocket()</span> of default TCP type, and then bind
it with a call of <span class="func">bindAddr()</span> to a socket address, that is the combination of
an IP address and a port number. The IP address is a string, it may consist of four
or six 8-bit numbers each separated by a period, or of a symbolic name like
<span class="lit">"google.com"</span>. As we want to test our server only on our local network, we use
the default IP address <span class="lit">"localhost"</span>. The port numbers are unsigned 16-bit
numbers in the range from <span class="lit">0</span> to <span class="lit">2^16-1</span>, where the numbers <span class="lit">0 ..
1023</span> are reserved for special tasks and can generally be used only with
administrator privileges. For a real world app, the used port numbers are important,
as server-client communication works only when both use the same port number. For our
experiments, we will use the number <span class="lit">12345</span> from the initial example, as this
one is easily to remember. As the <span class="type">Port</span> type is a distinct unsigned 16-bit
data type, we have to use the notation <span class="lit">Port(12345)</span> for the second parameter
of <span class="func">bindAddr()</span>.</p>
</div>
<div class="paragraph">
<p>We will start our explanations with a simplified code example, where we have removed
the sending of messages to all the clients, and we have replaced some new function
calls like <span class="func">runForever()</span> or <span class="func">asyncCheck()</span> with similar substitutes
that we already know:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[asyncnet, asyncdispatch]

proc processClient(client: AsyncSocket) {.async.} =
  while true:
    let line = await client.recvLine()
    if line.len == 0: break
    echo line

proc serve() {.async.} =
  echo "start serve()"
  let server = newAsyncSocket()
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(Port(12345))
  server.listen()
  while true:
    let client = await server.accept()
    let f1: Future[void] = processClient(client)

let f: Future[void] = serve()
echo "back at main scope"
waitFor sleepAsync(320000)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have two asynchronous <span class="proc">procs</span>, <span class="func">serve()</span> and <span class="func">processClient()</span>, which
are both marked with the <span class="var">{.async.}</span> pragma and return a <span class="type">Future[void]</span>
instance each. Our program starts by calling the <span class="func">serve()</span> <span class="proc">proc</span>. That <span class="proc">proc</span>
creates an asynchronous socket, binds it to <span class="lit">localhost</span> and port <span class="lit">12345</span>,
and starts listening for new connections. At the beginning of the infinite
<span class="code">while true</span> loop, <span class="func">await server.accept()</span> is called to accept new
client connections. As no client tries to connect to the server yet, control is
immediately returned, and the message <span class="lit">"back at main scope"</span> is printed.
Without the last line in our code with the <span class="func">waitFor</span> statement, our program
would terminate now. It is very important that we remember that the call of
<span class="func">serve()</span> does not only call that asynchronous <span class="proc">proc</span>, but also add it to the
global dispatcher loop. And with the last line in our code, we actually run this
dispatcher loop. We have used <span class="code">waitFor sleepAsync(320000)</span> instead of the
original <span class="func">runForever()</span> to make the code look not too foreign&#8201;&#8212;&#8201;running
<span class="lit">320</span> seconds should be good enough for our initial tests. Note that as long
as no client connects to the server, <span class="proc">proc</span> <span class="func">processClient()</span> is not executed at
all. But when a client connects, then <span class="func">processClient()</span> is called for that
client, and an instance of this <span class="func">processClient()</span> <span class="proc">proc</span> with the current client
as argument is added to the global dispatcher loop. This way, a new instance of the
<span class="func">processClient()</span> <span class="proc">proc</span> is added to the dispatcher loop whenever one more
client connects to the server. This results to the fact that we have for each client
its own instance of a <span class="func">processClient()</span> <span class="proc">proc</span> in the dispatcher loop, that is
executed periodically and so can receive data for that client. This way, all connected
clients are served, although we do not have an actual list of all the clients that we
iterate!</p>
</div>
<div class="paragraph">
<p>The actual code in <span class="proc">proc</span> <span class="func">processClient()</span> is not difficult: <span class="code">await
client.recvLine()</span> tries to receive a textual message from the client, and gives
control back to the dispatcher loop when there is no data available. And when there
is data, then we just print it for now. The test for line length zero makes some
sense and is necessary to determine when a client disconnects.</p>
</div>
<div class="paragraph">
<p>When we have managed to understand the simplified code from above, understanding the
original example is easy: We use a sequence with all the connected clients, as we
want to forward each message that we get from one client to all other connected
clients. So the <span class="func">serve()</span> <span class="proc">proc</span> adds each new client to that seq, and <span class="proc">proc</span>
<span class="func">processClient()</span> iterates over that seq and send the received message to all
the connected clients, followed by a <span class="lit">"\c\L"</span> to separate the messages. And
instead of <span class="code">waitFor sleepAsync()</span> <span class="func">runForever()</span> is used, and instead
of assigning the results of the <span class="proc">procs</span> <span class="func">serve()</span> and <span class="func">processClient()</span>
of <span class="type">Future[void]</span> type to an unused variable, or to discarding them, these
results are passed to <span class="func">asyncCheck</span>. <span class="func">AsyncCheck</span> is used to provide us
with some error messages if something goes wrong&#8201;&#8212;&#8201;it sets a callback on the future
argument, which raises an exception if the future should finish with an error state.</p>
</div>
<div class="paragraph">
<p>We hope that you do not wonder about the two infinite "while true" loops anymore&#8201;&#8212;&#8201;for the async/await pattern, such loops makes sense of course, as each await returns
control back to the global dispatcher loop. And the server would run this loop until
it is terminated by <span class="lit">CTRL-C</span> or another OS intervention.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>We have intentionally left out some less important points in the above explanations:
The call of <span class="func">server.setSockOpt(OptReuseAddr, true)</span> should prevent a common
problem when apps using sockets are terminated and restarted: Socket instances are
not immediately removed by the OS when an app terminates, as data packages for that
socket may be still traveling. So a restart of the app may produce an error message like
<span class="lit">"Socket address is already in use"</span>. Another point is that we used not the IP
address string <span class="lit">"localhost"</span>, but leave out that parameter, which seems to
default to the empty string in that case. Well, generally the default should make some
sense, you may test with <span class="lit">"localhost"</span> yourself to see if that may make a
difference. Finally, we append the string <span class="lit">"\c\L"</span> to the messages that we
send out to all of our clients. That is a carriage-return linefeed string, which is
commonly used in network communication to separate messages. You may still wonder
about the capital <span class="lit">"L"</span>&#8201;&#8212;&#8201;well should be identical to <span class="lit">"\l"</span>, you can
verify it yourself.</p>
</div>
<div class="paragraph">
<p>The careful reader may also wonder if initialization of the client list with
<span class="code">clients = @[]</span> is really necessary. No, should not be necessary for recent
Nim versions, maybe that is a legacy from old Nimrod days. And is the threadvar
pragma in <span class="code">var clients {.threadvar.}: seq[AsyncSocket]</span> really needed? Our
guess would be no, as the async/await pattern used in this server app is executed
only on the single main thread of the process. But as we are not sure, we have left
it in.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_the_client_application">The client application</h3>
<div class="paragraph">
<p>The client has to connect to the server, and then to watch for keyboard input from
the user and for arrival of new messages from the server at the same time. So again
we have to care to prevent blocking operations. Unfortunately, reading user input in a
terminal window is always blocking, and there is currently no input method available
that is directly supported by Nim&#8217;s async/await framework. But we presented earlier
in the book already a way to avoid the blocking behavior of the <span class="func">readLine()</span>
proc by use of Nim&#8217;s <span class="var">threadpool</span> library. We will use that method again for
the <span class="func">realLine()</span> calls, and combine it with the async/await pattern for
sending messages to the server and for watching for other messages from the server.
Actually our client example program follows closely the client program from
<span class="ndef">Mr. Picheta</span>, the creator of Nim&#8217;s async/await framework, which he sketched
in the <span class="ndef">Manning</span> book years ago:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">import std/[threadpool, asyncdispatch, asyncnet]

proc doConnect(socket: AsyncSocket, serverAddr: string) {.async.} =
  echo("Connecting to ", serverAddr)
  await socket.connect(serverAddr, Port(12345))
  echo("Connected!")
  while true:
    let line = await socket.recvLine()
    echo "Received Message: ", line

proc main =
  echo("Chat application started")
  var socket = newAsyncSocket()
  asyncCheck doConnect(socket, "localhost")
  var messageFlowVar = spawn stdin.readLine()
  while true:
    if messageFlowVar.isReady():
      asyncCheck socket.send(^messageFlowVar &amp; "\c\l")
      messageFlowVar = spawn stdin.readLine()
    asyncdispatch.poll()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The structure of this client implementation is a bit different from the server one.
The main reason is, that we have to use Nim&#8217;s <span class="var">threadpool</span> and <span class="key">spawn</span> to
avoid the blocking behavior of the <span class="func">readLine()</span> <span class="proc">proc</span>. Note that our
<span class="func">main()</span> <span class="proc">proc</span> is not marked with the <span class="var">{.async.}</span> pragma and contains no
<span class="key">await</span> statement. Only the <span class="func">doConnect()</span> <span class="proc">proc</span>, which connects to the
server and then watches for messages send by the server, is marked with the
<span class="var">async</span> pragma and awaits the new messages. The <span class="func">main()</span> <span class="proc">proc</span> creates
the new asynchronous socket and then calls the asynchronous <span class="proc">proc</span>
<span class="func">doConnect()</span>, which actually connects to the server and enters an infinite
loop watching for messages from the server. When <span class="func">doConnect()</span> calls
<span class="key">await</span>, control flow returns immediately to our <span class="func">main()</span> <span class="proc">proc</span>. But
<span class="func">doConnect()</span> has become a component of the dispatcher loop, so its infinite
<span class="code">while loop</span> with the <span class="key">await</span> statement will gain control back later.
In the <span class="func">main()</span> <span class="proc">proc</span> we then use <span class="func">spawn</span> to execute <span class="func">readLine()</span>
on one thread of the <span class="var">threadpool</span>, and enter a different infinite <span class="code">while
loop</span>. This loops checks if user input is available, and calls poll() to ensure that
the global dispatcher loop is executed. If there is user input available, that
message is send to the server, and <span class="func">spawn</span> is called again waiting for the
next user input.</p>
</div>
<div class="paragraph">
<p>Of course, you may wonder if this client structure really makes sense. At least it
seems to work. But you may be right&#8201;&#8212;&#8201;the use of <span class="func">spawn</span> is an important
component to avoid the blocking terminal input issue, and the dispatcher loop seems
to do not that much contribution.</p>
</div>
<div class="paragraph">
<p>Feel free to experiment with modified client app structures yourself.</p>
</div>
<div class="sect3">
<h4 id="_final_remarks_2">Final remarks</h4>
<div class="paragraph">
<p>Of course, whenever you should intend to create a real world chat application there
are a lot of other tasks to solve and points to discuss: Is the client/server
architecture really the best solution, or may the clients just talk directly to each
other, without the use of a central server? Then there is the problem with the actual
port numbers, as routers and firewalls may block that ports. And finally, you may
intend to send not only plain strings as we did, but structured message&#8201;&#8212;&#8201;maybe add
a time and sender name to each message, and send the content encrypted over the
internet. For encrypting the messages you should find some ideas in Nim' standard
library or in external packages, and sending structured messages is not difficult:
For example we used the JSON format in an earlier section of the book to save
structured objects to disk and reload it later. The object content was encoded as
human-readable text, which you can send of course over the net without any problems.
You just have to define a protocol for the message exchange: Create Nim objects that
contain all the data you want to exchange, like sender name, time, and the actual
message content. Then use one of the <span class="proc">procs</span> provided by the <span class="mod">json</span> module to
encode the object before you send it, and encode it again on the receiving side. The
<span class="mod">json</span> module provides for example the <span class="op">%</span> operator to convert various
data types to JSON strings or JSON objects, and the <span class="func">parseJson()</span> <span class="proc">proc</span> to
convert the text string back into Nim data types. When you have some free time and
are interested in that topic, you can try that yourself, it should be not difficult.
Maybe we will give later in the last part of the book a concrete example for such an
app&#8201;&#8212;&#8201;but maybe that is just too trivial and boring? What you may try as a small
exercise is this: We send the verbatim message over the net, that is exactly what the
user typed in, and we send it to all clients, including the one who initially send
it. So the sender always gets an echoed copy of its input. A simple exercise for you
would be to add a username to each message, so that all clients can see who wrote
it. And you can use that username to identify messages that you send yourself, to
suppress the echoed copy.</p>
</div>
<div class="paragraph">
<p>Another interesting point is, what happens actually when connected clients
disconnect. There should be at least one serious problem: The server stores all the
connected clients in a list, and sends messages to all of them. But what happens when
a client vanished? Sending messages to disconnected clients is not really a good
idea, so the server may remove clients from the list when they disconnect, or at
least mark them as disconnected. And when do we have to call <span class="func">close()</span> on a
client that is disconnecting? We have not used <span class="func">close()</span> at all now, should we
use it in the server or in the client app? We will not try to cover all these details
in this book&#8201;&#8212;&#8201;when you really should intend to do some form of network programming,
you should consult some dedicated literature.</p>
</div>
<div class="paragraph">
<p>For a real world Nim application for network data exchange, you may also investigate
this Twitter clone: <a href="https://github.com/zedeus/nitter" class="bare">https://github.com/zedeus/nitter</a></p>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O" class="bare">https://en.wikipedia.org/wiki/Asynchronous_I/O</a></p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Async/await" class="bare">https://en.wikipedia.org/wiki/Async/await</a></p>
</li>
<li>
<p><a href="https://peterme.net/asynchronous-programming-in-nim.html" class="bare">https://peterme.net/asynchronous-programming-in-nim.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_concepts">Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>to be done&#8230;&#8203;</p>
</div>
</div>
</div>
<h1 id="_appendix" class="sect0">Appendix</h1>
<div class="sect1">
<h2 id="_acknowledgments">Acknowledgments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Special thanks go to Mr. Jim Wilcoxson (<a href="https://github.com/hashbackup" class="bare">https://github.com/hashbackup</a>) who did
proofreading of the first dozen pages of the book and gave some advice on English grammar
and spelling. Thanks go also to Mr. Marek Ľach (<a href="https://github.com/marek-lach" class="bare">https://github.com/marek-lach</a>) for fixing many more spelling and grammar
errors. Finally, a lot of missing commas and some more grammar errors have been detected by use of the
languagetool.org software used from the command line with the pyLanguagetool application.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_nimblea_package_manager"><span class="new">Nimble&#8201;&#8212;&#8201;a package manager</span></h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Note: As its position in the appendix already indicates, this section had a hard time to
make it in the book at all, and it will be the first which is removed in the case
that the (printed) book will become too heavy. You may remember, that we said
in the introduction, that this book will not cover the Nimble package manager at all.
Indeed, there are good reason to leave Nimble out&#8201;&#8212;&#8201;Nimble is not the only package manager, and
Nimble is explained in the Manning book and in the GitHub README already.
Also note, that this section is written from someone with only a very basic knowledge
of the Git version control system, and most content is based on old memories and
have not been tested, as testing a new GitHub registration process is not
easily possible, one would need a valid, but still unused email address for
registration, and one would have to delete the account after the test again.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><span class="ndef">Nimble</span>, initial called <span class="nedef">Babel</span>, is Nim&#8217;s default package manager, which is currently shipped
together with the Nim compiler, and can be used to install additional Nim packages.
Nim packages are collections of Nim modules and other related files, which have been created to
serve a special purpose or to solve a special task, and have been made available to
other Nim users. Nim&#8217;s packages are usually distributed in the form of Nim source code modules,
which are used as libraries. But packages can also contain complete applications programs,
and may even contain pre-compiled executables. In part IV of the book, we have already used the
library packages nim-regex and cligen. An example of a package containing a complete
application is the <span class="ndef">c2nim</span> tool, which can convert C source code to Nim code.
You can find a longer introduction into the Nimble package manager in the Manning book, and a detailed description
on the Nimble GitHub page. As the GitHub page is not really intended as an introduction, and
as some people may not have a copy of the Manning book, we will give a short introduction
into Nimble, which includes its use to install packages, as well as the creation and distribution
of packages.</p>
</div>
<div class="sect2">
<h3 id="_purpose_of_package_managers">Purpose of package managers</h3>
<div class="paragraph">
<p>Package managers are used to install software on single computers or whole computer networks.
The software to install can be libraries, which will be used by other programs, or applications, which can be run
by the user.</p>
</div>
<div class="paragraph">
<p>Packages and package managers can be divided into two categories: Most Linux distributions have one or more
package manager closely couple to the OS, which are used to install libraries and executables for that OS.
These packages managers are usually executed from a user with administrator rights and install
the software system-width, in a way that all users of that computer can access it. Most well known
tools and libraries like Firefox, Gimp, GCC, CGAL, BOOST and GTK are installed this way. The other category
of package managers are the ones which are strongly coupled to a single programming language
and helps the user to install tools or libraries for this programming language. These package-managers
are mostly used by the user directly without administrator privileges and install the software
for this user only&#8201;&#8212;&#8201;other users of the computer would not notice the installation at all.
Well known examples of this latter kind of packages managers are pip for Python, npm for JavaScript,
Gem for Ruby, and finally Nimble for Nim.</p>
</div>
<div class="paragraph">
<p>Package managers do not only simplify the installation, update and de-installation of
software, but they may also install dependencies and resolve versioning conflicts:
When we intend to install a package <span class="lit">A</span>, that package may require again packages
<span class="lit">B</span> and <span class="lit">C</span>, which may again require other packages. Most package managers, including
Nimble can resolve and install dependencies for us automatically.
A big problem can occur when packages are available in multiple, incompatible version.
A common practice is to assign version numbers to packages&#8201;&#8212;&#8201;these version
numbers are typically built of three parts, each separated with a period, like <span class="lit">1.2.14</span>.
Larger numbers indicate a never package version. A common scheme for
version numbers is called <span class="ndef">semantic versioning</span>, where the leftmost number
is the major version, the second number is the minor version, and the rightmost
number is the patch level. The rightmost number is increased for each tiny change of the
software, e.g. for small bug fixes. The minor version number is increased for larger
changes, e.g. when new functionality is added. And the major version number is
only increased, when there are drastically changes, that is when the API has changed,
perhaps due to a complete rewrite of the library.
A major version number of zero often indicates that the package or library is
still in development, and not really considered mature&#8201;&#8212;&#8201;but there are many exceptions
to this rule, many packages, libraries or tools seems to never reach a major
version <span class="lit">1</span>, but still work very fine. On the other hand, a major version greater zero
can indicate some stability promises&#8201;&#8212;&#8201;the API should not change that much anymore,
and the authors may have the feeling that the software works reliable. But this
is very subjective&#8201;&#8212;&#8201;after reaching a version <span class="lit">1.0</span> the development process may just stop, as the authors are exhausted,
or soon after a <span class="lit">1.0</span> release, development of a <span class="lit">2.x</span> version may start, with a completely new API.
So the <span class="lit">1.x</span> version may be stable, but will become legacy soon.
A special aspect of version numbers is, that sometimes the
major version number is increased from zero to one just to indicate some
stability promises, so the content of a version <span class="lit">0.9.7</span> may be nearly identical
with a version <span class="lit">1.0</span>.</p>
</div>
<div class="paragraph">
<p>Unfortunately, even tiny bug fixes for packages or libraries, for which the major and minor version does not change,
can already generate some trouble, as the fix may change the {behave} of the package,
and our application program that uses this package may be sensible to this change.
But these issues are easily fixable. More serious issues may arise when we create larger
applications, that have to use multiple packages: A package <span class="lit">A</span> may be available in two incompatible
major versions <span class="lit">1.7</span> and <span class="lit">2.1</span>. And our software may depend on two external packages called
<span class="lit">B</span> and <span class="lit">C</span>, where package <span class="lit">B</span> requires package <span class="lit">A</span> in version <span class="lit">1.7</span>, but package <span class="lit">C</span> requires package <span class="lit">A</span>
in a version <span class="lit">&gt;= 2.0</span>. This is a serious problem, which may be unresolvable. For OS-bound packages
managers, this is a common concern. It may be solved, when
package updates are bundled, so that when a package changes it major version, all
packages that require it, are also updated. Another possible solution is, that for dynamic libraries
multiple versions are installed in parallel, or that multiple package versions are installed
in so-called <span class="ndef">slots</span>, which can coexists on the same computer. A prominent example
is the GTK GUI toolkit, which can be installed in a <span class="lit">3.0</span> and a <span class="lit">4.0</span> slot. But that is
in no way free from issues&#8201;&#8212;&#8201;an actual example in early 2022 is libsoup, which is currently
available and used in incompatible <span class="lit">2.x</span> and <span class="lit">3.x</span> versions.</p>
</div>
<div class="paragraph">
<p>For package managers like Nimble, that provide only packages related to a
programming languages, version conflicts are not that likely, but
when we create really large applications which require a lot of external packages,
version conflicts may occur. The package manager may help us to resolve
these conflicts by attempting to select a set of package versions that are compatible.</p>
</div>
<div class="paragraph">
<p>Nimble can work with local packages that are stored on the user&#8217;s file system, and with external packages
provided by repository hosting services.
Nimble uses as foundation for external packages <span class="ndef">Distributed Version Control Systems</span> (DVCS)
like Git or Mercurial, and the packages are hosted on online platforms like GitHub or GitLab.</p>
</div>
<div class="paragraph">
<p>While Nim uses currently no dedicated central package repository, it supports a centralized list with
package names and some metadata. We can upload our own packages to hosting servers and register
the package, to allow others a very easy installation. For registered packages, the command
<span class="term">nimble install package_name</span> downloads and installs the package for us. Other packages, that
are available somewhere on the Internet, but are not yet registered in Nim&#8217;s package database,
can be downloaded and installed in a similar way, but we have to specify the full path to the package,
like <a href="https://github.com/stefansalewski/gintro.git" class="bare">https://github.com/stefansalewski/gintro.git</a>.</p>
</div>
<div class="paragraph">
<p>Nimble can be used also to install packages that are locally stored on our computer, this
includes packages that we have manually downloaded from the interned, or packages
that are not saved on a remote location at all.</p>
</div>
<div class="paragraph">
<p>Nimble packages are basically plain directories, which have to include a special text file,
which name is constructed from the package name and the .nimble extension.
These files are sometimes called .nimble files,
and provide some metadata about the package, including the current version, the license,
dependencies, and a short textual description.
The .nimble files use a Nim-based file format that supports a subset of Nim’s features.
We can define variables and procedures in .nimble files, and import other modules.</p>
</div>
<div class="paragraph">
<p>The directory structure of a valid nimble package has to follow
a well-defined shape, which we will discuss later in detail.
When we have a valid local package directory somewhere on our file system, then we can <span class="term">cd</span> into
it and call <span class="term">nimble install</span> to install that package, without having to download all the files (again)
from a remote server. This installation from an existing directory does not only save us the download,
but also allows us to fix the package before the installation. Maybe the package needs some
tiny fixes to compile and work with the latest compiler version?</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Note: Nimble may use the Git tool to download Git repositories, so the <span class="term">nimble</span> command
may not work properly when Git is not installed on your computer. As you will need the Git tool
in any case, you should ensure that it is installed, and install it if it is missing. To check
if Git and Nimble are available, you may execute in a terminal window these commands:
<span class="term">git --version</span> and <span class="term">nimble --version</span></p>
</div>
</div>
</div>
<div class="paragraph">
<p>As a concrete example, we will show the three ways how we can install the <span class="ndef">RTree</span> package:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install rtree
nimble install https://github.com/stefansalewski/RTree.git

cd /tmp
git clone https://github.com/stefansalewski/RTree.git
cd RTree
nimble install</pre>
</div>
</div>
<div class="paragraph">
<p>This works, as the RTree directory has a valid structure, and because
it includes a valid package specification called rtree.nimble:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>/tmp/RTree $ tree
.
├── LICENSE
├── README.adoc
├── rtree.nimble
├── src
│   ├── drawingarea.nim
│   └── rtree.nim
└── tests
    ├── config.nims
    └── test.nim

/tmp/RTree $ cat rtree.nimble
# Package

version       = "0.2.0"
author        = "Stefan Salewski"
description   = "R-Tree"
license       = "MIT"
srcDir        = "src"

# Dependencies

requires "nim &gt;= 1.0.0"

skipFiles = @["drawingarea.nim"]</pre>
</div>
</div>
<div class="paragraph">
<p>When we install a package with Nimble in one of these three ways, Nimble copies
the module files to a location where the Nim compiler can easily find them&#8201;&#8212;&#8201;for the RTree example from above, this is ~/.nimble/pkgs/rtree-0.2.0/
for Linux. Sometimes it may be useful to launch the nimble command with the
--verbose flag, which displays a lot of additional information, including the location where
the module files get installed.</p>
</div>
<div class="paragraph">
<p>Another useful command of the Nimble tool is the <span class="lit">search</span> command, which searches
in Nim&#8217;s central package list for packages marked with tags indicating its purpose.
We may search for terms like GUI, png, mp3 and such. We can combine the search command with
the <span class="lit">--ver</span> flag to get all the versions of the packages listed, like <span class="term">nimble search GTK --ver</span>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_creating_and_publishing_nimble_packages">Creating and publishing Nimble packages</h3>
<div class="paragraph">
<p>For creating new packages, we can create the folder structure and the .nimble file manually, maybe by copying
an existing package and editing it, or we can use the <span class="term">nimble init</span> command.
When we use <span class="term">nimble init</span>, we can first create a folder, <span class="term">cd</span> into that folder and call <span class="term">nimble init</span>,
or we let Nimble create the folder by specifying the folder name like <span class="term">nimble init MyTest</span>.
Nimble will ask a few questions, and create the folder structure for us. You should test this exercise now,
to get a feeling for the process. Just move to a temporary directory like <span class="term">/tmp</span> on Linux, and enter
<span class="term">nimble init MyNewPkg</span>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble init MyNewPkg
... accepting all the defaults results in

/tmp $ tree MyNewPkg/
MyNewPkg/
├── MyNewPkg.nimble
├── src
│   ├── MyNewPkg
│   │   └── submodule.nim
│   └── MyNewPkg.nim
└── tests
    ├── config.nims
    └── test1.nim

cat MyNewPkg/MyNewPkg.nimble
# Package

version       = "0.1.0"
author        = "Stefan Salewski"
description   = "A new awesome nimble package"
license       = "MIT"
srcDir        = "src"


# Dependencies

requires "nim &gt;= 1.7.1"</pre>
</div>
</div>
<div class="paragraph">
<p>We see immediately a tiny issue: Nimble accepts the package name with upper case letters, and use
it for the module name. But by convention, module names should be all lower case for Nim. We can manually fix that,
or use a package name with all lowercase letters.
For most packages, names with only lower case letters should be OK, but sometimes
we may like to have package names like RTtree. Note that the package name itself
and all the file and folder names of the package should not contain hyphens or the <span class="italic">at</span> symbols ('-', '@')&#8201;&#8212;&#8201;the minus sign is generally not allowed for Nim symbols, and the <span class="lit">@</span> has a special meaning for Nimble.</p>
</div>
<div class="paragraph">
<p>Important is, that the created directory
structure contains the .nimble file, and a <span class="var">scr</span> folder. When our whole package consists of only one module,
that file would be MyNewPkg/src/mynewpkg.nim, and we would not need the subdirectory
MyNewPkg/src/MyNewPkg. After installation of the packages, we could use the module then
just as <span class="code">import mynewpkg</span>. For the case that our package consists of multiple files,
we put the files in the folder MyNewPkg/src/mynewpkg and import the files as
<span class="code">import mynewpkg/[mod1, mod5]</span>.</p>
</div>
<div class="paragraph">
<p>Another, sometimes useful functionality of Nimble is, that we can
define task at the end of .nimble files, like</p>
</div>
<div class="listingblock">
<div class="content">
<pre>task test, "Run the packages tests!":
  exec "nim r tests/mytest.nim"</pre>
</div>
</div>
<div class="paragraph">
<p>This allows us to execute <span class="term">nimble test</span> from within the package directory
to compile and run package tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_public_packages">Public packages</h3>
<div class="paragraph">
<p>Currently, most external Nim packages are hosted at GitHub, but other Git platforms
like GitLab should work also with Nimble, and in principle even the Mercurial format
should be supported.</p>
</div>
<div class="paragraph">
<p>As GitHub is currently very popular, we will briefly explain how you can create public
Nim GitHub packages. First, you need a GitHub account, which you can create easily by following
the instruction on their homepage at GitHub.com. You require your username, a valid email address, and have to select your GitHub password.
Since August 2021 GitHub requires to use personal access tokens instead of the original passwords,
when you want to modify your repositories. For the case that GitHub has not asked you to create an access token during
the initial registration, you have to create one now before you can continue. The GitHub page or
a search engine should give you the detailed instructions how you can create a personal access token.
The token is a long ASCII string, which you may store in some file, and paste in later when
GitHub ask for passwords when uploading files. Later, you can save the token in the local git database
somehow, that may save you from the copy/paste process.</p>
</div>
<div class="paragraph">
<p>When you have an account, you can easily create new public repositories following the instructions
on the GitHub page. Let us assume you have created a repository named fft, a package
to support the <span class="ndef">fast Fourier transform</span>. Then you can download that Git repository with
this instruction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git clone https://github.com/yourname/fft.git</pre>
</div>
</div>
<div class="paragraph">
<p>To make a valid Nimble package out of this repository, you have at least to create
the subdirectory src/fft and a fft.nimble file. You can do this manually, or you
can do it with <span class="term">nimble init fft</span> or <span class="term">cd fft; nimble init</span>.<sup class="footnote">[<a id="_footnoteref_55" class="footnote" href="#_footnotedef_55" title="View footnote.">55</a>]</sup>
If your package consist of only one file, you should call it <span class="var">fft.nim</span> and copy it into
<span class="var">fft/src/</span>. Or, if you have multiple files, create a directory <span class="var">fft/src/fft</span> and copy the files
to that location, maybe with file names <span class="var">fft.nim</span> and <span class="var">ffpsup.nim</span>.
As you have modified the local repository folder, it is not consistent anymore with
the remote repository. You can check that with the command <span class="term">git status</span> executed inside the folder.
To make it consistent again, you have to push your changes to the GitHub server, which can be done with these
commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git add -A
git commit -m "created initial Nimble file"
git push origin main
git status</pre>
</div>
</div>
<div class="paragraph">
<p>The command <span class="term">add -A</span> adds all the created files and directories to the Git content,
the <span class="term">commit -m</span> commits the changes with the specified message, and
finally <span class="term">push origin main</span> uploads all the modifications to GitHub.
When you now visit the GitHub page of your remote repository, you should
see the changes.</p>
</div>
<div class="paragraph">
<p>Other people can now already install your package by</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install https://github.com/yourname/fft.git
# or with
git clone https://github.com/yourname/fft.git
cd fft
nimble install</pre>
</div>
</div>
<div class="paragraph">
<p>Whenever you create or update a package, you should care for possible dependencies
and the required compiler version. The requirements field of the .nimble file
lists all the dependencies, like <span class="term">requires "nim &gt;= 1.6.0", nim-regex, bigints</span>.
Nimble supports the command <span class="lit">c</span>,
which can be used from within a package directory, and
which we can use to compile the package and to verify the requirements:
While the command <span class="term">nim c myapp.nim</span> always searches for libraries at
all known locations (current folder, Nimble packages, and standard library)
the command <span class="term">nimble c myapp.nim</span> firsts check the requirement field of
<span class="var">myapp.nimble</span>, and refuses to use nimble packages that are not listed under
requirements. On the other hand, when an external package is listed under requirements, but is not yet
installed, then the <span class="term">nimble c</span> command tries to install it.</p>
</div>
<div class="paragraph">
<p>If you think that your package is really useful for many other Nim users,
you may decide to publish your package, that is to add it to Nim&#8217;s central
package list. This can be done in two ways: You can just call
from within your package folder the command <span class="term">nimble publish</span>.
Then you are asked for some data, e.g. a list of tag names and a description,
and the publishing process should start. After manual approval
by some Nim devs, which checks if your package has a valid structure
and its name does not conflict with existing packages, your packages
gets added to the official package list. Unfortunately, the <span class="term">nimble publish</span>
command have failed for some people in the past. So you may prefer
to publish your package manually by creating a pull request at
the package list repository.</p>
</div>
<div class="paragraph">
<p>After successful publication, people can download your package just by giving its name,
that is with <span class="term">nimble install fft</span>. This publishing process may be a bit complicated, but it
is necessary only ones: It is not necessary to publish the package again, when you update the package.</p>
</div>
<div class="paragraph">
<p>When you intend to create a public packages, that is used by a lot of people and that is regularly
updated, it may make some sense to create tagged versions of your package. That way people will
be able to easily install an older version, in the case that they have issues with the most recent version,
and other packages, that may use your package, can require the version that they need.
Currently, creating tagged versions with Nimble is a bit complicated, as you have to update the
version in the .nimble file first: Actually the correct procedure to add a (new) tag is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Update all the files of your packages, that includes all the modules and the README file.</p>
</li>
<li>
<p>Update the version field in the nimble file.</p>
</li>
<li>
<p>Upload all your modifications to GitHub, with an action sequence like</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>git add -A
git commit -m "new version v0.2.1"
git push origin main</pre>
</div>
</div>
<div class="paragraph">
<p>Now, after you have uploaded all modified files, including the nimble file with the version
field update to this new version, you can
create a new tag and push the actual version tags to Github:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>git tag v0.2.1
git push origin --tags</pre>
</div>
</div>
<div class="paragraph">
<p>Now, other users will get this new version by default, but they can still
install older versions. For testing purposes, you can always push modified
module files to GitHub, without creating a new tag. These changes will be invisible
for most users, only users that explicitly request the latest changes with the tag <span class="lit">\#head</span>
will get these latest changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>nimble install fft # install latest tagged version, or
nimble install fft@v0.2.0 # install existing older version, or
nimble install fft@#head # install latest changes</pre>
</div>
</div>
<div class="paragraph">
<p>References:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/" class="bare">https://github.com/</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/nimble" class="bare">https://github.com/nim-lang/nimble</a></p>
</li>
<li>
<p><a href="https://github.com/nim-lang/packages" class="bare">https://github.com/nim-lang/packages</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ascii_table">ASCII Table</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">proc print(i: int) =
  let c =
    if i &gt; 31 and i &lt; 128: char(i) else: ' '
  stdout.write("  ", c, "  ")

proc main =
  echo "Visible ASCII Characters\n"
  stdout.write("     ")
  for i in 0 .. 15:
    if i &lt; 10:
       stdout.write(" +")
    else:
      stdout.write("+")
    stdout.write(i, "  ")
  stdout.write('\n')
  var i = 0
  while i &lt; 128:
    if i &lt; 10:
      stdout.write("  ")
    elif i &lt; 100:
      stdout.write(" ")
    stdout.write(i, ' ')
    for j in 0 .. 15:
      print(i + j)
    stdout.write('\n')
    inc(i, 16)

main()</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_div_and_mod_operation">Div and Mod operation</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-nim" data-lang="nim">type
  T = array[-5 .. 4, int]
  T2 = array[-5 .. 4, T]

var t: T2

for d in 0 .. 1:
  if d == 0:
    echo "\nResult of i div j"
  else:
    echo "\nResult of i mod j"
  for i in -5 .. 4: # row
    for j in -5 .. 4: # col
      if i == -5 and j == -5:
          t[i][j] = int.high
      elif i == -5:
        t[i][j] = j
      elif j == -5:
        t[i][j] = i
      else:
        if j == 0:
          t[i][j] = int.high
        else:
          if d == 0:
            t[i][j] = i div j
          else:
            t[i][j] = i mod j

  for i in -5 .. 4:
    for j in -5 .. 4:
      if t[i][j] &gt;= 0:
        stdout.write(" ")
      if t[i][j] == int.high:
        stdout.write("  ")
      else:
        stdout.write(t[i][j], " ")
    echo ""</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_text_styles">Text styles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We use semantic markup with these text styles:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>New text: <span class="new">This is new stuff</span></p>
</li>
<li>
<p>Recent text: <span class="recent">This was recently updated</span></p>
</li>
<li>
<p>First use: <span class="ndef">term</span></p>
</li>
<li>
<p>Italic: <span class="italic">This is italic</span></p>
</li>
<li>
<p>Operators: <span class="op">+ - &amp; shl</span></p>
</li>
<li>
<p>Keywords: <span class="key">var ref object import while</span></p>
</li>
<li>
<p>Use of proc in text: <span class="proc">proc</span></p>
</li>
<li>
<p>Use of macro in text: <span class="mac">macro</span></p>
</li>
<li>
<p>Data types: <span class="type">float int Table</span></p>
</li>
<li>
<p>String data type: <span class="str">string</span></p>
</li>
<li>
<p>Array data type: <span class="array">array</span></p>
</li>
<li>
<p>Function calls: <span class="func">setLen()</span></p>
</li>
<li>
<p>Variables: <span class="var">i, j, length</span></p>
</li>
<li>
<p>Module names: <span class="mod">strutils, system, io</span></p>
</li>
<li>
<p>Literals: <span class="lit">100, false, 3.14</span></p>
</li>
<li>
<p>Constants: <span class="const">fmWrite</span></p>
</li>
<li>
<p>Code in text: <span class="code">while a &gt; 0 and not done:</span></p>
</li>
<li>
<p>Terminal text: <span class="term">nim c -gc:arc test.nim</span></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the term "proc", which is a Nim keyword, we use no keyword markup, as
it occurs so often. Maybe we will later write just procedure instead.
And we do the same for the macro keyword.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_changelog">ChangeLog</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_november_2021">November 2021</h3>
<div class="paragraph">
<p>We have added a few more simple examples and exercises:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#_removing_adjacent_duplicates">Removing adjacent duplicates</a></p>
</li>
<li>
<p><a href="#_array_difference">Array difference</a></p>
</li>
<li>
<p><a href="#_binary_search">Binary search</a></p>
</li>
<li>
<p><a href="#_integer_to_string_conversion">Integer to string conversion</a></p>
</li>
<li>
<p><a href="#_no_game_programming">No Game Programming?</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_februar_2022">Februar 2022</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#Regular Expressions">[Regular Expressions]</a></p>
</li>
<li>
<p><a href="#Part V: External Packages">[Part V: External Packages]</a></p>
</li>
<li>
<p><a href="#_templates">Templates</a> (extended)</p>
</li>
<li>
<p><a href="#_iterators">Iterators</a> (extended)</p>
</li>
<li>
<p><a href="#_exceptions">Exceptions</a> (extended)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_march_2022">March 2022</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#Option types">[Option types]</a></p>
</li>
<li>
<p><a href="#Command line parsing">[Command line parsing]</a></p>
</li>
<li>
<p><a href="#Cligen">a Command-Line Interface generator</a></p>
</li>
<li>
<p><a href="#Nimble">[Nimble]</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. In the past, some form of analog computers existed, some worked mechanically, some used analog voltages or currents as input and output signals. Indeed, one important device which is still very common in analog electronics is the summing amplifier, which can sum up multiple electric voltages.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Well, when we watch very carefully, we will notice that the signal is not really digital&#8201;&#8212;&#8201;when we switch on, the filament may take a few milliseconds to heat up, and when we switch off, the filament takes again a few milliseconds to cool down.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. Of course even digital electric signals can not really "jump" from one digital state to another, but the transition time is much shorter than the time duration of the steady state, so the signal has a rectangular shape when we watch it on an oscilloscope, it looks like __--__--__.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. Well, before the OS is loaded and starts execution, often another tiny program called a <span class="ndef">Boot Manager</span> is launched. Boot managers are used to select different operating systems to boot, maybe Linux or Windows, or to pass parameters as the hard disk boot partition number to the OS.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. The search for the reason why a program does not do exactly what was hoped for by its creators is called debugging. That term is still a legacy from the very first computers in the 50s, where logical circuits were built by mechanical relays, for example a logical <span class="term">and</span> operation was built by two relays in series connection. To let the current flow, both of them would have to be in the conducting state. And it was told that sometimes insects walked onto the electric contacts of the relays and blocked them. Today, misbehavior of computer programs is rarely due to hardware faults, but the term "bugs" for errors and "debugging" for finding and fixing the errors, was kept.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. Exactly speaking, Ruby and Python do not really interpret the source code, but compile it on the fly to byte-code, which is then interpreted. And there exists some variants of Ruby and Python that compile with some success to native machine code. Crystal is a variant of Ruby, with some significant differences, that compiles to fast native machine code.
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. Indeed, an experimental LLVM backend is already available by third party contributors.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. Indeed, the Nim compiler compiles itself three times in this time period to ensure a stable result. Incremental compilation may further reduce recompile times soon.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. This syntax is well known from the D programming language, where it was called Uniform Function Call Syntax (UFCS).
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. If you still wonder why this works that way in decimal and binary system: Remember how we determine the value of a literal number. We sum the digits multiplied with powers of the base. And if we multiply an arbitrary number with the base, each of these powers increases obviously by one. Write it on a piece of paper when it is not yet clear to you.
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. If you have a piece of paper and a pencil at hand, you may test some properties of signed binary numbers represented in two&#8217;s complement: take binary 0, apply the two&#8217;s complement operation to get the negative of it. Note, we ignore overflow here when we add the 1! That was easy. Can we verify that all negative numbers in two&#8217;s complement can really be identified by its set topmost bit? Maybe that fact is not really obvious, as we not only invert all bits of the positive number, but also add 1. OK, let us consider the non-negative numbers 0 .. 127 for an 8-bit word. All those bit patterns have the topmost bit cleared and all bit combinations used in the other 7 bits. Inverting these patterns gives us a pattern with the leftmost bit set, and again all bit combinations used in the other 7 bits. Fine, so far, the topmost bit is set, but we still have to add 1 to complete our two&#8217;s complement operation. But the only case where adding 1 changes the topmost bit is when the 7 other bits are all set, and that is only the case when the initial value before bit inversion was zero. So the leftmost bit remains set for all numbers except initial zero, and zero maps to zero again!
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. For the current Nim implementation, signed overflow generates an overflow exception, while unsigned types just wrap around. For C it is similar&#8201;&#8212;&#8201;for C99 it is defined that unsigned int types wrap around, while the behavior for signed ints is undefined and depends on the actual implementation of the C compiler.
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. Actually, the code above would not compile, as the cos() function has to be imported from the <span class="mod">math</span> module. A first line like "from std/math import cos" would fix that, but we leave that out by intend for now.
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. Here <span class="func">len()</span> is a predefined function of the Nim standard library, len() is short for length, and that function returns the actual length of a text string as an integer value.
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. When we are using the term "size" here, this means how much space an instance of that type occupies in the RAM of the computer. A type of size 4 would occupy 4 bytes of the RAM of your computer.
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. The fact that in the current Nim implementation of A. Rumpf float is identical to float64 should be seen as an implementation detail. For other implementations, the float size may depend on OS and CPU.
</div>
<div class="footnote" id="_footnotedef_17">
<a href="#_footnoteref_17">17</a>. Well, to some degree&#8201;&#8212;&#8201;Inf &#43; 1.0 is still Inf, but for Inf / Inf the result is not that obvious&#8230;&#8203;
</div>
<div class="footnote" id="_footnotedef_18">
<a href="#_footnoteref_18">18</a>. Here we use already the for loops, which will be introduced later in the book.
</div>
<div class="footnote" id="_footnotedef_19">
<a href="#_footnoteref_19">19</a>. Arrays are homogenous, fixed size containers, we will learn the details later.
</div>
<div class="footnote" id="_footnotedef_20">
<a href="#_footnoteref_20">20</a>. We will explain later in this book what pointers are, so if you have no idea for what pointers are used in computer programming, then just ignore it for now.
</div>
<div class="footnote" id="_footnotedef_21">
<a href="#_footnoteref_21">21</a>. Well we have a backspace key on our keyboard, but generally it does not insert a backspace character but deletes the character to the left of the cursor when we are editing text. And the return key, well, it indeed inserts a newline character, but at the same time in our editor the cursor moves to the next line. Most of the time, we desire a character that generates a newline when we run our program, but not when we enter our source code.
</div>
<div class="footnote" id="_footnotedef_22">
<a href="#_footnoteref_22">22</a>. The base types can be sum types, we will discuss them later.
</div>
<div class="footnote" id="_footnotedef_23">
<a href="#_footnoteref_23">23</a>. It can be difficult to remember if we have to write [8, int
</div>
<div class="footnote" id="_footnotedef_24">
<a href="#_footnoteref_24">24</a>. A start index of 1 may appear to be more natural, some text books use start indices 1, and indeed one advantage of start index 1 is, that in his case, the length and the highest position index of the container are identical. But for systems programming languages like C it is a common practice to start at zero.
</div>
<div class="footnote" id="_footnotedef_25">
<a href="#_footnoteref_25">25</a>. Well with some luck the RAM area after the currently used memory block is still unused. For this case the OS may offer functions like realloc() to just increase our memory block size, so we can avoid the copying of the contained data.
</div>
<div class="footnote" id="_footnotedef_26">
<a href="#_footnoteref_26">26</a>. Actually, we can not really delete elements from an array, as it has a fixed size&#8201;&#8212;&#8201;but of course we can just ignore elements at the end of the array.
</div>
<div class="footnote" id="_footnotedef_27">
<a href="#_footnoteref_27">27</a>. In some special cases, it may be useful to just overwrite entries with special marker values, instead of actual deleting them. That operation is fast, order is maintained, and for operations like data output we can just ignore the marker entries. But this is really only a good solution is special cases, maybe just using a different container type like a list or hash table is a preferable solution.
</div>
<div class="footnote" id="_footnotedef_28">
<a href="#_footnoteref_28">28</a>. Sometimes the compiler may refuse to accept the addr() function, for example for variables defined with the let keyword. For that case, we may have to use the function unsafeAddr().
</div>
<div class="footnote" id="_footnotedef_29">
<a href="#_footnoteref_29">29</a>. The name of this temporary variable is fully arbitrary and does not indicate a special meaning. We could have used el as abbreviation for element, t or temp to indicate that it is only a temporary variable. We use the name "node" here because that is a common term for the elements in linked lists, trees or similar dynamically created data structures. We could have used the single letter n instead of "node", but n is already used for the actual friend&#8217;s name entered by the user.
</div>
<div class="footnote" id="_footnotedef_30">
<a href="#_footnoteref_30">30</a>. There may be situations, where we want to pass a value parameter to a <span class="proc">proc</span>, but still need to modify it in the <span class="proc">proc</span> body. For that case we can make just a mutable copy, and the copy can even have the same name as the <span class="proc">proc</span> parameter, like <span class="code">var myPar = myPar</span>.
</div>
<div class="footnote" id="_footnotedef_31">
<a href="#_footnoteref_31">31</a>. We learned already about pointers, and passing var parameters to procedures and functions is closely related to pointers: The compiler passes indeed the address of the var parameter. But we have not to care about these details.
</div>
<div class="footnote" id="_footnotedef_32">
<a href="#_footnoteref_32">32</a>. Of course, compiler become smarter every day, so that restriction may disappear in the future.
</div>
<div class="footnote" id="_footnotedef_33">
<a href="#_footnoteref_33">33</a>. Automatically inlining of <span class="proc">procs</span> from imported modules is not easy, as the C compiler backend does only inline functions from other source code files when link time optimization is enabled. With the inline pragma applied, the Nim compiler copies that <span class="proc">proc</span> from the imported module to the module where it is actually used, so the C compiler can inline it.
</div>
<div class="footnote" id="_footnotedef_34">
<a href="#_footnoteref_34">34</a>. <a href="https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-firstminusclass-iterators" class="bare">https://nim-lang.org/docs/manual.html#iterators-and-the-for-statement-firstminusclass-iterators</a>
</div>
<div class="footnote" id="_footnotedef_35">
<a href="#_footnoteref_35">35</a>. <a href="https://en.wikipedia.org/wiki/Generic_programming" class="bare">https://en.wikipedia.org/wiki/Generic_programming</a>
</div>
<div class="footnote" id="_footnotedef_36">
<a href="#_footnoteref_36">36</a>. In principle, as the compiler may always optimize that.
</div>
<div class="footnote" id="_footnotedef_37">
<a href="#_footnoteref_37">37</a>. And in case you find out for what these SkipTable is used, let us know :-)
</div>
<div class="footnote" id="_footnotedef_38">
<a href="#_footnoteref_38">38</a>. The careful reader may notice that we forget to process the float value for the corner radius in this example.
</div>
<div class="footnote" id="_footnotedef_39">
<a href="#_footnoteref_39">39</a>. A nimMax() is supposed to be faster than separate min() and max() calls, as minMax() would have to iterate through all the items in RAM only once.
</div>
<div class="footnote" id="_footnotedef_40">
<a href="#_footnoteref_40">40</a>. <a href="https://en.wikipedia.org/wiki/Metacharacter" class="bare">https://en.wikipedia.org/wiki/Metacharacter</a>
</div>
<div class="footnote" id="_footnotedef_41">
<a href="#_footnoteref_41">41</a>. <a href="https://en.wikipedia.org/wiki/Regular_expression" class="bare">https://en.wikipedia.org/wiki/Regular_expression</a>
</div>
<div class="footnote" id="_footnotedef_42">
<a href="#_footnoteref_42">42</a>. Unfortunately, we have used the term STACK in two different meanings in this section: For our recursive sorting <span class="proc">proc</span> we are talking about the CPU stack, which is used to pass <span class="proc">proc</span> parameters and store <span class="proc">proc</span> local data&#8201;&#8212;&#8201;and can overflow. In our nonrecursive <span class="proc">proc</span> we use a variable which is also called stack, but that is only an ordinary buffer variable. The term stack is common for such buffers, where we can push() and pop() values.
</div>
<div class="footnote" id="_footnotedef_43">
<a href="#_footnoteref_43">43</a>. From introductory courses to Computer Science, people generally remember QuickSort best, just because of its name and its good performance, as long as we ignore the worst case scenario and the not stable sorting order.
</div>
<div class="footnote" id="_footnotedef_44">
<a href="#_footnoteref_44">44</a>. Ruby provides such an operator: <a href="https://ruby-doc.org/core-3.0.0/Array.html#method-i-2D" class="bare">https://ruby-doc.org/core-3.0.0/Array.html#method-i-2D</a>
</div>
<div class="footnote" id="_footnotedef_45">
<a href="#_footnoteref_45">45</a>. Well, for a small data set, maybe up to a few dozen entries, a linear search may be the fastest still. We have observed this behavior already for our various sorting strategies&#8201;&#8212;&#8201;logarithmic, interval halving strategies pays off only for not too tiny data sets.
</div>
<div class="footnote" id="_footnotedef_46">
<a href="#_footnoteref_46">46</a>. <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" class="bare">https://en.wikipedia.org/wiki/Parsing_expression_grammar</a>
</div>
<div class="footnote" id="_footnotedef_47">
<a href="#_footnoteref_47">47</a>. Of course, the example from above works only for lines containing only lower case words&#8201;&#8212;&#8201;we will present a better line splitting example soon.
</div>
<div class="footnote" id="_footnotedef_48">
<a href="#_footnoteref_48">48</a>. This definition is from the Nim macros tutorial written by A. Doering, a former paid Nim core developer
</div>
<div class="footnote" id="_footnotedef_49">
<a href="#_footnoteref_49">49</a>. This definition is from the Nim macros tutorial written by A. Doering, a former paid Nim core developer
</div>
<div class="footnote" id="_footnotedef_50">
<a href="#_footnoteref_50">50</a>. <a href="https://en.wikipedia.org/wiki/Async/await" class="bare">https://en.wikipedia.org/wiki/Async/await</a>
</div>
<div class="footnote" id="_footnotedef_51">
<a href="#_footnoteref_51">51</a>. <a href="https://peterme.net/asynchronous-programming-in-nim.html" class="bare">https://peterme.net/asynchronous-programming-in-nim.html</a>
</div>
<div class="footnote" id="_footnotedef_52">
<a href="#_footnoteref_52">52</a>. <a href="https://en.wikipedia.org/wiki/Computer_network" class="bare">https://en.wikipedia.org/wiki/Computer_network</a>
</div>
<div class="footnote" id="_footnotedef_53">
<a href="#_footnoteref_53">53</a>. .https://en.wikipedia.org/wiki/Internet_protocol_suite
</div>
<div class="footnote" id="_footnotedef_54">
<a href="#_footnoteref_54">54</a>. <a href="https://en.wikipedia.org/wiki/Network_socket" class="bare">https://en.wikipedia.org/wiki/Network_socket</a>
</div>
<div class="footnote" id="_footnotedef_55">
<a href="#_footnoteref_55">55</a>. Be careful when you execute the init command on directories which do already contain valuable data, as Nimble may overwrite files. Make a backup!
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-03-25 21:04:08 +0100
</div>
</div>
</body>
</html>